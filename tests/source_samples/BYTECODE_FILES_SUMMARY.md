# Bytecode Files for Syntax Domains

## Overview

I've generated bytecode output files for each syntax domain to make debugging much easier. Each domain now has both raw and mapped bytecode outputs.

## File Structure

```
tests/source_samples/
├── python/                          # Source files
│   ├── imports/test_imports.py
│   ├── basics/test_basics.py
│   └── ... (10 domains)
├── javascript/                      # Source files
│   ├── imports/test_imports.js
│   ├── basics/test_basics.js
│   └── ... (10 domains)
├── python_bytecode/                 # Generated bytecode
│   ├── imports/
│   │   ├── test_imports_bytecode.txt          # Raw numeric opcodes
│   │   └── test_imports_bytecode_mapped.txt   # Readable mapped opcodes
│   └── ... (10 domains)
└── javascript_bytecode/             # Generated bytecode
    ├── imports/
    │   ├── test_imports_bytecode.txt
    │   └── test_imports_bytecode_mapped.txt
    └── ... (10 domains)
```

## Quick Debugging Commands

### View Specific Domain Bytecode
```bash
# View readable bytecode for Python control flow
uv run python util/view_domain_bytecode.py python control_flow

# View raw bytecode for JavaScript functions  
uv run python util/view_domain_bytecode.py javascript functions --raw

# Compare raw vs mapped side-by-side
uv run python util/view_domain_bytecode.py python operators --compare
```

### Find Issues Across Domains
```bash
# Search for missing opcodes across all Python domains
grep -r "JUMP_BACKWARD" tests/source_samples/python_bytecode/

# Check scope handling across domains
grep -r "LOAD_FAST\|STORE_FAST" tests/source_samples/python_bytecode/
```

### List Available Domains
```bash
uv run python util/view_domain_bytecode.py --list
```

## Benefits for Debugging

### 1. **Isolated Issue Analysis**
- Focus on specific language constructs without noise
- Each domain file tests one aspect of the language
- Easier to trace issues to their source

### 2. **Easy Comparison**
- Raw bytecode shows actual numeric values
- Mapped bytecode shows readable instruction names
- Side-by-side comparison reveals mapping issues

### 3. **Faster Iteration**
- Test changes to specific constructs quickly
- No need to regenerate massive files
- Clear separation of concerns

## Examples of What Each Domain Tests

### Python Domains
- **imports**: Import patterns, conditional imports, dynamic imports
- **basics**: Literals, comments, basic assignments  
- **data_types**: Lists, dicts, sets, string operations
- **control_flow**: if/else, loops, try/except, with statements
- **functions**: Function calls, decorators, closures, KW_NAMES
- **oop**: Classes, inheritance, properties, special methods
- **advanced**: Comprehensions, async/await, unpacking, walrus operator
- **stdlib**: Standard library usage (math, json, collections)
- **dynamic**: eval, exec, introspection, global/nonlocal
- **operators**: Binary operations, subscripts, comparisons

### JavaScript Domains
- **imports**: ES6 imports, CommonJS require patterns
- **basics**: Variables, literals, basic syntax
- **data_types**: Arrays, objects, type coercion
- **control_flow**: if/else, loops, switch, try/catch  
- **functions**: Functions, arrows, closures, async
- **oop**: Classes, prototypes, inheritance
- **advanced**: Promises, generators, destructuring
- **builtin**: JSON, Date, Math, RegExp objects
- **dynamic**: eval, dynamic properties, global access
- **operators**: Binary ops, subscripts, optional chaining

## Regenerating Bytecode

After making changes to the compiler:

```bash
# Regenerate all domain bytecode files
uv run python util/generate_domain_bytecode.py

# Also regenerate main test outputs if needed
uv run python util/regenerate_test_data.py
```

## Common Debugging Patterns

### Finding Missing Opcodes
```bash
# Check if LOAD_FAST appears in comprehensions
uv run python util/view_domain_bytecode.py python advanced --mapped | grep LOAD_FAST

# Verify while loops have JUMP_BACKWARD
uv run python util/view_domain_bytecode.py python control_flow --mapped | grep JUMP_BACKWARD
```

### Checking Scope Issues
```bash
# Global vs local variable handling
uv run python util/view_domain_bytecode.py python dynamic --mapped | grep -E "LOAD_GLOBAL|LOAD_NAME"

# Nonlocal variable handling
uv run python util/view_domain_bytecode.py python dynamic --mapped | grep DEREF
```

### Verifying Fixes
```bash
# Before fix: Check current output
uv run python util/view_domain_bytecode.py python advanced --compare

# After fix: Regenerate and check again
uv run python util/generate_domain_bytecode.py
uv run python util/view_domain_bytecode.py python advanced --compare
```

This structure makes it much easier to identify and fix bytecode generation issues for specific language constructs!