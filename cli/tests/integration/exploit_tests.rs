//! Native library exploit detection tests.
//!
//! Verifies that malwi detects C-level syscalls (open, socket, connect) made by
//! malicious native libraries loaded via Python ctypes or executed as standalone
//! binaries. These tests simulate real supply chain attacks where native .so/.dylib
//! files perform credential theft and data exfiltration entirely at the C level,
//! bypassing runtime-level (Python/Node.js) tracing.

use std::io::Write;
use std::path::PathBuf;
use std::process::{Command, Output, Stdio};
use std::time::Duration;

use crate::common::*;
use crate::skip_if_no_node_primary;
use crate::skip_if_no_python_primary;

fn setup() {
    build_fixtures();
}

static POLICY_COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(0);

fn write_temp_policy(content: &str) -> (PathBuf, std::fs::File) {
    let dir = std::env::temp_dir();
    let id = POLICY_COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    let path = dir.join(format!(
        "malwi-exploit-test-policy-{}-{}.yaml",
        std::process::id(),
        id
    ));
    let mut f = std::fs::File::create(&path).expect("failed to create temp policy file");
    f.write_all(content.as_bytes()).expect("failed to write policy");
    f.flush().expect("failed to flush policy");
    (path, f)
}

/// Get the path to the malicious shared library fixture.
fn malicious_lib_path() -> PathBuf {
    #[cfg(target_os = "macos")]
    let name = "malicious_lib.dylib";
    #[cfg(not(target_os = "macos"))]
    let name = "malicious_lib.so";
    fixture(name)
}

/// Run the tracer with extra environment variables passed to the child process.
fn run_tracer_with_env(
    args: &[&str],
    env_vars: &[(&str, &str)],
    timeout: Duration,
) -> Output {
    use std::thread;

    let mut cmd = Command::new(tracer_binary());
    cmd.args(args)
        .current_dir(fixtures_dir())
        .env("MALWI_AGENT_LIB", agent_library())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped());

    for &(key, val) in env_vars {
        cmd.env(key, val);
    }

    let mut child = cmd.spawn().expect("failed to spawn tracer");

    let stdout_pipe = child.stdout.take().unwrap();
    let stderr_pipe = child.stderr.take().unwrap();

    let stdout_thread = thread::spawn(move || {
        let mut buf = Vec::new();
        std::io::Read::read_to_end(&mut std::io::BufReader::new(stdout_pipe), &mut buf).ok();
        buf
    });
    let stderr_thread = thread::spawn(move || {
        let mut buf = Vec::new();
        std::io::Read::read_to_end(&mut std::io::BufReader::new(stderr_pipe), &mut buf).ok();
        buf
    });

    let start = std::time::Instant::now();
    loop {
        match child.try_wait() {
            Ok(Some(status)) => {
                let stdout = stdout_thread.join().unwrap_or_default();
                let stderr = stderr_thread.join().unwrap_or_default();
                return Output { status, stdout, stderr };
            }
            Ok(None) => {
                if start.elapsed() > timeout {
                    let _ = child.kill();
                    let stdout = stdout_thread.join().unwrap_or_default();
                    let stderr = stderr_thread.join().unwrap_or_default();
                    let status = child.wait().expect("failed to wait after kill");
                    return Output { status, stdout, stderr };
                }
                thread::sleep(Duration::from_millis(50));
            }
            Err(e) => panic!("Error waiting for tracer: {}", e),
        }
    }
}

/// Create a dummy sensitive file for steal_file tests.
/// Returns the path; caller is responsible for cleanup.
fn create_dummy_sensitive_file() -> PathBuf {
    let dir = std::env::temp_dir().join(".ssh-malwi-test");
    std::fs::create_dir_all(&dir).expect("failed to create dummy .ssh dir");
    let path = dir.join(format!("id_rsa_{}", std::process::id()));
    std::fs::write(&path, "DUMMY_PRIVATE_KEY_FOR_TESTING\n").expect("failed to write dummy key");
    path
}

fn cleanup_sensitive_file(path: &PathBuf) {
    let _ = std::fs::remove_file(path);
    if let Some(parent) = path.parent() {
        let _ = std::fs::remove_dir(parent);
    }
}

// ============================================================================
// Test A: Python loads malicious .so — file read detected via native tracing
// ============================================================================

/// Python loads `malicious_lib.so` via ctypes and calls `steal_file()`.
/// The C code calls `open()` on a sensitive path. malwi hooks `open` at the
/// native symbol level and traces the call — proving malwi-hook catches C-level
/// calls even when Python never called `open()` at the Python level.
///
/// Note: We trace (not block) `open` because blocking it globally prevents
/// Python from starting (it needs `open()` for module imports).
#[test]
fn test_python_ctypes_native_lib_file_read_detected() {
    setup();

    let sensitive_file = create_dummy_sensitive_file();
    let lib_path = malicious_lib_path();

    assert!(
        lib_path.exists(),
        "malicious_lib not built: {}",
        lib_path.display()
    );

    let sensitive_path_str = sensitive_file.to_str().unwrap();
    let lib_path_str = lib_path.to_str().unwrap();

    let py_code = format!(
        "import ctypes, os; \
         lib = ctypes.CDLL(os.environ['MALWI_TEST_LIB']); \
         lib.steal_file.argtypes = [ctypes.c_char_p]; \
         lib.steal_file.restype = ctypes.c_int; \
         lib.steal_file(b'{}')",
        sensitive_path_str
    );

    skip_if_no_python_primary!(python => {
        let output = run_tracer_with_env(
            &[
                "x",
                "-s", "open",
                "--",
                python.to_str().unwrap(),
                "-c", &py_code,
            ],
            &[("MALWI_TEST_LIB", lib_path_str)],
            Duration::from_secs(10),
        );

        let stdout_raw = String::from_utf8_lossy(&output.stdout);
        let stdout = strip_ansi_codes(&stdout_raw);
        let stderr = String::from_utf8_lossy(&output.stderr);

        // The C-level open() call inside the .so should be traced by malwi-hook.
        // We look for the sensitive file path in the traced open() arguments.
        assert!(
            stdout.contains("open") && stdout.contains(".ssh-malwi-test"),
            "Expected open() trace with sensitive file path. C-level open() inside .so should be caught by malwi-hook.\nstdout:\n{}\nstderr:\n{}",
            stdout, stderr
        );
    });

    cleanup_sensitive_file(&sensitive_file);
}

// ============================================================================
// Test B: Python loads malicious .so — network exfil blocked
// ============================================================================

/// Python loads `malicious_lib.so` and calls `exfil_data()`.
/// The C code calls `socket()`. malwi's symbol policy blocks it.
/// Unlike `open`, Python doesn't need `socket()` to start, so blocking is safe.
#[test]
fn test_python_ctypes_native_lib_socket_blocked() {
    setup();

    let lib_path = malicious_lib_path();

    assert!(
        lib_path.exists(),
        "malicious_lib not built: {}",
        lib_path.display()
    );

    let (policy_path, _f) = write_temp_policy(
        "version: 1\nsymbols:\n  deny:\n    - socket\n",
    );

    let lib_path_str = lib_path.to_str().unwrap();

    let py_code = "import ctypes, os; \
         lib = ctypes.CDLL(os.environ['MALWI_TEST_LIB']); \
         lib.exfil_data.argtypes = [ctypes.c_char_p, ctypes.c_int]; \
         lib.exfil_data.restype = ctypes.c_int; \
         lib.exfil_data(b'127.0.0.1', 4444)";

    skip_if_no_python_primary!(python => {
        let output = run_tracer_with_env(
            &[
                "x",
                "-p", policy_path.to_str().unwrap(),
                "--",
                python.to_str().unwrap(),
                "-c", py_code,
            ],
            &[("MALWI_TEST_LIB", lib_path_str)],
            Duration::from_secs(10),
        );

        let stdout_raw = String::from_utf8_lossy(&output.stdout);
        let stdout = strip_ansi_codes(&stdout_raw);
        let stderr = String::from_utf8_lossy(&output.stderr);

        assert!(
            stdout.contains("denied:") && stdout.contains("socket"),
            "Expected denied message for socket(). C-level socket() inside .so should be caught.\nstdout:\n{}\nstderr:\n{}",
            stdout, stderr
        );
    });

    let _ = std::fs::remove_file(&policy_path);
}

// ============================================================================
// Test C: Python full exploit chain — socket blocked + file access traced
// ============================================================================

/// Python calls `exploit()` which runs both file theft (open) and network
/// exfil (socket). Policy blocks `socket`, proving the exfil stage is caught
/// even when it's part of a multi-stage C-level attack chain.
/// File theft detection is proven separately in test_python_ctypes_native_lib_file_read_detected.
#[test]
fn test_python_ctypes_native_lib_full_exploit_blocked() {
    setup();

    let sensitive_file = create_dummy_sensitive_file();
    let lib_path = malicious_lib_path();

    assert!(
        lib_path.exists(),
        "malicious_lib not built: {}",
        lib_path.display()
    );

    let (policy_path, _f) = write_temp_policy(
        "version: 1\nsymbols:\n  deny:\n    - socket\n",
    );

    let sensitive_path_str = sensitive_file.to_str().unwrap();
    let lib_path_str = lib_path.to_str().unwrap();

    let py_code = format!(
        "import ctypes, os; \
         lib = ctypes.CDLL(os.environ['MALWI_TEST_LIB']); \
         lib.exploit.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]; \
         lib.exploit.restype = ctypes.c_int; \
         lib.exploit(b'{}', b'127.0.0.1', 4444)",
        sensitive_path_str
    );

    skip_if_no_python_primary!(python => {
        let output = run_tracer_with_env(
            &[
                "x",
                "-p", policy_path.to_str().unwrap(),
                "--",
                python.to_str().unwrap(),
                "-c", &py_code,
            ],
            &[("MALWI_TEST_LIB", lib_path_str)],
            Duration::from_secs(10),
        );

        let stdout_raw = String::from_utf8_lossy(&output.stdout);
        let stdout = strip_ansi_codes(&stdout_raw);
        let stderr = String::from_utf8_lossy(&output.stderr);

        // The exfiltration stage should be blocked — socket() denied
        assert!(
            stdout.contains("denied:") && stdout.contains("socket"),
            "Expected denied message for socket() in full exploit chain.\nstdout:\n{}\nstderr:\n{}",
            stdout, stderr
        );
    });

    let _ = std::fs::remove_file(&policy_path);
    cleanup_sensitive_file(&sensitive_file);
}

// ============================================================================
// Test D: Native malicious binary — full exploit blocked (no Python/Node.js)
// ============================================================================

/// Directly trace the malicious binary with symbol-level blocking.
/// No Python or Node.js involved — pure native binary. Both `open` and `socket`
/// can be blocked since the binary is simple and doesn't need them for startup.
#[test]
fn test_native_malicious_binary_full_exploit_blocked() {
    setup();

    let sensitive_file = create_dummy_sensitive_file();
    let target = fixture("malicious_target");

    assert!(
        target.exists(),
        "malicious_target not built: {}",
        target.display()
    );

    let (policy_path, _f) = write_temp_policy(
        "version: 1\nsymbols:\n  deny:\n    - open\n    - socket\n",
    );

    let output = run_tracer_with_timeout(
        &[
            "x",
            "-p", policy_path.to_str().unwrap(),
            "--",
            target.to_str().unwrap(),
            sensitive_file.to_str().unwrap(),
            "127.0.0.1",
            "4444",
        ],
        Duration::from_secs(10),
    );

    let stdout_raw = String::from_utf8_lossy(&output.stdout);
    let stdout = strip_ansi_codes(&stdout_raw);
    let stderr = String::from_utf8_lossy(&output.stderr);

    // Both stages should be blocked at the symbol level
    assert!(
        stdout.contains("denied:") && stdout.contains("open"),
        "Expected denied message for open() in native binary.\nstdout:\n{}\nstderr:\n{}",
        stdout, stderr
    );
    assert!(
        stdout.contains("denied:") && stdout.contains("socket"),
        "Expected denied message for socket() in native binary.\nstdout:\n{}\nstderr:\n{}",
        stdout, stderr
    );

    let _ = std::fs::remove_file(&policy_path);
    cleanup_sensitive_file(&sensitive_file);
}

// ============================================================================
// Test E: Node.js spawns malicious binary — command layer blocks it
// ============================================================================

/// Node.js uses child_process.execSync to run the malicious binary.
/// The commands policy blocks the spawn at the exec layer.
/// This tests the realistic npm postinstall scenario.
#[test]
fn test_nodejs_child_process_runs_malicious_binary_blocked() {
    setup();

    let target = fixture("malicious_target");

    assert!(
        target.exists(),
        "malicious_target not built: {}",
        target.display()
    );

    let (policy_path, _f) = write_temp_policy(
        "version: 1\ncommands:\n  deny:\n    - malicious_target\n",
    );

    let target_path = target.to_str().unwrap();

    // Node.js tries to exec the malicious binary — command policy should block it
    let js_code = format!(
        "try {{ require('child_process').execSync('{}'); }} catch(e) {{}}",
        target_path
    );

    skip_if_no_node_primary!(node => {
        let output = run_tracer_with_timeout(
            &[
                "x",
                "-p", policy_path.to_str().unwrap(),
                "--",
                node.to_str().unwrap(),
                "-e", &js_code,
            ],
            Duration::from_secs(10),
        );

        let stdout_raw = String::from_utf8_lossy(&output.stdout);
        let stdout = strip_ansi_codes(&stdout_raw);
        let stderr = String::from_utf8_lossy(&output.stderr);

        assert!(
            stdout.contains("denied:") && stdout.contains("malicious_target"),
            "Expected denied message for malicious_target command.\nstdout:\n{}\nstderr:\n{}",
            stdout, stderr
        );
    });

    let _ = std::fs::remove_file(&policy_path);
}
