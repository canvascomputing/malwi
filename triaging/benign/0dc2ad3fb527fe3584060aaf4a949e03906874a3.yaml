statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/urllib3/contrib/securetransport.py
  contents:
  - name: _read_callback
    score: 0.0
    code: |-
      def _read_callback(connection_id, data_buffer, data_length_pointer):
          """
          SecureTransport read callback. This is called by ST to request that data
          be returned from the socket.
          """
          wrapped_socket = None
          try:
              wrapped_socket = _connection_refs.get(connection_id)
              if wrapped_socket is None:
                  return SecurityConst.errSSLInternal
              base_socket = wrapped_socket.socket

              requested_length = data_length_pointer[0]

              timeout = wrapped_socket.gettimeout()
              error = None
              read_count = 0
              buffer = (ctypes.c_char * requested_length).from_address(data_buffer)
              buffer_view = memoryview(buffer)

              try:
                  while read_count < requested_length:
                      if timeout is None or timeout >= 0:
                          readables = util.wait_for_read([base_socket], timeout)
                          if not readables:
                              raise socket.error(errno.EAGAIN, 'timed out')

                      # We need to tell ctypes that we have a buffer that can be
                      # written to. Upsettingly, we do that like this:
                      chunk_size = base_socket.recv_into(
                          buffer_view[read_count:requested_length]
                      )
                      read_count += chunk_size
                      if not chunk_size:
                          if not read_count:
                              return SecurityConst.errSSLClosedGraceful
                          break
              except (socket.error) as e:
                  error = e.errno

                  if error is not None and error != errno.EAGAIN:
                      if error == errno.ECONNRESET:
                          return SecurityConst.errSSLClosedAbort
                      raise

              data_length_pointer[0] = read_count

              if read_count != requested_length:
                  return SecurityConst.errSSLWouldBlock

              return 0
          except Exception as e:
              if wrapped_socket is not None:
                  wrapped_socket._exception = e
              return SecurityConst.errSSLInternal
    tokens: resume load_const store_fast wrapped_socket nop load_global STRING_LEN_S_ENT_HIGH load_attr get load_fast connection_id call store_fast wrapped_socket load_fast wrapped_socket pop_jump_if_not_none TO_NUMBER load_global SecurityConst load_attr errSSLInternal return_value load_fast wrapped_socket load_attr socket store_fast base_socket load_fast STRING_LEN_S_ENT_HIGH load_const INTEGER binary_subscr store_fast STRING_LEN_S_ENT_HIGH load_fast wrapped_socket load_attr gettimeout call store_fast timeout load_const store_fast error load_const INTEGER store_fast read_count load_global ctypes load_attr c_char load_fast STRING_LEN_S_ENT_HIGH binary_op * load_attr from_address load_fast data_buffer call store_fast buffer load_global memoryview load_fast buffer call store_fast buffer_view nop load_fast read_count load_fast STRING_LEN_S_ENT_HIGH compare_op < pop_jump_if_false TO_NUMBER load_fast timeout pop_jump_if_none TO_NUMBER load_fast timeout load_const INTEGER compare_op >= pop_jump_if_false TO_NUMBER load_global util load_attr wait_for_read load_fast base_socket build_list load_fast timeout call store_fast readables load_fast readables pop_jump_if_true TO_NUMBER load_global socket load_attr error load_global errno load_attr EAGAIN load_const timed out call raise_varargs load_fast base_socket load_attr recv_into load_fast buffer_view load_fast read_count load_fast STRING_LEN_S_ENT_HIGH binary_slice call store_fast chunk_size load_fast read_count load_fast chunk_size binary_op += store_fast read_count load_fast chunk_size pop_jump_if_true TO_NUMBER load_fast read_count pop_jump_if_true TO_NUMBER load_global SecurityConst load_attr STRING_BASE64_LEN_S_ENT_HIGH return_value jump_forward TO_NUMBER load_fast read_count load_fast STRING_LEN_S_ENT_HIGH compare_op < pop_jump_if_false TO_NUMBER jump_backward TO_NUMBER load_fast read_count load_fast STRING_LEN_S_ENT_HIGH load_const INTEGER store_subscr load_fast read_count load_fast STRING_LEN_S_ENT_HIGH compare_op != pop_jump_if_false TO_NUMBER load_global SecurityConst load_attr STRING_BASE64_LEN_S_ENT_HIGH return_value return_const 0 push_exc_info load_global socket load_attr error check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_fast e load_attr errno store_fast error load_fast error pop_jump_if_none TO_NUMBER load_fast error load_global errno load_attr EAGAIN compare_op != pop_jump_if_false TO_NUMBER load_fast error load_global errno load_attr ECONNRESET compare_op == pop_jump_if_false TO_NUMBER load_global SecurityConst load_attr STRING_LEN_S_ENT_HIGH swap pop_except load_const store_fast e delete_fast e return_value raise_varargs pop_except load_const store_fast e delete_fast e jump_backward TO_NUMBER load_const store_fast e delete_fast e reraise reraise copy pop_except reraise push_exc_info load_global Exception check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_fast wrapped_socket pop_jump_if_none TO_NUMBER load_fast e load_fast wrapped_socket store_attr _exception load_global SecurityConst load_attr errSSLInternal swap pop_except load_const store_fast e delete_fast e return_value load_const store_fast e delete_fast e reraise reraise copy pop_except reraise
    hash: e3a6097d3dce48d3566396b053b5a4536905d2b0e95781b68d9e601e34f35373
sources:
  .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/urllib3/contrib/securetransport.py: IiIiClNlY3VyZVRyYW5wb3J0IHN1cHBvcnQgZm9yIHVybGxpYjMgdmlhIGN0eXBlcy4KClRoaXMgbWFrZXMgcGxhdGZvcm0tbmF0aXZlIFRMUyBhdmFpbGFibGUgdG8gdXJsbGliMyB1c2VycyBvbiBtYWNPUyB3aXRob3V0IHRoZQp1c2Ugb2YgYSBjb21waWxlci4gVGhpcyBpcyBhbiBpbXBvcnRhbnQgZmVhdHVyZSBiZWNhdXNlIHRoZSBQeXRob24gUGFja2FnZQpJbmRleCBpcyBtb3ZpbmcgdG8gYmVjb21lIGEgVExTdjEuMi1vci1oaWdoZXIgc2VydmVyLCBhbmQgdGhlIGRlZmF1bHQgT3BlblNTTAp0aGF0IHNoaXBzIHdpdGggbWFjT1MgaXMgbm90IGNhcGFibGUgb2YgZG9pbmcgVExTdjEuMi4gVGhlIG9ubHkgd2F5IHRvIHJlc29sdmUKdGhpcyBpcyB0byBnaXZlIG1hY09TIHVzZXJzIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIHRvIHRoZSBwcm9ibGVtLCBhbmQgdGhhdApzb2x1dGlvbiBpcyB0byB1c2UgU2VjdXJlVHJhbnNwb3J0LgoKV2UgdXNlIGN0eXBlcyBoZXJlIGJlY2F1c2UgdGhpcyBzb2x1dGlvbiBtdXN0IG5vdCByZXF1aXJlIGEgY29tcGlsZXIuIFRoYXQncwpiZWNhdXNlIHBpcCBpcyBub3QgYWxsb3dlZCB0byByZXF1aXJlIGEgY29tcGlsZXIgZWl0aGVyLgoKVGhpcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgYSBzZXJpb3VzbHkgbG9uZy10ZXJtIHNvbHV0aW9uIHRvIHRoaXMgcHJvYmxlbS4KVGhlIGhvcGUgaXMgdGhhdCBQRVAgNTQzIHdpbGwgZXZlbnR1YWxseSBzb2x2ZSB0aGlzIGlzc3VlIGZvciB1cywgYXQgd2hpY2gKcG9pbnQgd2UgY2FuIHJldGlyZSB0aGlzIGNvbnRyaWIgbW9kdWxlLiBCdXQgaW4gdGhlIHNob3J0IHRlcm0sIHdlIG5lZWQgdG8Kc29sdmUgdGhlIGltcGVuZGluZyB0aXJlIGZpcmUgdGhhdCBpcyBQeXRob24gb24gTWFjIHdpdGhvdXQgdGhpcyBraW5kIG9mCmNvbnRyaWIgbW9kdWxlLiBTby4uLmhlcmUgd2UgYXJlLgoKVG8gdXNlIHRoaXMgbW9kdWxlLCBzaW1wbHkgaW1wb3J0IGFuZCBpbmplY3QgaXQ6OgoKICAgIGltcG9ydCB1cmxsaWIzLmNvbnRyaWIuc2VjdXJldHJhbnNwb3J0CiAgICB1cmxsaWIzLmNvbnRyaWIuc2VjdXJldHJhbnNwb3J0LmluamVjdF9pbnRvX3VybGxpYjMoKQoKSGFwcHkgVExTaW5nIQoiIiIKZnJvbSBfX2Z1dHVyZV9fIGltcG9ydCBhYnNvbHV0ZV9pbXBvcnQKCmltcG9ydCBjb250ZXh0bGliCmltcG9ydCBjdHlwZXMKaW1wb3J0IGVycm5vCmltcG9ydCBvcy5wYXRoCmltcG9ydCBzaHV0aWwKaW1wb3J0IHNvY2tldAppbXBvcnQgc3NsCmltcG9ydCB0aHJlYWRpbmcKaW1wb3J0IHdlYWtyZWYKCmZyb20gLi4gaW1wb3J0IHV0aWwKZnJvbSAuX3NlY3VyZXRyYW5zcG9ydC5iaW5kaW5ncyBpbXBvcnQgKAogICAgU2VjdXJpdHksIFNlY3VyaXR5Q29uc3QsIENvcmVGb3VuZGF0aW9uCikKZnJvbSAuX3NlY3VyZXRyYW5zcG9ydC5sb3dfbGV2ZWwgaW1wb3J0ICgKICAgIF9hc3NlcnRfbm9fZXJyb3IsIF9jZXJ0X2FycmF5X2Zyb21fcGVtLCBfdGVtcG9yYXJ5X2tleWNoYWluLAogICAgX2xvYWRfY2xpZW50X2NlcnRfY2hhaW4KKQoKdHJ5OiAgIyBQbGF0Zm9ybS1zcGVjaWZpYzogUHl0aG9uIDIKICAgIGZyb20gc29ja2V0IGltcG9ydCBfZmlsZW9iamVjdApleGNlcHQgSW1wb3J0RXJyb3I6ICAjIFBsYXRmb3JtLXNwZWNpZmljOiBQeXRob24gMwogICAgX2ZpbGVvYmplY3QgPSBOb25lCiAgICBmcm9tIC4ucGFja2FnZXMuYmFja3BvcnRzLm1ha2VmaWxlIGltcG9ydCBiYWNrcG9ydF9tYWtlZmlsZQoKdHJ5OgogICAgbWVtb3J5dmlldyhiJycpCmV4Y2VwdCBOYW1lRXJyb3I6CiAgICByYWlzZSBJbXBvcnRFcnJvcigiU2VjdXJlVHJhbnNwb3J0IG9ubHkgd29ya3Mgb24gUHl0aG9ucyB3aXRoIG1lbW9yeXZpZXciKQoKX19hbGxfXyA9IFsnaW5qZWN0X2ludG9fdXJsbGliMycsICdleHRyYWN0X2Zyb21fdXJsbGliMyddCgojIFNOSSBhbHdheXMgd29ya3MKSEFTX1NOSSA9IFRydWUKCm9yaWdfdXRpbF9IQVNfU05JID0gdXRpbC5IQVNfU05JCm9yaWdfdXRpbF9TU0xDb250ZXh0ID0gdXRpbC5zc2xfLlNTTENvbnRleHQKCiMgVGhpcyBkaWN0aW9uYXJ5IGlzIHVzZWQgYnkgdGhlIHJlYWQgY2FsbGJhY2sgdG8gb2J0YWluIGEgaGFuZGxlIHRvIHRoZQojIGNhbGxpbmcgd3JhcHBlZCBzb2NrZXQuIFRoaXMgaXMgYSBwcmV0dHkgc2lsbHkgYXBwcm9hY2gsIGJ1dCBmb3Igbm93IGl0J2xsCiMgZG8uIEkgZmVlbCBsaWtlIEkgc2hvdWxkIGJlIGFibGUgdG8gc211Z2dsZSBhIGhhbmRsZSB0byB0aGUgd3JhcHBlZCBzb2NrZXQKIyBkaXJlY3RseSBpbiB0aGUgU1NMQ29ubmVjdGlvblJlZiwgYnV0IGZvciBub3cgdGhpcyBhcHByb2FjaCB3aWxsIHdvcmsgSQojIGd1ZXNzLgojCiMgV2UgbmVlZCB0byBsb2NrIGFyb3VuZCB0aGlzIHN0cnVjdHVyZSBmb3IgaW5zZXJ0cywgYnV0IHdlIGRvbid0IGRvIGl0IGZvcgojIHJlYWRzL3dyaXRlcyBpbiB0aGUgY2FsbGJhY2tzLiBUaGUgcmVhc29uaW5nIGhlcmUgZ29lcyBhcyBmb2xsb3dzOgojCiMgICAgMS4gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGNhbGwgaW50byB0aGUgY2FsbGJhY2tzIGJlZm9yZSB0aGUgZGljdGlvbmFyeSBpcwojICAgICAgIHBvcHVsYXRlZCwgc28gb25jZSBpbiB0aGUgY2FsbGJhY2sgdGhlIGlkIG11c3QgYmUgaW4gdGhlIGRpY3Rpb25hcnkuCiMgICAgMi4gVGhlIGNhbGxiYWNrcyBkb24ndCBtdXRhdGUgdGhlIGRpY3Rpb25hcnksIHRoZXkgb25seSByZWFkIGZyb20gaXQsIGFuZAojICAgICAgIHNvIGNhbm5vdCBjb25mbGljdCB3aXRoIGFueSBvZiB0aGUgaW5zZXJ0aW9ucy4KIwojIFRoaXMgaXMgZ29vZDogaWYgd2UgaGFkIHRvIGxvY2sgaW4gdGhlIGNhbGxiYWNrcyB3ZSdkIGRyYXN0aWNhbGx5IHNsb3cgZG93bgojIHRoZSBwZXJmb3JtYW5jZSBvZiB0aGlzIGNvZGUuCl9jb25uZWN0aW9uX3JlZnMgPSB3ZWFrcmVmLldlYWtWYWx1ZURpY3Rpb25hcnkoKQpfY29ubmVjdGlvbl9yZWZfbG9jayA9IHRocmVhZGluZy5Mb2NrKCkKCiMgTGltaXQgd3JpdGVzIHRvIDE2a0IuIFRoaXMgaXMgT3BlblNTTCdzIGxpbWl0LCBidXQgd2UnbGwgY2FyZ28tY3VsdCBpdCBvdmVyCiMgZm9yIG5vIGJldHRlciByZWFzb24gdGhhbiB3ZSBuZWVkICphKiBsaW1pdCwgYW5kIHRoaXMgb25lIGlzIHJpZ2h0IHRoZXJlLgpTU0xfV1JJVEVfQkxPQ0tTSVpFID0gMTYzODQKCiMgVGhpcyBpcyBvdXIgZXF1aXZhbGVudCBvZiB1dGlsLnNzbF8uREVGQVVMVF9DSVBIRVJTLCBidXQgZXhwYW5kZWQgb3V0IHRvCiMgaW5kaXZpZHVhbCBjaXBoZXIgc3VpdGVzLiBXZSBuZWVkIHRvIGRvIHRoaXMgYmVjdWFzZSB0aGlzIGlzIGhvdwojIFNlY3VyZVRyYW5zcG9ydCB3YW50cyB0aGVtLgpDSVBIRVJfU1VJVEVTID0gWwogICAgU2VjdXJpdHlDb25zdC5UTFNfRUNESEVfRUNEU0FfV0lUSF9BRVNfMjU2X0dDTV9TSEEzODQsCiAgICBTZWN1cml0eUNvbnN0LlRMU19FQ0RIRV9SU0FfV0lUSF9BRVNfMjU2X0dDTV9TSEEzODQsCiAgICBTZWN1cml0eUNvbnN0LlRMU19FQ0RIRV9FQ0RTQV9XSVRIX0FFU18xMjhfR0NNX1NIQTI1NiwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0VDREhFX1JTQV9XSVRIX0FFU18xMjhfR0NNX1NIQTI1NiwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0RIRV9EU1NfV0lUSF9BRVNfMjU2X0dDTV9TSEEzODQsCiAgICBTZWN1cml0eUNvbnN0LlRMU19ESEVfUlNBX1dJVEhfQUVTXzI1Nl9HQ01fU0hBMzg0LAogICAgU2VjdXJpdHlDb25zdC5UTFNfREhFX0RTU19XSVRIX0FFU18xMjhfR0NNX1NIQTI1NiwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0RIRV9SU0FfV0lUSF9BRVNfMTI4X0dDTV9TSEEyNTYsCiAgICBTZWN1cml0eUNvbnN0LlRMU19FQ0RIRV9FQ0RTQV9XSVRIX0FFU18yNTZfQ0JDX1NIQTM4NCwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0VDREhFX1JTQV9XSVRIX0FFU18yNTZfQ0JDX1NIQTM4NCwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0VDREhFX0VDRFNBX1dJVEhfQUVTXzI1Nl9DQkNfU0hBLAogICAgU2VjdXJpdHlDb25zdC5UTFNfRUNESEVfUlNBX1dJVEhfQUVTXzI1Nl9DQkNfU0hBLAogICAgU2VjdXJpdHlDb25zdC5UTFNfREhFX1JTQV9XSVRIX0FFU18yNTZfQ0JDX1NIQTI1NiwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0RIRV9EU1NfV0lUSF9BRVNfMjU2X0NCQ19TSEEyNTYsCiAgICBTZWN1cml0eUNvbnN0LlRMU19ESEVfUlNBX1dJVEhfQUVTXzI1Nl9DQkNfU0hBLAogICAgU2VjdXJpdHlDb25zdC5UTFNfREhFX0RTU19XSVRIX0FFU18yNTZfQ0JDX1NIQSwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0VDREhFX0VDRFNBX1dJVEhfQUVTXzEyOF9DQkNfU0hBMjU2LAogICAgU2VjdXJpdHlDb25zdC5UTFNfRUNESEVfUlNBX1dJVEhfQUVTXzEyOF9DQkNfU0hBMjU2LAogICAgU2VjdXJpdHlDb25zdC5UTFNfRUNESEVfRUNEU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEEsCiAgICBTZWN1cml0eUNvbnN0LlRMU19FQ0RIRV9SU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEEsCiAgICBTZWN1cml0eUNvbnN0LlRMU19ESEVfUlNBX1dJVEhfQUVTXzEyOF9DQkNfU0hBMjU2LAogICAgU2VjdXJpdHlDb25zdC5UTFNfREhFX0RTU19XSVRIX0FFU18xMjhfQ0JDX1NIQTI1NiwKICAgIFNlY3VyaXR5Q29uc3QuVExTX0RIRV9SU0FfV0lUSF9BRVNfMTI4X0NCQ19TSEEsCiAgICBTZWN1cml0eUNvbnN0LlRMU19ESEVfRFNTX1dJVEhfQUVTXzEyOF9DQkNfU0hBLAogICAgU2VjdXJpdHlDb25zdC5UTFNfUlNBX1dJVEhfQUVTXzI1Nl9HQ01fU0hBMzg0LAogICAgU2VjdXJpdHlDb25zdC5UTFNfUlNBX1dJVEhfQUVTXzEyOF9HQ01fU0hBMjU2LAogICAgU2VjdXJpdHlDb25zdC5UTFNfUlNBX1dJVEhfQUVTXzI1Nl9DQkNfU0hBMjU2LAogICAgU2VjdXJpdHlDb25zdC5UTFNfUlNBX1dJVEhfQUVTXzEyOF9DQkNfU0hBMjU2LAogICAgU2VjdXJpdHlDb25zdC5UTFNfUlNBX1dJVEhfQUVTXzI1Nl9DQkNfU0hBLAogICAgU2VjdXJpdHlDb25zdC5UTFNfUlNBX1dJVEhfQUVTXzEyOF9DQkNfU0hBLApdCgojIEJhc2ljYWxseSB0aGlzIGlzIHNpbXBsZTogZm9yIFBST1RPQ09MX1NTTHYyMyB3ZSB0dXJuIGl0IGludG8gYSBsb3cgb2YKIyBUTFN2MSBhbmQgYSBoaWdoIG9mIFRMU3YxLjIuIEZvciBldmVyeXRoaW5nIGVsc2UsIHdlIHBpbiB0byB0aGF0IHZlcnNpb24uCl9wcm90b2NvbF90b19taW5fbWF4ID0gewogICAgc3NsLlBST1RPQ09MX1NTTHYyMzogKFNlY3VyaXR5Q29uc3Qua1RMU1Byb3RvY29sMSwgU2VjdXJpdHlDb25zdC5rVExTUHJvdG9jb2wxMiksCn0KCmlmIGhhc2F0dHIoc3NsLCAiUFJPVE9DT0xfU1NMdjIiKToKICAgIF9wcm90b2NvbF90b19taW5fbWF4W3NzbC5QUk9UT0NPTF9TU0x2Ml0gPSAoCiAgICAgICAgU2VjdXJpdHlDb25zdC5rU1NMUHJvdG9jb2wyLCBTZWN1cml0eUNvbnN0LmtTU0xQcm90b2NvbDIKICAgICkKaWYgaGFzYXR0cihzc2wsICJQUk9UT0NPTF9TU0x2MyIpOgogICAgX3Byb3RvY29sX3RvX21pbl9tYXhbc3NsLlBST1RPQ09MX1NTTHYzXSA9ICgKICAgICAgICBTZWN1cml0eUNvbnN0LmtTU0xQcm90b2NvbDMsIFNlY3VyaXR5Q29uc3Qua1NTTFByb3RvY29sMwogICAgKQppZiBoYXNhdHRyKHNzbCwgIlBST1RPQ09MX1RMU3YxIik6CiAgICBfcHJvdG9jb2xfdG9fbWluX21heFtzc2wuUFJPVE9DT0xfVExTdjFdID0gKAogICAgICAgIFNlY3VyaXR5Q29uc3Qua1RMU1Byb3RvY29sMSwgU2VjdXJpdHlDb25zdC5rVExTUHJvdG9jb2wxCiAgICApCmlmIGhhc2F0dHIoc3NsLCAiUFJPVE9DT0xfVExTdjFfMSIpOgogICAgX3Byb3RvY29sX3RvX21pbl9tYXhbc3NsLlBST1RPQ09MX1RMU3YxXzFdID0gKAogICAgICAgIFNlY3VyaXR5Q29uc3Qua1RMU1Byb3RvY29sMTEsIFNlY3VyaXR5Q29uc3Qua1RMU1Byb3RvY29sMTEKICAgICkKaWYgaGFzYXR0cihzc2wsICJQUk9UT0NPTF9UTFN2MV8yIik6CiAgICBfcHJvdG9jb2xfdG9fbWluX21heFtzc2wuUFJPVE9DT0xfVExTdjFfMl0gPSAoCiAgICAgICAgU2VjdXJpdHlDb25zdC5rVExTUHJvdG9jb2wxMiwgU2VjdXJpdHlDb25zdC5rVExTUHJvdG9jb2wxMgogICAgKQppZiBoYXNhdHRyKHNzbCwgIlBST1RPQ09MX1RMUyIpOgogICAgX3Byb3RvY29sX3RvX21pbl9tYXhbc3NsLlBST1RPQ09MX1RMU10gPSBfcHJvdG9jb2xfdG9fbWluX21heFtzc2wuUFJPVE9DT0xfU1NMdjIzXQoKCmRlZiBpbmplY3RfaW50b191cmxsaWIzKCk6CiAgICAiIiIKICAgIE1vbmtleS1wYXRjaCB1cmxsaWIzIHdpdGggU2VjdXJlVHJhbnNwb3J0LWJhY2tlZCBTU0wtc3VwcG9ydC4KICAgICIiIgogICAgdXRpbC5zc2xfLlNTTENvbnRleHQgPSBTZWN1cmVUcmFuc3BvcnRDb250ZXh0CiAgICB1dGlsLkhBU19TTkkgPSBIQVNfU05JCiAgICB1dGlsLnNzbF8uSEFTX1NOSSA9IEhBU19TTkkKICAgIHV0aWwuSVNfU0VDVVJFVFJBTlNQT1JUID0gVHJ1ZQogICAgdXRpbC5zc2xfLklTX1NFQ1VSRVRSQU5TUE9SVCA9IFRydWUKCgpkZWYgZXh0cmFjdF9mcm9tX3VybGxpYjMoKToKICAgICIiIgogICAgVW5kbyBtb25rZXktcGF0Y2hpbmcgYnkgOmZ1bmM6YGluamVjdF9pbnRvX3VybGxpYjNgLgogICAgIiIiCiAgICB1dGlsLnNzbF8uU1NMQ29udGV4dCA9IG9yaWdfdXRpbF9TU0xDb250ZXh0CiAgICB1dGlsLkhBU19TTkkgPSBvcmlnX3V0aWxfSEFTX1NOSQogICAgdXRpbC5zc2xfLkhBU19TTkkgPSBvcmlnX3V0aWxfSEFTX1NOSQogICAgdXRpbC5JU19TRUNVUkVUUkFOU1BPUlQgPSBGYWxzZQogICAgdXRpbC5zc2xfLklTX1NFQ1VSRVRSQU5TUE9SVCA9IEZhbHNlCgoKZGVmIF9yZWFkX2NhbGxiYWNrKGNvbm5lY3Rpb25faWQsIGRhdGFfYnVmZmVyLCBkYXRhX2xlbmd0aF9wb2ludGVyKToKICAgICIiIgogICAgU2VjdXJlVHJhbnNwb3J0IHJlYWQgY2FsbGJhY2suIFRoaXMgaXMgY2FsbGVkIGJ5IFNUIHRvIHJlcXVlc3QgdGhhdCBkYXRhCiAgICBiZSByZXR1cm5lZCBmcm9tIHRoZSBzb2NrZXQuCiAgICAiIiIKICAgIHdyYXBwZWRfc29ja2V0ID0gTm9uZQogICAgdHJ5OgogICAgICAgIHdyYXBwZWRfc29ja2V0ID0gX2Nvbm5lY3Rpb25fcmVmcy5nZXQoY29ubmVjdGlvbl9pZCkKICAgICAgICBpZiB3cmFwcGVkX3NvY2tldCBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4gU2VjdXJpdHlDb25zdC5lcnJTU0xJbnRlcm5hbAogICAgICAgIGJhc2Vfc29ja2V0ID0gd3JhcHBlZF9zb2NrZXQuc29ja2V0CgogICAgICAgIHJlcXVlc3RlZF9sZW5ndGggPSBkYXRhX2xlbmd0aF9wb2ludGVyWzBdCgogICAgICAgIHRpbWVvdXQgPSB3cmFwcGVkX3NvY2tldC5nZXR0aW1lb3V0KCkKICAgICAgICBlcnJvciA9IE5vbmUKICAgICAgICByZWFkX2NvdW50ID0gMAogICAgICAgIGJ1ZmZlciA9IChjdHlwZXMuY19jaGFyICogcmVxdWVzdGVkX2xlbmd0aCkuZnJvbV9hZGRyZXNzKGRhdGFfYnVmZmVyKQogICAgICAgIGJ1ZmZlcl92aWV3ID0gbWVtb3J5dmlldyhidWZmZXIpCgogICAgICAgIHRyeToKICAgICAgICAgICAgd2hpbGUgcmVhZF9jb3VudCA8IHJlcXVlc3RlZF9sZW5ndGg6CiAgICAgICAgICAgICAgICBpZiB0aW1lb3V0IGlzIE5vbmUgb3IgdGltZW91dCA+PSAwOgogICAgICAgICAgICAgICAgICAgIHJlYWRhYmxlcyA9IHV0aWwud2FpdF9mb3JfcmVhZChbYmFzZV9zb2NrZXRdLCB0aW1lb3V0KQogICAgICAgICAgICAgICAgICAgIGlmIG5vdCByZWFkYWJsZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlIHNvY2tldC5lcnJvcihlcnJuby5FQUdBSU4sICd0aW1lZCBvdXQnKQoKICAgICAgICAgICAgICAgICMgV2UgbmVlZCB0byB0ZWxsIGN0eXBlcyB0aGF0IHdlIGhhdmUgYSBidWZmZXIgdGhhdCBjYW4gYmUKICAgICAgICAgICAgICAgICMgd3JpdHRlbiB0by4gVXBzZXR0aW5nbHksIHdlIGRvIHRoYXQgbGlrZSB0aGlzOgogICAgICAgICAgICAgICAgY2h1bmtfc2l6ZSA9IGJhc2Vfc29ja2V0LnJlY3ZfaW50bygKICAgICAgICAgICAgICAgICAgICBidWZmZXJfdmlld1tyZWFkX2NvdW50OnJlcXVlc3RlZF9sZW5ndGhdCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICByZWFkX2NvdW50ICs9IGNodW5rX3NpemUKICAgICAgICAgICAgICAgIGlmIG5vdCBjaHVua19zaXplOgogICAgICAgICAgICAgICAgICAgIGlmIG5vdCByZWFkX2NvdW50OgogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VjdXJpdHlDb25zdC5lcnJTU0xDbG9zZWRHcmFjZWZ1bAogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgZXhjZXB0IChzb2NrZXQuZXJyb3IpIGFzIGU6CiAgICAgICAgICAgIGVycm9yID0gZS5lcnJubwoKICAgICAgICAgICAgaWYgZXJyb3IgaXMgbm90IE5vbmUgYW5kIGVycm9yICE9IGVycm5vLkVBR0FJTjoKICAgICAgICAgICAgICAgIGlmIGVycm9yID09IGVycm5vLkVDT05OUkVTRVQ6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNlY3VyaXR5Q29uc3QuZXJyU1NMQ2xvc2VkQWJvcnQKICAgICAgICAgICAgICAgIHJhaXNlCgogICAgICAgIGRhdGFfbGVuZ3RoX3BvaW50ZXJbMF0gPSByZWFkX2NvdW50CgogICAgICAgIGlmIHJlYWRfY291bnQgIT0gcmVxdWVzdGVkX2xlbmd0aDoKICAgICAgICAgICAgcmV0dXJuIFNlY3VyaXR5Q29uc3QuZXJyU1NMV291bGRCbG9jawoKICAgICAgICByZXR1cm4gMAogICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgIGlmIHdyYXBwZWRfc29ja2V0IGlzIG5vdCBOb25lOgogICAgICAgICAgICB3cmFwcGVkX3NvY2tldC5fZXhjZXB0aW9uID0gZQogICAgICAgIHJldHVybiBTZWN1cml0eUNvbnN0LmVyclNTTEludGVybmFsCgoKZGVmIF93cml0ZV9jYWxsYmFjayhjb25uZWN0aW9uX2lkLCBkYXRhX2J1ZmZlciwgZGF0YV9sZW5ndGhfcG9pbnRlcik6CiAgICAiIiIKICAgIFNlY3VyZVRyYW5zcG9ydCB3cml0ZSBjYWxsYmFjay4gVGhpcyBpcyBjYWxsZWQgYnkgU1QgdG8gcmVxdWVzdCB0aGF0IGRhdGEKICAgIGFjdHVhbGx5IGJlIHNlbnQgb24gdGhlIG5ldHdvcmsuCiAgICAiIiIKICAgIHdyYXBwZWRfc29ja2V0ID0gTm9uZQogICAgdHJ5OgogICAgICAgIHdyYXBwZWRfc29ja2V0ID0gX2Nvbm5lY3Rpb25fcmVmcy5nZXQoY29ubmVjdGlvbl9pZCkKICAgICAgICBpZiB3cmFwcGVkX3NvY2tldCBpcyBOb25lOgogICAgICAgICAgICByZXR1cm4gU2VjdXJpdHlDb25zdC5lcnJTU0xJbnRlcm5hbAogICAgICAgIGJhc2Vfc29ja2V0ID0gd3JhcHBlZF9zb2NrZXQuc29ja2V0CgogICAgICAgIGJ5dGVzX3RvX3dyaXRlID0gZGF0YV9sZW5ndGhfcG9pbnRlclswXQogICAgICAgIGRhdGEgPSBjdHlwZXMuc3RyaW5nX2F0KGRhdGFfYnVmZmVyLCBieXRlc190b193cml0ZSkKCiAgICAgICAgdGltZW91dCA9IHdyYXBwZWRfc29ja2V0LmdldHRpbWVvdXQoKQogICAgICAgIGVycm9yID0gTm9uZQogICAgICAgIHNlbnQgPSAwCgogICAgICAgIHRyeToKICAgICAgICAgICAgd2hpbGUgc2VudCA8IGJ5dGVzX3RvX3dyaXRlOgogICAgICAgICAgICAgICAgaWYgdGltZW91dCBpcyBOb25lIG9yIHRpbWVvdXQgPj0gMDoKICAgICAgICAgICAgICAgICAgICB3cml0YWJsZXMgPSB1dGlsLndhaXRfZm9yX3dyaXRlKFtiYXNlX3NvY2tldF0sIHRpbWVvdXQpCiAgICAgICAgICAgICAgICAgICAgaWYgbm90IHdyaXRhYmxlczoKICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2Ugc29ja2V0LmVycm9yKGVycm5vLkVBR0FJTiwgJ3RpbWVkIG91dCcpCiAgICAgICAgICAgICAgICBjaHVua19zZW50ID0gYmFzZV9zb2NrZXQuc2VuZChkYXRhKQogICAgICAgICAgICAgICAgc2VudCArPSBjaHVua19zZW50CgogICAgICAgICAgICAgICAgIyBUaGlzIGhhcyBzb21lIG5lZWRsZXNzIGNvcHlpbmcgaGVyZSwgYnV0IEknbSBub3Qgc3VyZSB0aGVyZSdzCiAgICAgICAgICAgICAgICAjIG11Y2ggdmFsdWUgaW4gb3B0aW1pc2luZyB0aGlzIGRhdGEgcGF0aC4KICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2NodW5rX3NlbnQ6XQogICAgICAgIGV4Y2VwdCAoc29ja2V0LmVycm9yKSBhcyBlOgogICAgICAgICAgICBlcnJvciA9IGUuZXJybm8KCiAgICAgICAgICAgIGlmIGVycm9yIGlzIG5vdCBOb25lIGFuZCBlcnJvciAhPSBlcnJuby5FQUdBSU46CiAgICAgICAgICAgICAgICBpZiBlcnJvciA9PSBlcnJuby5FQ09OTlJFU0VUOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBTZWN1cml0eUNvbnN0LmVyclNTTENsb3NlZEFib3J0CiAgICAgICAgICAgICAgICByYWlzZQoKICAgICAgICBkYXRhX2xlbmd0aF9wb2ludGVyWzBdID0gc2VudAogICAgICAgIGlmIHNlbnQgIT0gYnl0ZXNfdG9fd3JpdGU6CiAgICAgICAgICAgIHJldHVybiBTZWN1cml0eUNvbnN0LmVyclNTTFdvdWxkQmxvY2sKCiAgICAgICAgcmV0dXJuIDAKICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICBpZiB3cmFwcGVkX3NvY2tldCBpcyBub3QgTm9uZToKICAgICAgICAgICAgd3JhcHBlZF9zb2NrZXQuX2V4Y2VwdGlvbiA9IGUKICAgICAgICByZXR1cm4gU2VjdXJpdHlDb25zdC5lcnJTU0xJbnRlcm5hbAoKCiMgV2UgbmVlZCB0byBrZWVwIHRoZXNlIHR3byBvYmplY3RzIHJlZmVyZW5jZXMgYWxpdmU6IGlmIHRoZXkgZ2V0IEdDJ2Qgd2hpbGUKIyBpbiB1c2UgdGhlbiBTZWN1cmVUcmFuc3BvcnQgY291bGQgYXR0ZW1wdCB0byBjYWxsIGEgZnVuY3Rpb24gdGhhdCBpcyBpbiBmcmVlZAojIG1lbW9yeS4gVGhhdCB3b3VsZCBiZS4uLnVoLi4uYmFkLiBZZWFoLCB0aGF0J3MgdGhlIHdvcmQuIEJhZC4KX3JlYWRfY2FsbGJhY2tfcG9pbnRlciA9IFNlY3VyaXR5LlNTTFJlYWRGdW5jKF9yZWFkX2NhbGxiYWNrKQpfd3JpdGVfY2FsbGJhY2tfcG9pbnRlciA9IFNlY3VyaXR5LlNTTFdyaXRlRnVuYyhfd3JpdGVfY2FsbGJhY2spCgoKY2xhc3MgV3JhcHBlZFNvY2tldChvYmplY3QpOgogICAgIiIiCiAgICBBUEktY29tcGF0aWJpbGl0eSB3cmFwcGVyIGZvciBQeXRob24ncyBPcGVuU1NMIHdyYXBwZWQgc29ja2V0IG9iamVjdC4KCiAgICBOb3RlOiBfbWFrZWZpbGVfcmVmcywgX2Ryb3AoKSwgYW5kIF9yZXVzZSgpIGFyZSBuZWVkZWQgZm9yIHRoZSBnYXJiYWdlCiAgICBjb2xsZWN0b3Igb2YgUHlQeS4KICAgICIiIgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHNvY2tldCk6CiAgICAgICAgc2VsZi5zb2NrZXQgPSBzb2NrZXQKICAgICAgICBzZWxmLmNvbnRleHQgPSBOb25lCiAgICAgICAgc2VsZi5fbWFrZWZpbGVfcmVmcyA9IDAKICAgICAgICBzZWxmLl9jbG9zZWQgPSBGYWxzZQogICAgICAgIHNlbGYuX2V4Y2VwdGlvbiA9IE5vbmUKICAgICAgICBzZWxmLl9rZXljaGFpbiA9IE5vbmUKICAgICAgICBzZWxmLl9rZXljaGFpbl9kaXIgPSBOb25lCiAgICAgICAgc2VsZi5fY2xpZW50X2NlcnRfY2hhaW4gPSBOb25lCgogICAgICAgICMgV2Ugc2F2ZSBvZmYgdGhlIHByZXZpb3VzbHktY29uZmlndXJlZCB0aW1lb3V0IGFuZCB0aGVuIHNldCBpdCB0bwogICAgICAgICMgemVyby4gVGhpcyBpcyBkb25lIGJlY2F1c2Ugd2UgdXNlIHNlbGVjdCBhbmQgZnJpZW5kcyB0byBoYW5kbGUgdGhlCiAgICAgICAgIyB0aW1lb3V0cywgYnV0IGlmIHdlIGxlYXZlIHRoZSB0aW1lb3V0IHNldCBvbiB0aGUgbG93ZXIgc29ja2V0IHRoZW4KICAgICAgICAjIFB5dGhvbiB3aWxsICJraW5kbHkiIGNhbGwgc2VsZWN0IG9uIHRoYXQgc29ja2V0IGFnYWluIGZvciB1cy4gQXZvaWQKICAgICAgICAjIHRoYXQgYnkgZm9yY2luZyB0aGUgdGltZW91dCB0byB6ZXJvLgogICAgICAgIHNlbGYuX3RpbWVvdXQgPSBzZWxmLnNvY2tldC5nZXR0aW1lb3V0KCkKICAgICAgICBzZWxmLnNvY2tldC5zZXR0aW1lb3V0KDApCgogICAgQGNvbnRleHRsaWIuY29udGV4dG1hbmFnZXIKICAgIGRlZiBfcmFpc2Vfb25fZXJyb3Ioc2VsZik6CiAgICAgICAgIiIiCiAgICAgICAgQSBjb250ZXh0IG1hbmFnZXIgdGhhdCBjYW4gYmUgdXNlZCB0byB3cmFwIGNhbGxzIHRoYXQgZG8gSS9PIGZyb20KICAgICAgICBTZWN1cmVUcmFuc3BvcnQuIElmIGFueSBvZiB0aGUgSS9PIGNhbGxiYWNrcyBoaXQgYW4gZXhjZXB0aW9uLCB0aGlzCiAgICAgICAgY29udGV4dCBtYW5hZ2VyIHdpbGwgY29ycmVjdGx5IHByb3BhZ2F0ZSB0aGUgZXhjZXB0aW9uIGFmdGVyIHRoZSBmYWN0LgogICAgICAgIFRoaXMgYXZvaWRzIHNpbGVudGx5IHN3YWxsb3dpbmcgdGhvc2UgZXhjZXB0aW9ucy4KCiAgICAgICAgSXQgYWxzbyBjb3JyZWN0bHkgZm9yY2VzIHRoZSBzb2NrZXQgY2xvc2VkLgogICAgICAgICIiIgogICAgICAgIHNlbGYuX2V4Y2VwdGlvbiA9IE5vbmUKCiAgICAgICAgIyBXZSBleHBsaWNpdGx5IGRvbid0IGNhdGNoIGFyb3VuZCB0aGlzIHlpZWxkIGJlY2F1c2UgaW4gdGhlIHVubGlrZWx5CiAgICAgICAgIyBldmVudCB0aGF0IGFuIGV4Y2VwdGlvbiB3YXMgaGl0IGluIHRoZSBibG9jayB3ZSBkb24ndCB3YW50IHRvIHN3YWxsb3cKICAgICAgICAjIGl0LgogICAgICAgIHlpZWxkCiAgICAgICAgaWYgc2VsZi5fZXhjZXB0aW9uIGlzIG5vdCBOb25lOgogICAgICAgICAgICBleGNlcHRpb24sIHNlbGYuX2V4Y2VwdGlvbiA9IHNlbGYuX2V4Y2VwdGlvbiwgTm9uZQogICAgICAgICAgICBzZWxmLmNsb3NlKCkKICAgICAgICAgICAgcmFpc2UgZXhjZXB0aW9uCgogICAgZGVmIF9zZXRfY2lwaGVycyhzZWxmKToKICAgICAgICAiIiIKICAgICAgICBTZXRzIHVwIHRoZSBhbGxvd2VkIGNpcGhlcnMuIEJ5IGRlZmF1bHQgdGhpcyBtYXRjaGVzIHRoZSBzZXQgaW4KICAgICAgICB1dGlsLnNzbF8uREVGQVVMVF9DSVBIRVJTLCBhdCBsZWFzdCBhcyBzdXBwb3J0ZWQgYnkgbWFjT1MuIFRoaXMgaXMgZG9uZQogICAgICAgIGN1c3RvbSBhbmQgZG9lc24ndCBhbGxvdyBjaGFuZ2luZyBhdCB0aGlzIHRpbWUsIG1vc3RseSBiZWNhdXNlIHBhcnNpbmcKICAgICAgICBPcGVuU1NMIGNpcGhlciBzdHJpbmdzIGlzIGdvaW5nIHRvIGJlIGEgZnJlYWtpbmcgbmlnaHRtYXJlLgogICAgICAgICIiIgogICAgICAgIGNpcGhlcnMgPSAoU2VjdXJpdHkuU1NMQ2lwaGVyU3VpdGUgKiBsZW4oQ0lQSEVSX1NVSVRFUykpKCpDSVBIRVJfU1VJVEVTKQogICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNTTFNldEVuYWJsZWRDaXBoZXJzKAogICAgICAgICAgICBzZWxmLmNvbnRleHQsIGNpcGhlcnMsIGxlbihDSVBIRVJfU1VJVEVTKQogICAgICAgICkKICAgICAgICBfYXNzZXJ0X25vX2Vycm9yKHJlc3VsdCkKCiAgICBkZWYgX2N1c3RvbV92YWxpZGF0ZShzZWxmLCB2ZXJpZnksIHRydXN0X2J1bmRsZSk6CiAgICAgICAgIiIiCiAgICAgICAgQ2FsbGVkIHdoZW4gd2UgaGF2ZSBzZXQgY3VzdG9tIHZhbGlkYXRpb24uIFdlIGRvIHRoaXMgaW4gdHdvIGNhc2VzOgogICAgICAgIGZpcnN0LCB3aGVuIGNlcnQgdmFsaWRhdGlvbiBpcyBlbnRpcmVseSBkaXNhYmxlZDsgYW5kIHNlY29uZCwgd2hlbgogICAgICAgIHVzaW5nIGEgY3VzdG9tIHRydXN0IERCLgogICAgICAgICIiIgogICAgICAgICMgSWYgd2UgZGlzYWJsZWQgY2VydCB2YWxpZGF0aW9uLCBqdXN0IHNheTogY29vbC4KICAgICAgICBpZiBub3QgdmVyaWZ5OgogICAgICAgICAgICByZXR1cm4KCiAgICAgICAgIyBXZSB3YW50IGRhdGEgaW4gbWVtb3J5LCBzbyBsb2FkIGl0IHVwLgogICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKHRydXN0X2J1bmRsZSk6CiAgICAgICAgICAgIHdpdGggb3Blbih0cnVzdF9idW5kbGUsICdyYicpIGFzIGY6CiAgICAgICAgICAgICAgICB0cnVzdF9idW5kbGUgPSBmLnJlYWQoKQoKICAgICAgICBjZXJ0X2FycmF5ID0gTm9uZQogICAgICAgIHRydXN0ID0gU2VjdXJpdHkuU2VjVHJ1c3RSZWYoKQoKICAgICAgICB0cnk6CiAgICAgICAgICAgICMgR2V0IGEgQ0ZBcnJheSB0aGF0IGNvbnRhaW5zIHRoZSBjZXJ0cyB3ZSB3YW50LgogICAgICAgICAgICBjZXJ0X2FycmF5ID0gX2NlcnRfYXJyYXlfZnJvbV9wZW0odHJ1c3RfYnVuZGxlKQoKICAgICAgICAgICAgIyBPaywgbm93IHRoZSBoYXJkIHBhcnQuIFdlIHdhbnQgdG8gZ2V0IHRoZSBTZWNUcnVzdFJlZiB0aGF0IFNUIGhhcwogICAgICAgICAgICAjIGNyZWF0ZWQgZm9yIHRoaXMgY29ubmVjdGlvbiwgc2hvdmUgb3VyIENBcyBpbnRvIGl0LCB0ZWxsIFNUIHRvCiAgICAgICAgICAgICMgaWdub3JlIGV2ZXJ5dGhpbmcgZWxzZSBpdCBrbm93cywgYW5kIHRoZW4gYXNrIGlmIGl0IGNhbiBidWlsZCBhCiAgICAgICAgICAgICMgY2hhaW4uIFRoaXMgaXMgYSBidXV1dW5jaCBvZiBjb2RlLgogICAgICAgICAgICByZXN1bHQgPSBTZWN1cml0eS5TU0xDb3B5UGVlclRydXN0KAogICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0LCBjdHlwZXMuYnlyZWYodHJ1c3QpCiAgICAgICAgICAgICkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCiAgICAgICAgICAgIGlmIG5vdCB0cnVzdDoKICAgICAgICAgICAgICAgIHJhaXNlIHNzbC5TU0xFcnJvcigiRmFpbGVkIHRvIGNvcHkgdHJ1c3QgcmVmZXJlbmNlIikKCiAgICAgICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNlY1RydXN0U2V0QW5jaG9yQ2VydGlmaWNhdGVzKHRydXN0LCBjZXJ0X2FycmF5KQogICAgICAgICAgICBfYXNzZXJ0X25vX2Vycm9yKHJlc3VsdCkKCiAgICAgICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNlY1RydXN0U2V0QW5jaG9yQ2VydGlmaWNhdGVzT25seSh0cnVzdCwgVHJ1ZSkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCgogICAgICAgICAgICB0cnVzdF9yZXN1bHQgPSBTZWN1cml0eS5TZWNUcnVzdFJlc3VsdFR5cGUoKQogICAgICAgICAgICByZXN1bHQgPSBTZWN1cml0eS5TZWNUcnVzdEV2YWx1YXRlKAogICAgICAgICAgICAgICAgdHJ1c3QsIGN0eXBlcy5ieXJlZih0cnVzdF9yZXN1bHQpCiAgICAgICAgICAgICkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCiAgICAgICAgZmluYWxseToKICAgICAgICAgICAgaWYgdHJ1c3Q6CiAgICAgICAgICAgICAgICBDb3JlRm91bmRhdGlvbi5DRlJlbGVhc2UodHJ1c3QpCgogICAgICAgICAgICBpZiBjZXJ0X2FycmF5IGlzIE5vbmU6CiAgICAgICAgICAgICAgICBDb3JlRm91bmRhdGlvbi5DRlJlbGVhc2UoY2VydF9hcnJheSkKCiAgICAgICAgIyBPaywgbm93IHdlIGNhbiBsb29rIGF0IHdoYXQgdGhlIHJlc3VsdCB3YXMuCiAgICAgICAgc3VjY2Vzc2VzID0gKAogICAgICAgICAgICBTZWN1cml0eUNvbnN0LmtTZWNUcnVzdFJlc3VsdFVuc3BlY2lmaWVkLAogICAgICAgICAgICBTZWN1cml0eUNvbnN0LmtTZWNUcnVzdFJlc3VsdFByb2NlZWQKICAgICAgICApCiAgICAgICAgaWYgdHJ1c3RfcmVzdWx0LnZhbHVlIG5vdCBpbiBzdWNjZXNzZXM6CiAgICAgICAgICAgIHJhaXNlIHNzbC5TU0xFcnJvcigKICAgICAgICAgICAgICAgICJjZXJ0aWZpY2F0ZSB2ZXJpZnkgZmFpbGVkLCBlcnJvciBjb2RlOiAlZCIgJQogICAgICAgICAgICAgICAgdHJ1c3RfcmVzdWx0LnZhbHVlCiAgICAgICAgICAgICkKCiAgICBkZWYgaGFuZHNoYWtlKHNlbGYsCiAgICAgICAgICAgICAgICAgIHNlcnZlcl9ob3N0bmFtZSwKICAgICAgICAgICAgICAgICAgdmVyaWZ5LAogICAgICAgICAgICAgICAgICB0cnVzdF9idW5kbGUsCiAgICAgICAgICAgICAgICAgIG1pbl92ZXJzaW9uLAogICAgICAgICAgICAgICAgICBtYXhfdmVyc2lvbiwKICAgICAgICAgICAgICAgICAgY2xpZW50X2NlcnQsCiAgICAgICAgICAgICAgICAgIGNsaWVudF9rZXksCiAgICAgICAgICAgICAgICAgIGNsaWVudF9rZXlfcGFzc3BocmFzZSk6CiAgICAgICAgIiIiCiAgICAgICAgQWN0dWFsbHkgcGVyZm9ybXMgdGhlIFRMUyBoYW5kc2hha2UuIFRoaXMgaXMgcnVuIGF1dG9tYXRpY2FsbHkgYnkKICAgICAgICB3cmFwcGVkIHNvY2tldCwgYW5kIHNob3VsZG4ndCBiZSBuZWVkZWQgaW4gdXNlciBjb2RlLgogICAgICAgICIiIgogICAgICAgICMgRmlyc3QsIHdlIGRvIHRoZSBpbml0aWFsIGJpdHMgb2YgY29ubmVjdGlvbiBzZXR1cC4gV2UgbmVlZCB0byBjcmVhdGUKICAgICAgICAjIGEgY29udGV4dCwgc2V0IGl0cyBJL08gZnVuY3MsIGFuZCBzZXQgdGhlIGNvbm5lY3Rpb24gcmVmZXJlbmNlLgogICAgICAgIHNlbGYuY29udGV4dCA9IFNlY3VyaXR5LlNTTENyZWF0ZUNvbnRleHQoCiAgICAgICAgICAgIE5vbmUsIFNlY3VyaXR5Q29uc3Qua1NTTENsaWVudFNpZGUsIFNlY3VyaXR5Q29uc3Qua1NTTFN0cmVhbVR5cGUKICAgICAgICApCiAgICAgICAgcmVzdWx0ID0gU2VjdXJpdHkuU1NMU2V0SU9GdW5jcygKICAgICAgICAgICAgc2VsZi5jb250ZXh0LCBfcmVhZF9jYWxsYmFja19wb2ludGVyLCBfd3JpdGVfY2FsbGJhY2tfcG9pbnRlcgogICAgICAgICkKICAgICAgICBfYXNzZXJ0X25vX2Vycm9yKHJlc3VsdCkKCiAgICAgICAgIyBIZXJlIHdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgaGFuZGxlIHRvIHVzZS4gV2UgZG8gdGhpcyBieSB0YWtpbmcgdGhlCiAgICAgICAgIyBpZCBvZiBzZWxmIG1vZHVsbyAyKiozMSAtIDEuIElmIHRoaXMgaXMgYWxyZWFkeSBpbiB0aGUgZGljdGlvbmFyeSwgd2UKICAgICAgICAjIGp1c3Qga2VlcCBpbmNyZW1lbnRpbmcgYnkgb25lIHVudGlsIHdlIGZpbmQgYSBmcmVlIHNwYWNlLgogICAgICAgIHdpdGggX2Nvbm5lY3Rpb25fcmVmX2xvY2s6CiAgICAgICAgICAgIGhhbmRsZSA9IGlkKHNlbGYpICUgMjE0NzQ4MzY0NwogICAgICAgICAgICB3aGlsZSBoYW5kbGUgaW4gX2Nvbm5lY3Rpb25fcmVmczoKICAgICAgICAgICAgICAgIGhhbmRsZSA9IChoYW5kbGUgKyAxKSAlIDIxNDc0ODM2NDcKICAgICAgICAgICAgX2Nvbm5lY3Rpb25fcmVmc1toYW5kbGVdID0gc2VsZgoKICAgICAgICByZXN1bHQgPSBTZWN1cml0eS5TU0xTZXRDb25uZWN0aW9uKHNlbGYuY29udGV4dCwgaGFuZGxlKQogICAgICAgIF9hc3NlcnRfbm9fZXJyb3IocmVzdWx0KQoKICAgICAgICAjIElmIHdlIGhhdmUgYSBzZXJ2ZXIgaG9zdG5hbWUsIHdlIHNob3VsZCBzZXQgdGhhdCB0b28uCiAgICAgICAgaWYgc2VydmVyX2hvc3RuYW1lOgogICAgICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShzZXJ2ZXJfaG9zdG5hbWUsIGJ5dGVzKToKICAgICAgICAgICAgICAgIHNlcnZlcl9ob3N0bmFtZSA9IHNlcnZlcl9ob3N0bmFtZS5lbmNvZGUoJ3V0Zi04JykKCiAgICAgICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNTTFNldFBlZXJEb21haW5OYW1lKAogICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0LCBzZXJ2ZXJfaG9zdG5hbWUsIGxlbihzZXJ2ZXJfaG9zdG5hbWUpCiAgICAgICAgICAgICkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCgogICAgICAgICMgU2V0dXAgdGhlIGNpcGhlcnMuCiAgICAgICAgc2VsZi5fc2V0X2NpcGhlcnMoKQoKICAgICAgICAjIFNldCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBUTFMgdmVyc2lvbnMuCiAgICAgICAgcmVzdWx0ID0gU2VjdXJpdHkuU1NMU2V0UHJvdG9jb2xWZXJzaW9uTWluKHNlbGYuY29udGV4dCwgbWluX3ZlcnNpb24pCiAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCiAgICAgICAgcmVzdWx0ID0gU2VjdXJpdHkuU1NMU2V0UHJvdG9jb2xWZXJzaW9uTWF4KHNlbGYuY29udGV4dCwgbWF4X3ZlcnNpb24pCiAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCgogICAgICAgICMgSWYgdGhlcmUncyBhIHRydXN0IERCLCB3ZSBuZWVkIHRvIHVzZSBpdC4gV2UgZG8gdGhhdCBieSB0ZWxsaW5nCiAgICAgICAgIyBTZWN1cmVUcmFuc3BvcnQgdG8gYnJlYWsgb24gc2VydmVyIGF1dGguIFdlIGFsc28gZG8gdGhhdCBpZiB3ZSBkb24ndAogICAgICAgICMgd2FudCB0byB2YWxpZGF0ZSB0aGUgY2VydHMgYXQgYWxsOiB3ZSBqdXN0IHdvbid0IGFjdHVhbGx5IGRvIGFueQogICAgICAgICMgYXV0aGluZyBpbiB0aGF0IGNhc2UuCiAgICAgICAgaWYgbm90IHZlcmlmeSBvciB0cnVzdF9idW5kbGUgaXMgbm90IE5vbmU6CiAgICAgICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNTTFNldFNlc3Npb25PcHRpb24oCiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHQsCiAgICAgICAgICAgICAgICBTZWN1cml0eUNvbnN0LmtTU0xTZXNzaW9uT3B0aW9uQnJlYWtPblNlcnZlckF1dGgsCiAgICAgICAgICAgICAgICBUcnVlCiAgICAgICAgICAgICkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCgogICAgICAgICMgSWYgdGhlcmUncyBhIGNsaWVudCBjZXJ0LCB3ZSBuZWVkIHRvIHVzZSBpdC4KICAgICAgICBpZiBjbGllbnRfY2VydDoKICAgICAgICAgICAgc2VsZi5fa2V5Y2hhaW4sIHNlbGYuX2tleWNoYWluX2RpciA9IF90ZW1wb3Jhcnlfa2V5Y2hhaW4oKQogICAgICAgICAgICBzZWxmLl9jbGllbnRfY2VydF9jaGFpbiA9IF9sb2FkX2NsaWVudF9jZXJ0X2NoYWluKAogICAgICAgICAgICAgICAgc2VsZi5fa2V5Y2hhaW4sIGNsaWVudF9jZXJ0LCBjbGllbnRfa2V5CiAgICAgICAgICAgICkKICAgICAgICAgICAgcmVzdWx0ID0gU2VjdXJpdHkuU1NMU2V0Q2VydGlmaWNhdGUoCiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHQsIHNlbGYuX2NsaWVudF9jZXJ0X2NoYWluCiAgICAgICAgICAgICkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCgogICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgIHdpdGggc2VsZi5fcmFpc2Vfb25fZXJyb3IoKToKICAgICAgICAgICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNTTEhhbmRzaGFrZShzZWxmLmNvbnRleHQpCgogICAgICAgICAgICAgICAgaWYgcmVzdWx0ID09IFNlY3VyaXR5Q29uc3QuZXJyU1NMV291bGRCbG9jazoKICAgICAgICAgICAgICAgICAgICByYWlzZSBzb2NrZXQudGltZW91dCgiaGFuZHNoYWtlIHRpbWVkIG91dCIpCiAgICAgICAgICAgICAgICBlbGlmIHJlc3VsdCA9PSBTZWN1cml0eUNvbnN0LmVyclNTTFNlcnZlckF1dGhDb21wbGV0ZWQ6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY3VzdG9tX3ZhbGlkYXRlKHZlcmlmeSwgdHJ1c3RfYnVuZGxlKQogICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIF9hc3NlcnRfbm9fZXJyb3IocmVzdWx0KQogICAgICAgICAgICAgICAgICAgIGJyZWFrCgogICAgZGVmIGZpbGVubyhzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5zb2NrZXQuZmlsZW5vKCkKCiAgICAjIENvcHktcGFzdGVkIGZyb20gUHl0aG9uIDMuNSBzb3VyY2UgY29kZQogICAgZGVmIF9kZWNyZWZfc29ja2V0aW9zKHNlbGYpOgogICAgICAgIGlmIHNlbGYuX21ha2VmaWxlX3JlZnMgPiAwOgogICAgICAgICAgICBzZWxmLl9tYWtlZmlsZV9yZWZzIC09IDEKICAgICAgICBpZiBzZWxmLl9jbG9zZWQ6CiAgICAgICAgICAgIHNlbGYuY2xvc2UoKQoKICAgIGRlZiByZWN2KHNlbGYsIGJ1ZnNpeik6CiAgICAgICAgYnVmZmVyID0gY3R5cGVzLmNyZWF0ZV9zdHJpbmdfYnVmZmVyKGJ1ZnNpeikKICAgICAgICBieXRlc19yZWFkID0gc2VsZi5yZWN2X2ludG8oYnVmZmVyLCBidWZzaXopCiAgICAgICAgZGF0YSA9IGJ1ZmZlcls6Ynl0ZXNfcmVhZF0KICAgICAgICByZXR1cm4gZGF0YQoKICAgIGRlZiByZWN2X2ludG8oc2VsZiwgYnVmZmVyLCBuYnl0ZXM9Tm9uZSk6CiAgICAgICAgIyBSZWFkIHNob3J0IG9uIEVPRi4KICAgICAgICBpZiBzZWxmLl9jbG9zZWQ6CiAgICAgICAgICAgIHJldHVybiAwCgogICAgICAgIGlmIG5ieXRlcyBpcyBOb25lOgogICAgICAgICAgICBuYnl0ZXMgPSBsZW4oYnVmZmVyKQoKICAgICAgICBidWZmZXIgPSAoY3R5cGVzLmNfY2hhciAqIG5ieXRlcykuZnJvbV9idWZmZXIoYnVmZmVyKQogICAgICAgIHByb2Nlc3NlZF9ieXRlcyA9IGN0eXBlcy5jX3NpemVfdCgwKQoKICAgICAgICB3aXRoIHNlbGYuX3JhaXNlX29uX2Vycm9yKCk6CiAgICAgICAgICAgIHJlc3VsdCA9IFNlY3VyaXR5LlNTTFJlYWQoCiAgICAgICAgICAgICAgICBzZWxmLmNvbnRleHQsIGJ1ZmZlciwgbmJ5dGVzLCBjdHlwZXMuYnlyZWYocHJvY2Vzc2VkX2J5dGVzKQogICAgICAgICAgICApCgogICAgICAgICMgVGhlcmUgYXJlIHNvbWUgcmVzdWx0IGNvZGVzIHRoYXQgd2Ugd2FudCB0byB0cmVhdCBhcyAibm90IGFsd2F5cwogICAgICAgICMgZXJyb3JzIi4gU3BlY2lmaWNhbGx5LCB0aG9zZSBhcmUgZXJyU1NMV291bGRCbG9jaywKICAgICAgICAjIGVyclNTTENsb3NlZEdyYWNlZnVsLCBhbmQgZXJyU1NMQ2xvc2VkTm9Ob3RpZnkuCiAgICAgICAgaWYgKHJlc3VsdCA9PSBTZWN1cml0eUNvbnN0LmVyclNTTFdvdWxkQmxvY2spOgogICAgICAgICAgICAjIElmIHdlIGRpZG4ndCBwcm9jZXNzIGFueSBieXRlcywgdGhlbiB0aGlzIHdhcyBqdXN0IGEgdGltZSBvdXQuCiAgICAgICAgICAgICMgSG93ZXZlciwgd2UgY2FuIGdldCBlcnJTU0xXb3VsZEJsb2NrIGluIHNpdHVhdGlvbnMgd2hlbiB3ZSAqZGlkKgogICAgICAgICAgICAjIHJlYWQgc29tZSBkYXRhLCBhbmQgaW4gdGhvc2UgY2FzZXMgd2Ugc2hvdWxkIGp1c3QgcmVhZCAic2hvcnQiCiAgICAgICAgICAgICMgYW5kIHJldHVybi4KICAgICAgICAgICAgaWYgcHJvY2Vzc2VkX2J5dGVzLnZhbHVlID09IDA6CiAgICAgICAgICAgICAgICAjIFRpbWVkIG91dCwgbm8gZGF0YSByZWFkLgogICAgICAgICAgICAgICAgcmFpc2Ugc29ja2V0LnRpbWVvdXQoInJlY3YgdGltZWQgb3V0IikKICAgICAgICBlbGlmIHJlc3VsdCBpbiAoU2VjdXJpdHlDb25zdC5lcnJTU0xDbG9zZWRHcmFjZWZ1bCwgU2VjdXJpdHlDb25zdC5lcnJTU0xDbG9zZWROb05vdGlmeSk6CiAgICAgICAgICAgICMgVGhlIHJlbW90ZSBwZWVyIGhhcyBjbG9zZWQgdGhpcyBjb25uZWN0aW9uLiBXZSBzaG91bGQgZG8gc28gYXMKICAgICAgICAgICAgIyB3ZWxsLiBOb3RlIHRoYXQgd2UgZG9uJ3QgYWN0dWFsbHkgcmV0dXJuIGhlcmUgYmVjYXVzZSBpbgogICAgICAgICAgICAjIHByaW5jaXBsZSB0aGlzIGNvdWxkIGFjdHVhbGx5IGJlIGZpcmVkIGFsb25nIHdpdGggcmV0dXJuIGRhdGEuCiAgICAgICAgICAgICMgSXQncyB1bmxpa2VseSB0aG91Z2guCiAgICAgICAgICAgIHNlbGYuY2xvc2UoKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIF9hc3NlcnRfbm9fZXJyb3IocmVzdWx0KQoKICAgICAgICAjIE9rLCB3ZSByZWFkIGFuZCBwcm9iYWJseSBzdWNjZWVkZWQuIFdlIHNob3VsZCByZXR1cm4gd2hhdGV2ZXIgZGF0YQogICAgICAgICMgd2FzIGFjdHVhbGx5IHJlYWQuCiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZF9ieXRlcy52YWx1ZQoKICAgIGRlZiBzZXR0aW1lb3V0KHNlbGYsIHRpbWVvdXQpOgogICAgICAgIHNlbGYuX3RpbWVvdXQgPSB0aW1lb3V0CgogICAgZGVmIGdldHRpbWVvdXQoc2VsZik6CiAgICAgICAgcmV0dXJuIHNlbGYuX3RpbWVvdXQKCiAgICBkZWYgc2VuZChzZWxmLCBkYXRhKToKICAgICAgICBwcm9jZXNzZWRfYnl0ZXMgPSBjdHlwZXMuY19zaXplX3QoMCkKCiAgICAgICAgd2l0aCBzZWxmLl9yYWlzZV9vbl9lcnJvcigpOgogICAgICAgICAgICByZXN1bHQgPSBTZWN1cml0eS5TU0xXcml0ZSgKICAgICAgICAgICAgICAgIHNlbGYuY29udGV4dCwgZGF0YSwgbGVuKGRhdGEpLCBjdHlwZXMuYnlyZWYocHJvY2Vzc2VkX2J5dGVzKQogICAgICAgICAgICApCgogICAgICAgIGlmIHJlc3VsdCA9PSBTZWN1cml0eUNvbnN0LmVyclNTTFdvdWxkQmxvY2sgYW5kIHByb2Nlc3NlZF9ieXRlcy52YWx1ZSA9PSAwOgogICAgICAgICAgICAjIFRpbWVkIG91dAogICAgICAgICAgICByYWlzZSBzb2NrZXQudGltZW91dCgic2VuZCB0aW1lZCBvdXQiKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIF9hc3NlcnRfbm9fZXJyb3IocmVzdWx0KQoKICAgICAgICAjIFdlIHNlbnQsIGFuZCBwcm9iYWJseSBzdWNjZWVkZWQuIFRlbGwgdGhlbSBob3cgbXVjaCB3ZSBzZW50LgogICAgICAgIHJldHVybiBwcm9jZXNzZWRfYnl0ZXMudmFsdWUKCiAgICBkZWYgc2VuZGFsbChzZWxmLCBkYXRhKToKICAgICAgICB0b3RhbF9zZW50ID0gMAogICAgICAgIHdoaWxlIHRvdGFsX3NlbnQgPCBsZW4oZGF0YSk6CiAgICAgICAgICAgIHNlbnQgPSBzZWxmLnNlbmQoZGF0YVt0b3RhbF9zZW50OnRvdGFsX3NlbnQgKyBTU0xfV1JJVEVfQkxPQ0tTSVpFXSkKICAgICAgICAgICAgdG90YWxfc2VudCArPSBzZW50CgogICAgZGVmIHNodXRkb3duKHNlbGYpOgogICAgICAgIHdpdGggc2VsZi5fcmFpc2Vfb25fZXJyb3IoKToKICAgICAgICAgICAgU2VjdXJpdHkuU1NMQ2xvc2Uoc2VsZi5jb250ZXh0KQoKICAgIGRlZiBjbG9zZShzZWxmKToKICAgICAgICAjIFRPRE86IHNob3VsZCBJIGRvIGNsZWFuIHNodXRkb3duIGhlcmU/IERvIEkgaGF2ZSB0bz8KICAgICAgICBpZiBzZWxmLl9tYWtlZmlsZV9yZWZzIDwgMToKICAgICAgICAgICAgc2VsZi5fY2xvc2VkID0gVHJ1ZQogICAgICAgICAgICBpZiBzZWxmLmNvbnRleHQ6CiAgICAgICAgICAgICAgICBDb3JlRm91bmRhdGlvbi5DRlJlbGVhc2Uoc2VsZi5jb250ZXh0KQogICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0ID0gTm9uZQogICAgICAgICAgICBpZiBzZWxmLl9jbGllbnRfY2VydF9jaGFpbjoKICAgICAgICAgICAgICAgIENvcmVGb3VuZGF0aW9uLkNGUmVsZWFzZShzZWxmLl9jbGllbnRfY2VydF9jaGFpbikKICAgICAgICAgICAgICAgIHNlbGYuX2NsaWVudF9jZXJ0X2NoYWluID0gTm9uZQogICAgICAgICAgICBpZiBzZWxmLl9rZXljaGFpbjoKICAgICAgICAgICAgICAgIFNlY3VyaXR5LlNlY0tleWNoYWluRGVsZXRlKHNlbGYuX2tleWNoYWluKQogICAgICAgICAgICAgICAgQ29yZUZvdW5kYXRpb24uQ0ZSZWxlYXNlKHNlbGYuX2tleWNoYWluKQogICAgICAgICAgICAgICAgc2h1dGlsLnJtdHJlZShzZWxmLl9rZXljaGFpbl9kaXIpCiAgICAgICAgICAgICAgICBzZWxmLl9rZXljaGFpbiA9IHNlbGYuX2tleWNoYWluX2RpciA9IE5vbmUKICAgICAgICAgICAgcmV0dXJuIHNlbGYuc29ja2V0LmNsb3NlKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLl9tYWtlZmlsZV9yZWZzIC09IDEKCiAgICBkZWYgZ2V0cGVlcmNlcnQoc2VsZiwgYmluYXJ5X2Zvcm09RmFsc2UpOgogICAgICAgICMgVXJnaCwgYW5ub3lpbmcuCiAgICAgICAgIwogICAgICAgICMgSGVyZSdzIGhvdyB3ZSBkbyB0aGlzOgogICAgICAgICMKICAgICAgICAjIDEuIENhbGwgU1NMQ29weVBlZXJUcnVzdCB0byBnZXQgaG9sZCBvZiB0aGUgdHJ1c3Qgb2JqZWN0IGZvciB0aGlzCiAgICAgICAgIyAgICBjb25uZWN0aW9uLgogICAgICAgICMgMi4gQ2FsbCBTZWNUcnVzdEdldENlcnRpZmljYXRlQXRJbmRleCBmb3IgaW5kZXggMCB0byBnZXQgdGhlIGxlYWYuCiAgICAgICAgIyAzLiBUbyBnZXQgdGhlIENOLCBjYWxsIFNlY0NlcnRpZmljYXRlQ29weUNvbW1vbk5hbWUgYW5kIHByb2Nlc3MgdGhhdAogICAgICAgICMgICAgc3RyaW5nIHNvIHRoYXQgaXQncyBvZiB0aGUgYXBwcm9wcmlhdGUgdHlwZS4KICAgICAgICAjIDQuIFRvIGdldCB0aGUgU0FOLCB3ZSBuZWVkIHRvIGRvIHNvbWV0aGluZyBhIGJpdCBtb3JlIGNvbXBsZXg6CiAgICAgICAgIyAgICBhLiBDYWxsIFNlY0NlcnRpZmljYXRlQ29weVZhbHVlcyB0byBnZXQgdGhlIGRhdGEsIHJlcXVlc3RpbmcKICAgICAgICAjICAgICAgIGtTZWNPSURTdWJqZWN0QWx0TmFtZS4KICAgICAgICAjICAgIGIuIE1lc3MgYWJvdXQgd2l0aCB0aGlzIGRpY3Rpb25hcnkgdG8gdHJ5IHRvIGdldCB0aGUgU0FOcyBvdXQuCiAgICAgICAgIwogICAgICAgICMgVGhpcyBpcyBncm9zcy4gUmVhbGx5IGdyb3NzLiBJdCdzIGdvaW5nIHRvIGJlIGEgZmV3IGh1bmRyZWQgTG9DIGV4dHJhCiAgICAgICAgIyBqdXN0IHRvIHJlcGVhdCBzb21ldGhpbmcgdGhhdCBTZWN1cmVUcmFuc3BvcnQgY2FuICphbHJlYWR5IGRvKi4gU28gbXkKICAgICAgICAjIG9wZXJhdGluZyBhc3N1bXB0aW9uIGF0IHRoaXMgdGltZSBpcyB0aGF0IHdoYXQgd2Ugd2FudCB0byBkbyBpcwogICAgICAgICMgaW5zdGVhZCB0byBqdXN0IGZsYWcgdG8gdXJsbGliMyB0aGF0IGl0IHNob3VsZG4ndCBkbyBpdHMgb3duIGhvc3RuYW1lCiAgICAgICAgIyB2YWxpZGF0aW9uIHdoZW4gdXNpbmcgU2VjdXJlVHJhbnNwb3J0LgogICAgICAgIGlmIG5vdCBiaW5hcnlfZm9ybToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigKICAgICAgICAgICAgICAgICJTZWN1cmVUcmFuc3BvcnQgb25seSBzdXBwb3J0cyBkdW1waW5nIGJpbmFyeSBjZXJ0cyIKICAgICAgICAgICAgKQogICAgICAgIHRydXN0ID0gU2VjdXJpdHkuU2VjVHJ1c3RSZWYoKQogICAgICAgIGNlcnRkYXRhID0gTm9uZQogICAgICAgIGRlcl9ieXRlcyA9IE5vbmUKCiAgICAgICAgdHJ5OgogICAgICAgICAgICAjIEdyYWIgdGhlIHRydXN0IHN0b3JlLgogICAgICAgICAgICByZXN1bHQgPSBTZWN1cml0eS5TU0xDb3B5UGVlclRydXN0KAogICAgICAgICAgICAgICAgc2VsZi5jb250ZXh0LCBjdHlwZXMuYnlyZWYodHJ1c3QpCiAgICAgICAgICAgICkKICAgICAgICAgICAgX2Fzc2VydF9ub19lcnJvcihyZXN1bHQpCiAgICAgICAgICAgIGlmIG5vdCB0cnVzdDoKICAgICAgICAgICAgICAgICMgUHJvYmFibHkgd2UgaGF2ZW4ndCBkb25lIHRoZSBoYW5kc2hha2UgeWV0LiBObyBiaWdnaWUuCiAgICAgICAgICAgICAgICByZXR1cm4gTm9uZQoKICAgICAgICAgICAgY2VydF9jb3VudCA9IFNlY3VyaXR5LlNlY1RydXN0R2V0Q2VydGlmaWNhdGVDb3VudCh0cnVzdCkKICAgICAgICAgICAgaWYgbm90IGNlcnRfY291bnQ6CiAgICAgICAgICAgICAgICAjIEFsc28gYSBjYXNlIHRoYXQgbWlnaHQgaGFwcGVuIGlmIHdlIGhhdmVuJ3QgaGFuZHNoYWtlZC4KICAgICAgICAgICAgICAgICMgSGFuZHNob29rPyBIYW5kc2hha2VuPwogICAgICAgICAgICAgICAgcmV0dXJuIE5vbmUKCiAgICAgICAgICAgIGxlYWYgPSBTZWN1cml0eS5TZWNUcnVzdEdldENlcnRpZmljYXRlQXRJbmRleCh0cnVzdCwgMCkKICAgICAgICAgICAgYXNzZXJ0IGxlYWYKCiAgICAgICAgICAgICMgT2ssIG5vdyB3ZSB3YW50IHRoZSBERVIgYnl0ZXMuCiAgICAgICAgICAgIGNlcnRkYXRhID0gU2VjdXJpdHkuU2VjQ2VydGlmaWNhdGVDb3B5RGF0YShsZWFmKQogICAgICAgICAgICBhc3NlcnQgY2VydGRhdGEKCiAgICAgICAgICAgIGRhdGFfbGVuZ3RoID0gQ29yZUZvdW5kYXRpb24uQ0ZEYXRhR2V0TGVuZ3RoKGNlcnRkYXRhKQogICAgICAgICAgICBkYXRhX2J1ZmZlciA9IENvcmVGb3VuZGF0aW9uLkNGRGF0YUdldEJ5dGVQdHIoY2VydGRhdGEpCiAgICAgICAgICAgIGRlcl9ieXRlcyA9IGN0eXBlcy5zdHJpbmdfYXQoZGF0YV9idWZmZXIsIGRhdGFfbGVuZ3RoKQogICAgICAgIGZpbmFsbHk6CiAgICAgICAgICAgIGlmIGNlcnRkYXRhOgogICAgICAgICAgICAgICAgQ29yZUZvdW5kYXRpb24uQ0ZSZWxlYXNlKGNlcnRkYXRhKQogICAgICAgICAgICBpZiB0cnVzdDoKICAgICAgICAgICAgICAgIENvcmVGb3VuZGF0aW9uLkNGUmVsZWFzZSh0cnVzdCkKCiAgICAgICAgcmV0dXJuIGRlcl9ieXRlcwoKICAgIGRlZiBfcmV1c2Uoc2VsZik6CiAgICAgICAgc2VsZi5fbWFrZWZpbGVfcmVmcyArPSAxCgogICAgZGVmIF9kcm9wKHNlbGYpOgogICAgICAgIGlmIHNlbGYuX21ha2VmaWxlX3JlZnMgPCAxOgogICAgICAgICAgICBzZWxmLmNsb3NlKCkKICAgICAgICBlbHNlOgogICAgICAgICAgICBzZWxmLl9tYWtlZmlsZV9yZWZzIC09IDEKCgppZiBfZmlsZW9iamVjdDogICMgUGxhdGZvcm0tc3BlY2lmaWM6IFB5dGhvbiAyCiAgICBkZWYgbWFrZWZpbGUoc2VsZiwgbW9kZSwgYnVmc2l6ZT0tMSk6CiAgICAgICAgc2VsZi5fbWFrZWZpbGVfcmVmcyArPSAxCiAgICAgICAgcmV0dXJuIF9maWxlb2JqZWN0KHNlbGYsIG1vZGUsIGJ1ZnNpemUsIGNsb3NlPVRydWUpCmVsc2U6ICAjIFBsYXRmb3JtLXNwZWNpZmljOiBQeXRob24gMwogICAgZGVmIG1ha2VmaWxlKHNlbGYsIG1vZGU9InIiLCBidWZmZXJpbmc9Tm9uZSwgKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAjIFdlIGRpc2FibGUgYnVmZmVyaW5nIHdpdGggU2VjdXJlVHJhbnNwb3J0IGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGgKICAgICAgICAjIHRoZSBidWZmZXJpbmcgdGhhdCBTVCBkb2VzIGludGVybmFsbHkgKHNlZSBpc3N1ZSAjMTE1MyBmb3IgbW9yZSkuCiAgICAgICAgYnVmZmVyaW5nID0gMAogICAgICAgIHJldHVybiBiYWNrcG9ydF9tYWtlZmlsZShzZWxmLCBtb2RlLCBidWZmZXJpbmcsICphcmdzLCAqKmt3YXJncykKCldyYXBwZWRTb2NrZXQubWFrZWZpbGUgPSBtYWtlZmlsZQoKCmNsYXNzIFNlY3VyZVRyYW5zcG9ydENvbnRleHQob2JqZWN0KToKICAgICIiIgogICAgSSBhbSBhIHdyYXBwZXIgY2xhc3MgZm9yIHRoZSBTZWN1cmVUcmFuc3BvcnQgbGlicmFyeSwgdG8gdHJhbnNsYXRlIHRoZQogICAgaW50ZXJmYWNlIG9mIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGBgU1NMQ29udGV4dGBgIG9iamVjdCB0byBjYWxscyBpbnRvCiAgICBTZWN1cmVUcmFuc3BvcnQuCiAgICAiIiIKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwcm90b2NvbCk6CiAgICAgICAgc2VsZi5fbWluX3ZlcnNpb24sIHNlbGYuX21heF92ZXJzaW9uID0gX3Byb3RvY29sX3RvX21pbl9tYXhbcHJvdG9jb2xdCiAgICAgICAgc2VsZi5fb3B0aW9ucyA9IDAKICAgICAgICBzZWxmLl92ZXJpZnkgPSBGYWxzZQogICAgICAgIHNlbGYuX3RydXN0X2J1bmRsZSA9IE5vbmUKICAgICAgICBzZWxmLl9jbGllbnRfY2VydCA9IE5vbmUKICAgICAgICBzZWxmLl9jbGllbnRfa2V5ID0gTm9uZQogICAgICAgIHNlbGYuX2NsaWVudF9rZXlfcGFzc3BocmFzZSA9IE5vbmUKCiAgICBAcHJvcGVydHkKICAgIGRlZiBjaGVja19ob3N0bmFtZShzZWxmKToKICAgICAgICAiIiIKICAgICAgICBTZWN1cmVUcmFuc3BvcnQgY2Fubm90IGhhdmUgaXRzIGhvc3RuYW1lIGNoZWNraW5nIGRpc2FibGVkLiBGb3IgbW9yZSwKICAgICAgICBzZWUgdGhlIGNvbW1lbnQgb24gZ2V0cGVlcmNlcnQoKSBpbiB0aGlzIGZpbGUuCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIFRydWUKCiAgICBAY2hlY2tfaG9zdG5hbWUuc2V0dGVyCiAgICBkZWYgY2hlY2tfaG9zdG5hbWUoc2VsZiwgdmFsdWUpOgogICAgICAgICIiIgogICAgICAgIFNlY3VyZVRyYW5zcG9ydCBjYW5ub3QgaGF2ZSBpdHMgaG9zdG5hbWUgY2hlY2tpbmcgZGlzYWJsZWQuIEZvciBtb3JlLAogICAgICAgIHNlZSB0aGUgY29tbWVudCBvbiBnZXRwZWVyY2VydCgpIGluIHRoaXMgZmlsZS4KICAgICAgICAiIiIKICAgICAgICBwYXNzCgogICAgQHByb3BlcnR5CiAgICBkZWYgb3B0aW9ucyhzZWxmKToKICAgICAgICAjIFRPRE86IFdlbGwsIGNyYXAuCiAgICAgICAgIwogICAgICAgICMgU28gdGhpcyBpcyB0aGUgYml0IG9mIHRoZSBjb2RlIHRoYXQgaXMgdGhlIG1vc3QgbGlrZWx5IHRvIGNhdXNlIHVzCiAgICAgICAgIyB0cm91YmxlLiBFc3NlbnRpYWxseSB3ZSBuZWVkIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIFNTTCBvcHRpb25zIHRoYXQKICAgICAgICAjIHVzZXJzIG1pZ2h0IHdhbnQgdG8gdXNlIGFuZCB0cnkgdG8gc2VlIGlmIHdlIGNhbiBzZW5zaWJseSB0cmFuc2xhdGUKICAgICAgICAjIHRoZW0sIG9yIHdoZXRoZXIgd2Ugc2hvdWxkIGp1c3QgaWdub3JlIHRoZW0uCiAgICAgICAgcmV0dXJuIHNlbGYuX29wdGlvbnMKCiAgICBAb3B0aW9ucy5zZXR0ZXIKICAgIGRlZiBvcHRpb25zKHNlbGYsIHZhbHVlKToKICAgICAgICAjIFRPRE86IFVwZGF0ZSBpbiBsaW5lIHdpdGggYWJvdmUuCiAgICAgICAgc2VsZi5fb3B0aW9ucyA9IHZhbHVlCgogICAgQHByb3BlcnR5CiAgICBkZWYgdmVyaWZ5X21vZGUoc2VsZik6CiAgICAgICAgcmV0dXJuIHNzbC5DRVJUX1JFUVVJUkVEIGlmIHNlbGYuX3ZlcmlmeSBlbHNlIHNzbC5DRVJUX05PTkUKCiAgICBAdmVyaWZ5X21vZGUuc2V0dGVyCiAgICBkZWYgdmVyaWZ5X21vZGUoc2VsZiwgdmFsdWUpOgogICAgICAgIHNlbGYuX3ZlcmlmeSA9IFRydWUgaWYgdmFsdWUgPT0gc3NsLkNFUlRfUkVRVUlSRUQgZWxzZSBGYWxzZQoKICAgIGRlZiBzZXRfZGVmYXVsdF92ZXJpZnlfcGF0aHMoc2VsZik6CiAgICAgICAgIyBTbywgdGhpcyBoYXMgdG8gZG8gc29tZXRoaW5nIGEgYml0IHdlaXJkLiBTcGVjaWZpY2FsbHksIHdoYXQgaXQgZG9lcwogICAgICAgICMgaXMgbm90aGluZy4KICAgICAgICAjCiAgICAgICAgIyBUaGlzIG1lYW5zIHRoYXQsIGlmIHdlIGhhZCBwcmV2aW91c2x5IGhhZCBsb2FkX3ZlcmlmeV9sb2NhdGlvbnMKICAgICAgICAjIGNhbGxlZCwgdGhpcyBkb2VzIG5vdCB1bmRvIHRoYXQuIFdlIG5lZWQgdG8gZG8gdGhhdCBiZWNhdXNlIGl0IHR1cm5zCiAgICAgICAgIyBvdXQgdGhhdCB0aGUgcmVzdCBvZiB0aGUgdXJsbGliMyBjb2RlIHdpbGwgYXR0ZW1wdCB0byBsb2FkIHRoZQogICAgICAgICMgZGVmYXVsdCB2ZXJpZnkgcGF0aHMgaWYgaXQgaGFzbid0IGJlZW4gdG9sZCBhYm91dCBhbnkgcGF0aHMsIGV2ZW4gaWYKICAgICAgICAjIHRoZSBjb250ZXh0IGl0c2VsZiB3YXMgc29tZXRpbWUgZWFybGllci4gV2UgcmVzb2x2ZSB0aGF0IGJ5IGp1c3QKICAgICAgICAjIGlnbm9yaW5nIGl0LgogICAgICAgIHBhc3MKCiAgICBkZWYgbG9hZF9kZWZhdWx0X2NlcnRzKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLnNldF9kZWZhdWx0X3ZlcmlmeV9wYXRocygpCgogICAgZGVmIHNldF9jaXBoZXJzKHNlbGYsIGNpcGhlcnMpOgogICAgICAgICMgRm9yIG5vdywgd2UganVzdCByZXF1aXJlIHRoZSBkZWZhdWx0IGNpcGhlciBzdHJpbmcuCiAgICAgICAgaWYgY2lwaGVycyAhPSB1dGlsLnNzbF8uREVGQVVMVF9DSVBIRVJTOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKAogICAgICAgICAgICAgICAgIlNlY3VyZVRyYW5zcG9ydCBkb2Vzbid0IHN1cHBvcnQgY3VzdG9tIGNpcGhlciBzdHJpbmdzIgogICAgICAgICAgICApCgogICAgZGVmIGxvYWRfdmVyaWZ5X2xvY2F0aW9ucyhzZWxmLCBjYWZpbGU9Tm9uZSwgY2FwYXRoPU5vbmUsIGNhZGF0YT1Ob25lKToKICAgICAgICAjIE9LLCB3ZSBvbmx5IHJlYWxseSBzdXBwb3J0IGNhZGF0YSBhbmQgY2FmaWxlLgogICAgICAgIGlmIGNhcGF0aCBpcyBub3QgTm9uZToKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigKICAgICAgICAgICAgICAgICJTZWN1cmVUcmFuc3BvcnQgZG9lcyBub3Qgc3VwcG9ydCBjZXJ0IGRpcmVjdG9yaWVzIgogICAgICAgICAgICApCgogICAgICAgIHNlbGYuX3RydXN0X2J1bmRsZSA9IGNhZmlsZSBvciBjYWRhdGEKCiAgICBkZWYgbG9hZF9jZXJ0X2NoYWluKHNlbGYsIGNlcnRmaWxlLCBrZXlmaWxlPU5vbmUsIHBhc3N3b3JkPU5vbmUpOgogICAgICAgIHNlbGYuX2NsaWVudF9jZXJ0ID0gY2VydGZpbGUKICAgICAgICBzZWxmLl9jbGllbnRfa2V5ID0ga2V5ZmlsZQogICAgICAgIHNlbGYuX2NsaWVudF9jZXJ0X3Bhc3NwaHJhc2UgPSBwYXNzd29yZAoKICAgIGRlZiB3cmFwX3NvY2tldChzZWxmLCBzb2NrLCBzZXJ2ZXJfc2lkZT1GYWxzZSwKICAgICAgICAgICAgICAgICAgICBkb19oYW5kc2hha2Vfb25fY29ubmVjdD1UcnVlLCBzdXBwcmVzc19yYWdnZWRfZW9mcz1UcnVlLAogICAgICAgICAgICAgICAgICAgIHNlcnZlcl9ob3N0bmFtZT1Ob25lKToKICAgICAgICAjIFNvLCB3aGF0IGRvIHdlIGRvIGhlcmU/IEZpcnN0bHksIHdlIGFzc2VydCBzb21lIHByb3BlcnRpZXMuIFRoaXMgaXMgYQogICAgICAgICMgc3RyaXBwZWQgZG93biBzaGltLCBzbyB0aGVyZSBpcyBzb21lIGZ1bmN0aW9uYWxpdHkgd2UgZG9uJ3Qgc3VwcG9ydC4KICAgICAgICAjIFNlZSBQRVAgNTQzIGZvciB0aGUgcmVhbCBkZWFsLgogICAgICAgIGFzc2VydCBub3Qgc2VydmVyX3NpZGUKICAgICAgICBhc3NlcnQgZG9faGFuZHNoYWtlX29uX2Nvbm5lY3QKICAgICAgICBhc3NlcnQgc3VwcHJlc3NfcmFnZ2VkX2VvZnMKCiAgICAgICAgIyBPaywgd2UncmUgZ29vZCB0byBnby4gTm93IHdlIHdhbnQgdG8gY3JlYXRlIHRoZSB3cmFwcGVkIHNvY2tldCBvYmplY3QKICAgICAgICAjIGFuZCBzdG9yZSBpdCBpbiB0aGUgYXBwcm9wcmlhdGUgcGxhY2UuCiAgICAgICAgd3JhcHBlZF9zb2NrZXQgPSBXcmFwcGVkU29ja2V0KHNvY2spCgogICAgICAgICMgTm93IHdlIGNhbiBoYW5kc2hha2UKICAgICAgICB3cmFwcGVkX3NvY2tldC5oYW5kc2hha2UoCiAgICAgICAgICAgIHNlcnZlcl9ob3N0bmFtZSwgc2VsZi5fdmVyaWZ5LCBzZWxmLl90cnVzdF9idW5kbGUsCiAgICAgICAgICAgIHNlbGYuX21pbl92ZXJzaW9uLCBzZWxmLl9tYXhfdmVyc2lvbiwgc2VsZi5fY2xpZW50X2NlcnQsCiAgICAgICAgICAgIHNlbGYuX2NsaWVudF9rZXksIHNlbGYuX2NsaWVudF9rZXlfcGFzc3BocmFzZQogICAgICAgICkKICAgICAgICByZXR1cm4gd3JhcHBlZF9zb2NrZXQK
