statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/pycryptoenv/1.0.7/pycryptoenv-1.0.7/pycryptoenv-1.0.7/pycryptoenv/_win/_advapi32.py
  contents:
  - name: open_context_handle
    score: 0.0
    code: |-
      def open_context_handle(provider, verify_only=True):
          if provider == Advapi32Const.MS_ENH_RSA_AES_PROV:
              provider_type = Advapi32Const.PROV_RSA_AES
          elif provider == Advapi32Const.MS_ENH_DSS_DH_PROV:
              provider_type = Advapi32Const.PROV_DSS_DH
          else:
              raise ValueError('Invalid provider specified: %s' % provider)

          # The DSS provider needs a container to allow importing and exporting
          # private keys, but all of the RSA stuff works fine with CRYPT_VERIFYCONTEXT
          if verify_only or provider != Advapi32Const.MS_ENH_DSS_DH_PROV:
              container_name = null()
              flags = Advapi32Const.CRYPT_VERIFYCONTEXT
          else:
              container_name = Advapi32Const.CONTAINER_NAME
              flags = Advapi32Const.CRYPT_NEWKEYSET

          context_handle_pointer = new(advapi32, 'HCRYPTPROV *')
          res = advapi32.CryptAcquireContextW(
              context_handle_pointer,
              container_name,
              provider,
              provider_type,
              flags
          )
          # If using the DSS provider and the container exists, just open it
          if not res and get_error()[0] == Advapi32Const.NTE_EXISTS:
              res = advapi32.CryptAcquireContextW(
                  context_handle_pointer,
                  container_name,
                  provider,
                  provider_type,
                  0
              )
          handle_error(res)

          return unwrap(context_handle_pointer)
    tokens: resume load_fast provider load_global Advapi32Const load_attr STRING_LEN_S_ENT_HIGH compare_op == pop_jump_if_false TO_NUMBER load_global Advapi32Const load_attr PROV_RSA_AES store_fast provider_type jump_forward TO_NUMBER load_fast provider load_global Advapi32Const load_attr STRING_LEN_S_ENT_HIGH compare_op == pop_jump_if_false TO_NUMBER load_global Advapi32Const load_attr PROV_DSS_DH store_fast provider_type jump_forward TO_NUMBER load_global ValueError load_const STRING_LEN_S_ENT_HIGH load_fast provider binary_op % call raise_varargs load_fast verify_only pop_jump_if_true TO_NUMBER load_fast provider load_global Advapi32Const load_attr STRING_LEN_S_ENT_HIGH compare_op != pop_jump_if_false TO_NUMBER load_global null call store_fast container_name load_global Advapi32Const load_attr STRING_LEN_S_ENT_HIGH store_fast flags jump_forward TO_NUMBER load_global Advapi32Const load_attr CONTAINER_NAME store_fast container_name load_global Advapi32Const load_attr CRYPT_NEWKEYSET store_fast flags load_global new load_global advapi32 load_const HCRYPTPROV * call store_fast STRING_LEN_S_ENT_HIGH load_global advapi32 load_attr STRING_BASE64_LEN_S_ENT_HIGH load_fast STRING_LEN_S_ENT_HIGH load_fast container_name load_fast provider load_fast provider_type load_fast flags call store_fast res load_fast res pop_jump_if_true TO_NUMBER load_global get_error call load_const INTEGER binary_subscr load_global Advapi32Const load_attr NTE_EXISTS compare_op == pop_jump_if_false TO_NUMBER load_global advapi32 load_attr STRING_BASE64_LEN_S_ENT_HIGH load_fast STRING_LEN_S_ENT_HIGH load_fast container_name load_fast provider load_fast provider_type load_const INTEGER call store_fast res load_global handle_error load_fast res call pop_top load_global unwrap load_fast STRING_LEN_S_ENT_HIGH call return_value
    hash: 30fc13c0d790127a684d0f35ccab0b9b0f206e23336f72943195135195421840
sources:
  ? .repo_cache/malicious_repos/pypi_malregistry/pycryptoenv/1.0.7/pycryptoenv-1.0.7/pycryptoenv-1.0.7/pycryptoenv/_win/_advapi32.py
  : IyBjb2Rpbmc6IHV0Zi04CmZyb20gX19mdXR1cmVfXyBpbXBvcnQgdW5pY29kZV9saXRlcmFscywgZGl2aXNpb24sIGFic29sdXRlX2ltcG9ydCwgcHJpbnRfZnVuY3Rpb24KCmltcG9ydCBzeXMKCmZyb20gLi4gaW1wb3J0IGZmaQpmcm9tIC5fZGVjb2RlIGltcG9ydCBfdHJ5X2RlY29kZQpmcm9tIC4uZXJyb3JzIGltcG9ydCBTaWduYXR1cmVFcnJvcgpmcm9tIC4uX2ZmaSBpbXBvcnQgbmV3LCB1bndyYXAsIG51bGwKZnJvbSAuLl90eXBlcyBpbXBvcnQgc3RyX2NscwoKaWYgZmZpKCkgPT0gJ2NmZmknOgogICAgZnJvbSAuX2FkdmFwaTMyX2NmZmkgaW1wb3J0IGFkdmFwaTMyLCBnZXRfZXJyb3IKZWxzZToKICAgIGZyb20gLl9hZHZhcGkzMl9jdHlwZXMgaW1wb3J0IGFkdmFwaTMyLCBnZXRfZXJyb3IKCgpfX2FsbF9fID0gWwogICAgJ2FkdmFwaTMyJywKICAgICdBZHZhcGkzMkNvbnN0JywKICAgICdoYW5kbGVfZXJyb3InLApdCgoKX2d3diA9IHN5cy5nZXR3aW5kb3dzdmVyc2lvbigpCl93aW5fdmVyc2lvbl9pbmZvID0gKF9nd3ZbMF0sIF9nd3ZbMV0pCgoKZGVmIG9wZW5fY29udGV4dF9oYW5kbGUocHJvdmlkZXIsIHZlcmlmeV9vbmx5PVRydWUpOgogICAgaWYgcHJvdmlkZXIgPT0gQWR2YXBpMzJDb25zdC5NU19FTkhfUlNBX0FFU19QUk9WOgogICAgICAgIHByb3ZpZGVyX3R5cGUgPSBBZHZhcGkzMkNvbnN0LlBST1ZfUlNBX0FFUwogICAgZWxpZiBwcm92aWRlciA9PSBBZHZhcGkzMkNvbnN0Lk1TX0VOSF9EU1NfREhfUFJPVjoKICAgICAgICBwcm92aWRlcl90eXBlID0gQWR2YXBpMzJDb25zdC5QUk9WX0RTU19ESAogICAgZWxzZToKICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCdJbnZhbGlkIHByb3ZpZGVyIHNwZWNpZmllZDogJXMnICUgcHJvdmlkZXIpCgogICAgIyBUaGUgRFNTIHByb3ZpZGVyIG5lZWRzIGEgY29udGFpbmVyIHRvIGFsbG93IGltcG9ydGluZyBhbmQgZXhwb3J0aW5nCiAgICAjIHByaXZhdGUga2V5cywgYnV0IGFsbCBvZiB0aGUgUlNBIHN0dWZmIHdvcmtzIGZpbmUgd2l0aCBDUllQVF9WRVJJRllDT05URVhUCiAgICBpZiB2ZXJpZnlfb25seSBvciBwcm92aWRlciAhPSBBZHZhcGkzMkNvbnN0Lk1TX0VOSF9EU1NfREhfUFJPVjoKICAgICAgICBjb250YWluZXJfbmFtZSA9IG51bGwoKQogICAgICAgIGZsYWdzID0gQWR2YXBpMzJDb25zdC5DUllQVF9WRVJJRllDT05URVhUCiAgICBlbHNlOgogICAgICAgIGNvbnRhaW5lcl9uYW1lID0gQWR2YXBpMzJDb25zdC5DT05UQUlORVJfTkFNRQogICAgICAgIGZsYWdzID0gQWR2YXBpMzJDb25zdC5DUllQVF9ORVdLRVlTRVQKCiAgICBjb250ZXh0X2hhbmRsZV9wb2ludGVyID0gbmV3KGFkdmFwaTMyLCAnSENSWVBUUFJPViAqJykKICAgIHJlcyA9IGFkdmFwaTMyLkNyeXB0QWNxdWlyZUNvbnRleHRXKAogICAgICAgIGNvbnRleHRfaGFuZGxlX3BvaW50ZXIsCiAgICAgICAgY29udGFpbmVyX25hbWUsCiAgICAgICAgcHJvdmlkZXIsCiAgICAgICAgcHJvdmlkZXJfdHlwZSwKICAgICAgICBmbGFncwogICAgKQogICAgIyBJZiB1c2luZyB0aGUgRFNTIHByb3ZpZGVyIGFuZCB0aGUgY29udGFpbmVyIGV4aXN0cywganVzdCBvcGVuIGl0CiAgICBpZiBub3QgcmVzIGFuZCBnZXRfZXJyb3IoKVswXSA9PSBBZHZhcGkzMkNvbnN0Lk5URV9FWElTVFM6CiAgICAgICAgcmVzID0gYWR2YXBpMzIuQ3J5cHRBY3F1aXJlQ29udGV4dFcoCiAgICAgICAgICAgIGNvbnRleHRfaGFuZGxlX3BvaW50ZXIsCiAgICAgICAgICAgIGNvbnRhaW5lcl9uYW1lLAogICAgICAgICAgICBwcm92aWRlciwKICAgICAgICAgICAgcHJvdmlkZXJfdHlwZSwKICAgICAgICAgICAgMAogICAgICAgICkKICAgIGhhbmRsZV9lcnJvcihyZXMpCgogICAgcmV0dXJuIHVud3JhcChjb250ZXh0X2hhbmRsZV9wb2ludGVyKQoKCmRlZiBjbG9zZV9jb250ZXh0X2hhbmRsZShoYW5kbGUpOgogICAgcmVzID0gYWR2YXBpMzIuQ3J5cHRSZWxlYXNlQ29udGV4dChoYW5kbGUsIDApCiAgICBoYW5kbGVfZXJyb3IocmVzKQoKCmRlZiBoYW5kbGVfZXJyb3IocmVzdWx0KToKICAgICIiIgogICAgRXh0cmFjdHMgdGhlIGxhc3QgV2luZG93cyBlcnJvciBtZXNzYWdlIGludG8gYSBweXRob24gdW5pY29kZSBzdHJpbmcKCiAgICA6cGFyYW0gcmVzdWx0OgogICAgICAgIEEgZnVuY3Rpb24gcmVzdWx0LCAwIG9yIE5vbmUgaW5kaWNhdGVzIGZhaWx1cmUKCiAgICA6cmV0dXJuOgogICAgICAgIEEgdW5pY29kZSBzdHJpbmcgZXJyb3IgbWVzc2FnZQogICAgIiIiCgogICAgaWYgcmVzdWx0OgogICAgICAgIHJldHVybgoKICAgIGNvZGUsIGVycm9yX3N0cmluZyA9IGdldF9lcnJvcigpCgogICAgaWYgY29kZSA9PSBBZHZhcGkzMkNvbnN0Lk5URV9CQURfU0lHTkFUVVJFOgogICAgICAgIHJhaXNlIFNpZ25hdHVyZUVycm9yKCdTaWduYXR1cmUgaXMgaW52YWxpZCcpCgogICAgaWYgbm90IGlzaW5zdGFuY2UoZXJyb3Jfc3RyaW5nLCBzdHJfY2xzKToKICAgICAgICBlcnJvcl9zdHJpbmcgPSBfdHJ5X2RlY29kZShlcnJvcl9zdHJpbmcpCgogICAgcmFpc2UgT1NFcnJvcihlcnJvcl9zdHJpbmcpCgoKY2xhc3MgQWR2YXBpMzJDb25zdCgpOgogICAgIyBOYW1lIHdlIGdpdmUgdG8gYSBjb250YWluZXIgdXNlZCB0byBtYWtlIERTQSBwcml2YXRlIGtleSBpbXBvcnQvZXhwb3J0IHdvcmsKICAgIENPTlRBSU5FUl9OQU1FID0gJ29zY3J5cHRvIHRlbXBvcmFyeSBEU1Mga2V5c2V0JwoKICAgIFBST1ZfUlNBX0FFUyA9IDI0CiAgICBQUk9WX0RTU19ESCA9IDEzCgogICAgWDUwOV9QVUJMSUNfS0VZX0lORk8gPSA4CiAgICBQS0NTX1BSSVZBVEVfS0VZX0lORk8gPSA0NAogICAgWDUwOV9EU1NfU0lHTkFUVVJFID0gNDAKICAgIENSWVBUX05PX1NBTFQgPSAweDAwMDAwMDEwCgogICAgTVNfRU5IX0RTU19ESF9QUk9WID0gIk1pY3Jvc29mdCBFbmhhbmNlZCBEU1MgYW5kIERpZmZpZS1IZWxsbWFuIENyeXB0b2dyYXBoaWMgUHJvdmlkZXIiCiAgICAjIFRoaXMgaXMgdGhlIG5hbWUgZm9yIFdpbmRvd3MgU2VydmVyIDIwMDMgYW5kIG5ld2VyIGFuZCBXaW5kb3dzIFZpc3RhIGFuZCBuZXdlcgogICAgTVNfRU5IX1JTQV9BRVNfUFJPViA9ICJNaWNyb3NvZnQgRW5oYW5jZWQgUlNBIGFuZCBBRVMgQ3J5cHRvZ3JhcGhpYyBQcm92aWRlciIKCiAgICBDUllQVF9FWFBPUlRBQkxFID0gMQogICAgQ1JZUFRfTkVXS0VZU0VUID0gMHgwMDAwMDAwOAogICAgQ1JZUFRfVkVSSUZZQ09OVEVYVCA9IDB4RjAwMDAwMDAKCiAgICBDQUxHX01ENSA9IDB4MDAwMDgwMDMKICAgIENBTEdfU0hBMSA9IDB4MDAwMDgwMDQKICAgIENBTEdfU0hBXzI1NiA9IDB4MDAwMDgwMGMKICAgIENBTEdfU0hBXzM4NCA9IDB4MDAwMDgwMGQKICAgIENBTEdfU0hBXzUxMiA9IDB4MDAwMDgwMGUKCiAgICBDQUxHX1JDMiA9IDB4MDAwMDY2MDIKICAgIENBTEdfUkM0ID0gMHgwMDAwNjgwMQogICAgQ0FMR19ERVMgPSAweDAwMDA2NjAxCiAgICBDQUxHXzNERVNfMTEyID0gMHgwMDAwNjYwOQogICAgQ0FMR18zREVTID0gMHgwMDAwNjYwMwogICAgQ0FMR19BRVNfMTI4ID0gMHgwMDAwNjYwZQogICAgQ0FMR19BRVNfMTkyID0gMHgwMDAwNjYwZgogICAgQ0FMR19BRVNfMjU2ID0gMHgwMDAwNjYxMAoKICAgIENBTEdfRFNTX1NJR04gPSAweDAwMDAyMjAwCiAgICBDQUxHX1JTQV9TSUdOID0gMHgwMDAwMjQwMAogICAgQ0FMR19SU0FfS0VZWCA9IDB4MDAwMGE0MDAKCiAgICBDUllQVF9NT0RFX0NCQyA9IDEKCiAgICBQS0NTNV9QQURESU5HID0gMQoKICAgIENVUl9CTE9CX1ZFUlNJT04gPSAyCiAgICBQVUJMSUNLRVlCTE9CID0gNgogICAgUFJJVkFURUtFWUJMT0IgPSA3CiAgICBQTEFJTlRFWFRLRVlCTE9CID0gOAoKICAgIEtQX0lWID0gMQogICAgS1BfUEFERElORyA9IDMKICAgIEtQX01PREUgPSA0CiAgICBLUF9FRkZFQ1RJVkVfS0VZTEVOID0gMTkKCiAgICBDUllQVF9PQUVQID0gMHgwMDAwMDA0MAoKICAgIE5URV9CQURfU0lHTkFUVVJFID0gLTIxNDY4OTM4MTggICMgMHg4MDA5MDAwNgogICAgTlRFX0VYSVNUUyA9IC0yMTQ2ODkzODA5ICAjIDB4ODAwOTAwMEYKICAgIEFUX1NJR05BVFVSRSA9IDIKCiAgICBSU0ExID0gMHgzMTQxNTM1MgogICAgUlNBMiA9IDB4MzI0MTUzNTIKICAgIERTUzEgPSAweDMxNTM1MzQ0CiAgICBEU1MyID0gMHgzMjUzNTM0NAoKCmlmIF93aW5fdmVyc2lvbl9pbmZvID09ICg1LCAxKToKICAgICMgVGhpcyBpcyB0aGUgV2luZG93cyBYUCBuYW1lIGZvciB0aGUgcHJvdmlkZXIKICAgIEFkdmFwaTMyQ29uc3QuTVNfRU5IX1JTQV9BRVNfUFJPViA9ICJNaWNyb3NvZnQgRW5oYW5jZWQgUlNBIGFuZCBBRVMgQ3J5cHRvZ3JhcGhpYyBQcm92aWRlciAoUHJvdG90eXBlKSIK
