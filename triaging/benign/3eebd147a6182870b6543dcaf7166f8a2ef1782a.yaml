statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/test/test_connectionpool.py
  contents:
  - name: <module>
    score: 0.0
    code: |-
      from __future__ import absolute_import

      import sys

      from urllib3.connectionpool import (
          connection_from_url,
          HTTPConnection,
          HTTPConnectionPool,
          HTTPSConnectionPool,
      )
      from urllib3.response import httplib, HTTPResponse
      from urllib3.util.timeout import Timeout
      from urllib3.packages.six.moves.http_client import HTTPException
      from urllib3.packages.six.moves.queue import Empty
      from urllib3.packages.ssl_match_hostname import CertificateError
      from urllib3.exceptions import (
          ClosedPoolError,
          EmptyPoolError,
          HostChangedError,
          LocationValueError,
          MaxRetryError,
          ProtocolError,
          SSLError,
          TimeoutError,
      )
      from urllib3._collections import HTTPHeaderDict
      from .test_response import MockChunkedEncodingResponse, MockSock

      from socket import error as SocketError
      from ssl import SSLError as BaseSSLError

      from dummyserver.server import DEFAULT_CA

      if sys.version_info >= (2, 7):
          import unittest
      else:
          import unittest2 as unittest


      class TestConnectionPool(unittest.TestCase):
          """
          Tests in this suite should exercise the ConnectionPool functionality
          without actually making any network requests or connections.
          """
          def test_same_host(self):
              same_host = [
                  ('http://google.com/', '/'),
                  ('http://google.com/', 'http://google.com/'),
                  ('http://google.com/', 'http://google.com'),
                  ('http://google.com/', 'http://google.com/abra/cadabra'),
                  ('http://google.com:42/', 'http://google.com:42/abracadabra'),
                  # Test comparison using default ports
                  ('http://google.com:80/', 'http://google.com/abracadabra'),
                  ('http://google.com/', 'http://google.com:80/abracadabra'),
                  ('https://google.com:443/', 'https://google.com/abracadabra'),
                  ('https://google.com/', 'https://google.com:443/abracadabra'),
                  ('http://[2607:f8b0:4005:805::200e%25eth0]/',
                   'http://[2607:f8b0:4005:805::200e%eth0]/'),
                  ('https://[2607:f8b0:4005:805::200e%25eth0]:443/',
                   'https://[2607:f8b0:4005:805::200e%eth0]:443/'),
                  ('http://[::1]/', 'http://[::1]'),
                  ('http://[2001:558:fc00:200:f816:3eff:fef9:b954%lo]/',
                   'http://[2001:558:fc00:200:f816:3eff:fef9:b954%25lo]')
              ]

              for a, b in same_host:
                  c = connection_from_url(a)
                  self.addCleanup(c.close)
                  self.assertTrue(c.is_same_host(b), "%s =? %s" % (a, b))

              not_same_host = [
                  ('https://google.com/', 'http://google.com/'),
                  ('http://google.com/', 'https://google.com/'),
                  ('http://yahoo.com/', 'http://google.com/'),
                  ('http://google.com:42', 'https://google.com/abracadabra'),
                  ('http://google.com', 'https://google.net/'),
                  # Test comparison with default ports
                  ('http://google.com:42', 'http://google.com'),
                  ('https://google.com:42', 'https://google.com'),
                  ('http://google.com:443', 'http://google.com'),
                  ('https://google.com:80', 'https://google.com'),
                  ('http://google.com:443', 'https://google.com'),
                  ('https://google.com:80', 'http://google.com'),
                  ('https://google.com:443', 'http://google.com'),
                  ('http://google.com:80', 'https://google.com'),
                  # Zone identifiers are unique connection end points and should
                  # never be equivalent.
                  ('http://[dead::beef]', 'https://[dead::beef%en5]/'),
              ]

              for a, b in not_same_host:
                  c = connection_from_url(a)
                  self.addCleanup(c.close)
                  self.assertFalse(c.is_same_host(b), "%s =? %s" % (a, b))
                  c = connection_from_url(b)
                  self.addCleanup(c.close)
                  self.assertFalse(c.is_same_host(a), "%s =? %s" % (b, a))

          def test_same_host_no_port(self):
              # This test was introduced in #801 to deal with the fact that urllib3
              # never initializes ConnectionPool objects with port=None.
              same_host_http = [
                  ('google.com', '/'),
                  ('google.com', 'http://google.com/'),
                  ('google.com', 'http://google.com'),
                  ('google.com', 'http://google.com/abra/cadabra'),
                  # Test comparison using default ports
                  ('google.com', 'http://google.com:80/abracadabra'),
              ]
              same_host_https = [
                  ('google.com', '/'),
                  ('google.com', 'https://google.com/'),
                  ('google.com', 'https://google.com'),
                  ('google.com', 'https://google.com/abra/cadabra'),
                  # Test comparison using default ports
                  ('google.com', 'https://google.com:443/abracadabra'),
              ]

              for a, b in same_host_http:
                  c = HTTPConnectionPool(a)
                  self.addCleanup(c.close)
                  self.assertTrue(c.is_same_host(b), "%s =? %s" % (a, b))
              for a, b in same_host_https:
                  c = HTTPSConnectionPool(a)
                  self.addCleanup(c.close)
                  self.assertTrue(c.is_same_host(b), "%s =? %s" % (a, b))

              not_same_host_http = [
                  ('google.com', 'https://google.com/'),
                  ('yahoo.com', 'http://google.com/'),
                  ('google.com', 'https://google.net/'),
              ]
              not_same_host_https = [
                  ('google.com', 'http://google.com/'),
                  ('yahoo.com', 'https://google.com/'),
                  ('google.com', 'https://google.net/'),
              ]

              for a, b in not_same_host_http:
                  c = HTTPConnectionPool(a)
                  self.addCleanup(c.close)
                  self.assertFalse(c.is_same_host(b), "%s =? %s" % (a, b))
                  c = HTTPConnectionPool(b)
                  self.addCleanup(c.close)
                  self.assertFalse(c.is_same_host(a), "%s =? %s" % (b, a))
              for a, b in not_same_host_https:
                  c = HTTPSConnectionPool(a)
                  self.addCleanup(c.close)
                  self.assertFalse(c.is_same_host(b), "%s =? %s" % (a, b))
                  c = HTTPSConnectionPool(b)
                  self.addCleanup(c.close)
                  self.assertFalse(c.is_same_host(a), "%s =? %s" % (b, a))

          def test_max_connections(self):
              pool = HTTPConnectionPool(host='localhost', maxsize=1, block=True)
              self.addCleanup(pool.close)

              pool._get_conn(timeout=0.01)

              try:
                  pool._get_conn(timeout=0.01)
                  self.fail("Managed to get a connection without EmptyPoolError")
              except EmptyPoolError:
                  pass

              try:
                  pool.request('GET', '/', pool_timeout=0.01)
                  self.fail("Managed to get a connection without EmptyPoolError")
              except EmptyPoolError:
                  pass

              self.assertEqual(pool.num_connections, 1)

          def test_pool_edgecases(self):
              pool = HTTPConnectionPool(host='localhost', maxsize=1, block=False)
              self.addCleanup(pool.close)

              conn1 = pool._get_conn()
              conn2 = pool._get_conn()  # New because block=False

              pool._put_conn(conn1)
              pool._put_conn(conn2)  # Should be discarded

              self.assertEqual(conn1, pool._get_conn())
              self.assertNotEqual(conn2, pool._get_conn())

              self.assertEqual(pool.num_connections, 3)

          def test_exception_str(self):
              self.assertEqual(
                  str(EmptyPoolError(HTTPConnectionPool(host='localhost'), "Test.")),
                  "HTTPConnectionPool(host='localhost', port=None): Test.")

          def test_retry_exception_str(self):
              self.assertEqual(
                  str(MaxRetryError(
                      HTTPConnectionPool(host='localhost'), "Test.", None)),
                  "HTTPConnectionPool(host='localhost', port=None): "
                  "Max retries exceeded with url: Test. (Caused by None)")

              err = SocketError("Test")

              # using err.__class__ here, as socket.error is an alias for OSError
              # since Py3.3 and gets printed as this
              self.assertEqual(
                  str(MaxRetryError(
                      HTTPConnectionPool(host='localhost'), "Test.", err)),
                  "HTTPConnectionPool(host='localhost', port=None): "
                  "Max retries exceeded with url: Test. "
                  "(Caused by %r)" % err)

          def test_pool_size(self):
              POOL_SIZE = 1
              pool = HTTPConnectionPool(host='localhost', maxsize=POOL_SIZE, block=True)
              self.addCleanup(pool.close)

              def _raise(ex):
                  raise ex()

              def _test(exception, expect):
                  pool._make_request = lambda *args, **kwargs: _raise(exception)
                  self.assertRaises(expect, pool.request, 'GET', '/')

                  self.assertEqual(pool.pool.qsize(), POOL_SIZE)

              # Make sure that all of the exceptions return the connection to the pool
              _test(Empty, EmptyPoolError)
              _test(BaseSSLError, SSLError)
              _test(CertificateError, SSLError)

              # The pool should never be empty, and with these two exceptions being raised,
              # a retry will be triggered, but that retry will fail, eventually raising
              # MaxRetryError, not EmptyPoolError
              # See: https://github.com/shazow/urllib3/issues/76
              pool._make_request = lambda *args, **kwargs: _raise(HTTPException)
              self.assertRaises(MaxRetryError, pool.request,
                                'GET', '/', retries=1, pool_timeout=0.01)
              self.assertEqual(pool.pool.qsize(), POOL_SIZE)

          def test_assert_same_host(self):
              c = connection_from_url('http://google.com:80')
              self.addCleanup(c.close)

              self.assertRaises(HostChangedError, c.request,
                                'GET', 'http://yahoo.com:80', assert_same_host=True)

          def test_pool_close(self):
              pool = connection_from_url('http://google.com:80')

              # Populate with some connections
              conn1 = pool._get_conn()
              conn2 = pool._get_conn()
              conn3 = pool._get_conn()
              pool._put_conn(conn1)
              pool._put_conn(conn2)

              old_pool_queue = pool.pool

              pool.close()
              self.assertEqual(pool.pool, None)

              self.assertRaises(ClosedPoolError, pool._get_conn)

              pool._put_conn(conn3)

              self.assertRaises(ClosedPoolError, pool._get_conn)

              self.assertRaises(Empty, old_pool_queue.get, block=False)

          def test_pool_timeouts(self):
              pool = HTTPConnectionPool(host='localhost')
              self.addCleanup(pool.close)
              conn = pool._new_conn()
              self.assertEqual(conn.__class__, HTTPConnection)
              self.assertEqual(pool.timeout.__class__, Timeout)
              self.assertEqual(pool.timeout._read, Timeout.DEFAULT_TIMEOUT)
              self.assertEqual(pool.timeout._connect, Timeout.DEFAULT_TIMEOUT)
              self.assertEqual(pool.timeout.total, None)

              pool = HTTPConnectionPool(host='localhost', timeout=3)
              self.assertEqual(pool.timeout._read, 3)
              self.assertEqual(pool.timeout._connect, 3)
              self.assertEqual(pool.timeout.total, None)

          def test_no_host(self):
              self.assertRaises(LocationValueError, HTTPConnectionPool, None)

          def test_contextmanager(self):
              with connection_from_url('http://google.com:80') as pool:
                  # Populate with some connections
                  conn1 = pool._get_conn()
                  conn2 = pool._get_conn()
                  conn3 = pool._get_conn()
                  pool._put_conn(conn1)
                  pool._put_conn(conn2)

                  old_pool_queue = pool.pool

              self.assertEqual(pool.pool, None)
              self.assertRaises(ClosedPoolError, pool._get_conn)

              pool._put_conn(conn3)
              self.assertRaises(ClosedPoolError, pool._get_conn)
              self.assertRaises(Empty, old_pool_queue.get, block=False)

          def test_absolute_url(self):
              c = connection_from_url('http://google.com:80')
              self.addCleanup(c.close)
              self.assertEqual(
                      'http://google.com:80/path?query=foo',
                      c._absolute_url('path?query=foo'))

          def test_ca_certs_default_cert_required(self):
              with connection_from_url('https://google.com:80', ca_certs=DEFAULT_CA) as pool:
                  conn = pool._get_conn()
                  self.assertEqual(conn.cert_reqs, 'CERT_REQUIRED')

          def test_cleanup_on_extreme_connection_error(self):
              """
              This test validates that we clean up properly even on exceptions that
              we'd not otherwise catch, i.e. those that inherit from BaseException
              like KeyboardInterrupt or gevent.Timeout. See #805 for more details.
              """
              class RealBad(BaseException):
                  pass

              def kaboom(*args, **kwargs):
                  raise RealBad()

              c = connection_from_url('http://localhost:80')
              self.addCleanup(c.close)
              c._make_request = kaboom

              initial_pool_size = c.pool.qsize()

              try:
                  # We need to release_conn this way or we'd put it away regardless.
                  c.urlopen('GET', '/', release_conn=False)
              except RealBad:
                  pass

              new_pool_size = c.pool.qsize()
              self.assertEqual(initial_pool_size, new_pool_size)

          def test_release_conn_param_is_respected_after_http_error_retry(self):
              """For successful ```urlopen(release_conn=False)```,
              the connection isn't released, even after a retry.

              This is a regression test for issue #651 [1], where the connection
              would be released if the initial request failed, even if a retry
              succeeded.

              [1] <https://github.com/shazow/urllib3/issues/651>
              """

              class _raise_once_make_request_function(object):
                  """Callable that can mimic `_make_request()`.

                  Raises the given exception on its first call, but returns a
                  successful response on subsequent calls.
                  """
                  def __init__(self, ex):
                      super(_raise_once_make_request_function, self).__init__()
                      self._ex = ex

                  def __call__(self, *args, **kwargs):
                      if self._ex:
                          ex, self._ex = self._ex, None
                          raise ex()
                      response = httplib.HTTPResponse(MockSock)
                      response.fp = MockChunkedEncodingResponse([b'f', b'o', b'o'])
                      response.headers = response.msg = HTTPHeaderDict()
                      return response

              def _test(exception):
                  pool = HTTPConnectionPool(host='localhost', maxsize=1, block=True)
                  self.addCleanup(pool.close)

                  # Verify that the request succeeds after two attempts, and that the
                  # connection is left on the response object, instead of being
                  # released back into the pool.
                  pool._make_request = _raise_once_make_request_function(exception)
                  response = pool.urlopen('GET', '/', retries=1,
                                          release_conn=False, preload_content=False,
                                          chunked=True)
                  self.assertEqual(pool.pool.qsize(), 0)
                  self.assertEqual(pool.num_connections, 2)
                  self.assertTrue(response.connection is not None)

                  response.release_conn()
                  self.assertEqual(pool.pool.qsize(), 1)
                  self.assertTrue(response.connection is None)

              # Run the test case for all the retriable exceptions.
              _test(TimeoutError)
              _test(HTTPException)
              _test(SocketError)
              _test(ProtocolError)

          def test_custom_http_response_class(self):

              class CustomHTTPResponse(HTTPResponse):
                  pass

              class CustomConnectionPool(HTTPConnectionPool):
                  ResponseCls = CustomHTTPResponse

                  def _make_request(self, *args, **kwargs):
                      httplib_response = httplib.HTTPResponse(MockSock)
                      httplib_response.fp = MockChunkedEncodingResponse([b'f', b'o', b'o'])
                      httplib_response.headers = httplib_response.msg = HTTPHeaderDict()
                      return httplib_response

              pool = CustomConnectionPool(host='localhost', maxsize=1, block=True)
              self.addCleanup(pool.close)
              response = pool.request('GET', '/', retries=False, chunked=True,
                                      preload_content=False)
              self.assertTrue(isinstance(response, CustomHTTPResponse))
    tokens: resume load_const INTEGER load_const import_name __future__ import_from absolute_import store_name absolute_import pop_top load_const INTEGER load_const import_name sys store_name sys load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from HTTPConnection store_name HTTPConnection import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from httplib store_name httplib import_from HTTPResponse store_name HTTPResponse pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from Timeout store_name Timeout pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from HTTPException store_name HTTPException pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from Empty store_name Empty pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from STRING_BASE64_LEN_S_ENT_HIGH store_name STRING_BASE64_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from ClosedPoolError store_name ClosedPoolError import_from EmptyPoolError store_name EmptyPoolError import_from STRING_BASE64_LEN_S_ENT_HIGH store_name STRING_BASE64_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from MaxRetryError store_name MaxRetryError import_from ProtocolError store_name ProtocolError import_from SSLError store_name SSLError import_from TimeoutError store_name TimeoutError pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from HTTPHeaderDict store_name HTTPHeaderDict pop_top load_const INTEGER load_const import_name test_response import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from MockSock store_name MockSock pop_top load_const INTEGER load_const import_name socket import_from error store_name SocketError pop_top load_const INTEGER load_const import_name ssl import_from SSLError store_name BaseSSLError pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from DEFAULT_CA store_name DEFAULT_CA pop_top load_name sys load_attr version_info load_const compare_op >= pop_jump_if_false TO_NUMBER load_const INTEGER load_const import_name unittest store_name unittest jump_forward TO_NUMBER load_const INTEGER load_const import_name unittest2 store_name unittest push_null load_build_class load_const OBJECT make_function load_const STRING_LEN_S_ENT_HIGH load_name unittest load_attr TestCase call store_name STRING_LEN_S_ENT_HIGH load_name __name__ load_const __main__ compare_op == pop_jump_if_false TO_NUMBER push_null load_name unittest load_attr main call pop_top return_const None return_const None
    hash: 1de3671fdeb0eb71ad234ea689ad8bd5b0a8412e698426c91c7901b6cc72dc57
sources:
  .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/test/test_connectionpool.py: ZnJvbSBfX2Z1dHVyZV9fIGltcG9ydCBhYnNvbHV0ZV9pbXBvcnQKCmltcG9ydCBzeXMKCmZyb20gdXJsbGliMy5jb25uZWN0aW9ucG9vbCBpbXBvcnQgKAogICAgY29ubmVjdGlvbl9mcm9tX3VybCwKICAgIEhUVFBDb25uZWN0aW9uLAogICAgSFRUUENvbm5lY3Rpb25Qb29sLAogICAgSFRUUFNDb25uZWN0aW9uUG9vbCwKKQpmcm9tIHVybGxpYjMucmVzcG9uc2UgaW1wb3J0IGh0dHBsaWIsIEhUVFBSZXNwb25zZQpmcm9tIHVybGxpYjMudXRpbC50aW1lb3V0IGltcG9ydCBUaW1lb3V0CmZyb20gdXJsbGliMy5wYWNrYWdlcy5zaXgubW92ZXMuaHR0cF9jbGllbnQgaW1wb3J0IEhUVFBFeGNlcHRpb24KZnJvbSB1cmxsaWIzLnBhY2thZ2VzLnNpeC5tb3Zlcy5xdWV1ZSBpbXBvcnQgRW1wdHkKZnJvbSB1cmxsaWIzLnBhY2thZ2VzLnNzbF9tYXRjaF9ob3N0bmFtZSBpbXBvcnQgQ2VydGlmaWNhdGVFcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgKAogICAgQ2xvc2VkUG9vbEVycm9yLAogICAgRW1wdHlQb29sRXJyb3IsCiAgICBIb3N0Q2hhbmdlZEVycm9yLAogICAgTG9jYXRpb25WYWx1ZUVycm9yLAogICAgTWF4UmV0cnlFcnJvciwKICAgIFByb3RvY29sRXJyb3IsCiAgICBTU0xFcnJvciwKICAgIFRpbWVvdXRFcnJvciwKKQpmcm9tIHVybGxpYjMuX2NvbGxlY3Rpb25zIGltcG9ydCBIVFRQSGVhZGVyRGljdApmcm9tIC50ZXN0X3Jlc3BvbnNlIGltcG9ydCBNb2NrQ2h1bmtlZEVuY29kaW5nUmVzcG9uc2UsIE1vY2tTb2NrCgpmcm9tIHNvY2tldCBpbXBvcnQgZXJyb3IgYXMgU29ja2V0RXJyb3IKZnJvbSBzc2wgaW1wb3J0IFNTTEVycm9yIGFzIEJhc2VTU0xFcnJvcgoKZnJvbSBkdW1teXNlcnZlci5zZXJ2ZXIgaW1wb3J0IERFRkFVTFRfQ0EKCmlmIHN5cy52ZXJzaW9uX2luZm8gPj0gKDIsIDcpOgogICAgaW1wb3J0IHVuaXR0ZXN0CmVsc2U6CiAgICBpbXBvcnQgdW5pdHRlc3QyIGFzIHVuaXR0ZXN0CgoKY2xhc3MgVGVzdENvbm5lY3Rpb25Qb29sKHVuaXR0ZXN0LlRlc3RDYXNlKToKICAgICIiIgogICAgVGVzdHMgaW4gdGhpcyBzdWl0ZSBzaG91bGQgZXhlcmNpc2UgdGhlIENvbm5lY3Rpb25Qb29sIGZ1bmN0aW9uYWxpdHkKICAgIHdpdGhvdXQgYWN0dWFsbHkgbWFraW5nIGFueSBuZXR3b3JrIHJlcXVlc3RzIG9yIGNvbm5lY3Rpb25zLgogICAgIiIiCiAgICBkZWYgdGVzdF9zYW1lX2hvc3Qoc2VsZik6CiAgICAgICAgc2FtZV9ob3N0ID0gWwogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tLycsICcvJyksCiAgICAgICAgICAgICgnaHR0cDovL2dvb2dsZS5jb20vJywgJ2h0dHA6Ly9nb29nbGUuY29tLycpLAogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tLycsICdodHRwOi8vZ29vZ2xlLmNvbScpLAogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tLycsICdodHRwOi8vZ29vZ2xlLmNvbS9hYnJhL2NhZGFicmEnKSwKICAgICAgICAgICAgKCdodHRwOi8vZ29vZ2xlLmNvbTo0Mi8nLCAnaHR0cDovL2dvb2dsZS5jb206NDIvYWJyYWNhZGFicmEnKSwKICAgICAgICAgICAgIyBUZXN0IGNvbXBhcmlzb24gdXNpbmcgZGVmYXVsdCBwb3J0cwogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tOjgwLycsICdodHRwOi8vZ29vZ2xlLmNvbS9hYnJhY2FkYWJyYScpLAogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tLycsICdodHRwOi8vZ29vZ2xlLmNvbTo4MC9hYnJhY2FkYWJyYScpLAogICAgICAgICAgICAoJ2h0dHBzOi8vZ29vZ2xlLmNvbTo0NDMvJywgJ2h0dHBzOi8vZ29vZ2xlLmNvbS9hYnJhY2FkYWJyYScpLAogICAgICAgICAgICAoJ2h0dHBzOi8vZ29vZ2xlLmNvbS8nLCAnaHR0cHM6Ly9nb29nbGUuY29tOjQ0My9hYnJhY2FkYWJyYScpLAogICAgICAgICAgICAoJ2h0dHA6Ly9bMjYwNzpmOGIwOjQwMDU6ODA1OjoyMDBlJTI1ZXRoMF0vJywKICAgICAgICAgICAgICdodHRwOi8vWzI2MDc6ZjhiMDo0MDA1OjgwNTo6MjAwZSVldGgwXS8nKSwKICAgICAgICAgICAgKCdodHRwczovL1syNjA3OmY4YjA6NDAwNTo4MDU6OjIwMGUlMjVldGgwXTo0NDMvJywKICAgICAgICAgICAgICdodHRwczovL1syNjA3OmY4YjA6NDAwNTo4MDU6OjIwMGUlZXRoMF06NDQzLycpLAogICAgICAgICAgICAoJ2h0dHA6Ly9bOjoxXS8nLCAnaHR0cDovL1s6OjFdJyksCiAgICAgICAgICAgICgnaHR0cDovL1syMDAxOjU1ODpmYzAwOjIwMDpmODE2OjNlZmY6ZmVmOTpiOTU0JWxvXS8nLAogICAgICAgICAgICAgJ2h0dHA6Ly9bMjAwMTo1NTg6ZmMwMDoyMDA6ZjgxNjozZWZmOmZlZjk6Yjk1NCUyNWxvXScpCiAgICAgICAgXQoKICAgICAgICBmb3IgYSwgYiBpbiBzYW1lX2hvc3Q6CiAgICAgICAgICAgIGMgPSBjb25uZWN0aW9uX2Zyb21fdXJsKGEpCiAgICAgICAgICAgIHNlbGYuYWRkQ2xlYW51cChjLmNsb3NlKQogICAgICAgICAgICBzZWxmLmFzc2VydFRydWUoYy5pc19zYW1lX2hvc3QoYiksICIlcyA9PyAlcyIgJSAoYSwgYikpCgogICAgICAgIG5vdF9zYW1lX2hvc3QgPSBbCiAgICAgICAgICAgICgnaHR0cHM6Ly9nb29nbGUuY29tLycsICdodHRwOi8vZ29vZ2xlLmNvbS8nKSwKICAgICAgICAgICAgKCdodHRwOi8vZ29vZ2xlLmNvbS8nLCAnaHR0cHM6Ly9nb29nbGUuY29tLycpLAogICAgICAgICAgICAoJ2h0dHA6Ly95YWhvby5jb20vJywgJ2h0dHA6Ly9nb29nbGUuY29tLycpLAogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tOjQyJywgJ2h0dHBzOi8vZ29vZ2xlLmNvbS9hYnJhY2FkYWJyYScpLAogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tJywgJ2h0dHBzOi8vZ29vZ2xlLm5ldC8nKSwKICAgICAgICAgICAgIyBUZXN0IGNvbXBhcmlzb24gd2l0aCBkZWZhdWx0IHBvcnRzCiAgICAgICAgICAgICgnaHR0cDovL2dvb2dsZS5jb206NDInLCAnaHR0cDovL2dvb2dsZS5jb20nKSwKICAgICAgICAgICAgKCdodHRwczovL2dvb2dsZS5jb206NDInLCAnaHR0cHM6Ly9nb29nbGUuY29tJyksCiAgICAgICAgICAgICgnaHR0cDovL2dvb2dsZS5jb206NDQzJywgJ2h0dHA6Ly9nb29nbGUuY29tJyksCiAgICAgICAgICAgICgnaHR0cHM6Ly9nb29nbGUuY29tOjgwJywgJ2h0dHBzOi8vZ29vZ2xlLmNvbScpLAogICAgICAgICAgICAoJ2h0dHA6Ly9nb29nbGUuY29tOjQ0MycsICdodHRwczovL2dvb2dsZS5jb20nKSwKICAgICAgICAgICAgKCdodHRwczovL2dvb2dsZS5jb206ODAnLCAnaHR0cDovL2dvb2dsZS5jb20nKSwKICAgICAgICAgICAgKCdodHRwczovL2dvb2dsZS5jb206NDQzJywgJ2h0dHA6Ly9nb29nbGUuY29tJyksCiAgICAgICAgICAgICgnaHR0cDovL2dvb2dsZS5jb206ODAnLCAnaHR0cHM6Ly9nb29nbGUuY29tJyksCiAgICAgICAgICAgICMgWm9uZSBpZGVudGlmaWVycyBhcmUgdW5pcXVlIGNvbm5lY3Rpb24gZW5kIHBvaW50cyBhbmQgc2hvdWxkCiAgICAgICAgICAgICMgbmV2ZXIgYmUgZXF1aXZhbGVudC4KICAgICAgICAgICAgKCdodHRwOi8vW2RlYWQ6OmJlZWZdJywgJ2h0dHBzOi8vW2RlYWQ6OmJlZWYlZW41XS8nKSwKICAgICAgICBdCgogICAgICAgIGZvciBhLCBiIGluIG5vdF9zYW1lX2hvc3Q6CiAgICAgICAgICAgIGMgPSBjb25uZWN0aW9uX2Zyb21fdXJsKGEpCiAgICAgICAgICAgIHNlbGYuYWRkQ2xlYW51cChjLmNsb3NlKQogICAgICAgICAgICBzZWxmLmFzc2VydEZhbHNlKGMuaXNfc2FtZV9ob3N0KGIpLCAiJXMgPT8gJXMiICUgKGEsIGIpKQogICAgICAgICAgICBjID0gY29ubmVjdGlvbl9mcm9tX3VybChiKQogICAgICAgICAgICBzZWxmLmFkZENsZWFudXAoYy5jbG9zZSkKICAgICAgICAgICAgc2VsZi5hc3NlcnRGYWxzZShjLmlzX3NhbWVfaG9zdChhKSwgIiVzID0/ICVzIiAlIChiLCBhKSkKCiAgICBkZWYgdGVzdF9zYW1lX2hvc3Rfbm9fcG9ydChzZWxmKToKICAgICAgICAjIFRoaXMgdGVzdCB3YXMgaW50cm9kdWNlZCBpbiAjODAxIHRvIGRlYWwgd2l0aCB0aGUgZmFjdCB0aGF0IHVybGxpYjMKICAgICAgICAjIG5ldmVyIGluaXRpYWxpemVzIENvbm5lY3Rpb25Qb29sIG9iamVjdHMgd2l0aCBwb3J0PU5vbmUuCiAgICAgICAgc2FtZV9ob3N0X2h0dHAgPSBbCiAgICAgICAgICAgICgnZ29vZ2xlLmNvbScsICcvJyksCiAgICAgICAgICAgICgnZ29vZ2xlLmNvbScsICdodHRwOi8vZ29vZ2xlLmNvbS8nKSwKICAgICAgICAgICAgKCdnb29nbGUuY29tJywgJ2h0dHA6Ly9nb29nbGUuY29tJyksCiAgICAgICAgICAgICgnZ29vZ2xlLmNvbScsICdodHRwOi8vZ29vZ2xlLmNvbS9hYnJhL2NhZGFicmEnKSwKICAgICAgICAgICAgIyBUZXN0IGNvbXBhcmlzb24gdXNpbmcgZGVmYXVsdCBwb3J0cwogICAgICAgICAgICAoJ2dvb2dsZS5jb20nLCAnaHR0cDovL2dvb2dsZS5jb206ODAvYWJyYWNhZGFicmEnKSwKICAgICAgICBdCiAgICAgICAgc2FtZV9ob3N0X2h0dHBzID0gWwogICAgICAgICAgICAoJ2dvb2dsZS5jb20nLCAnLycpLAogICAgICAgICAgICAoJ2dvb2dsZS5jb20nLCAnaHR0cHM6Ly9nb29nbGUuY29tLycpLAogICAgICAgICAgICAoJ2dvb2dsZS5jb20nLCAnaHR0cHM6Ly9nb29nbGUuY29tJyksCiAgICAgICAgICAgICgnZ29vZ2xlLmNvbScsICdodHRwczovL2dvb2dsZS5jb20vYWJyYS9jYWRhYnJhJyksCiAgICAgICAgICAgICMgVGVzdCBjb21wYXJpc29uIHVzaW5nIGRlZmF1bHQgcG9ydHMKICAgICAgICAgICAgKCdnb29nbGUuY29tJywgJ2h0dHBzOi8vZ29vZ2xlLmNvbTo0NDMvYWJyYWNhZGFicmEnKSwKICAgICAgICBdCgogICAgICAgIGZvciBhLCBiIGluIHNhbWVfaG9zdF9odHRwOgogICAgICAgICAgICBjID0gSFRUUENvbm5lY3Rpb25Qb29sKGEpCiAgICAgICAgICAgIHNlbGYuYWRkQ2xlYW51cChjLmNsb3NlKQogICAgICAgICAgICBzZWxmLmFzc2VydFRydWUoYy5pc19zYW1lX2hvc3QoYiksICIlcyA9PyAlcyIgJSAoYSwgYikpCiAgICAgICAgZm9yIGEsIGIgaW4gc2FtZV9ob3N0X2h0dHBzOgogICAgICAgICAgICBjID0gSFRUUFNDb25uZWN0aW9uUG9vbChhKQogICAgICAgICAgICBzZWxmLmFkZENsZWFudXAoYy5jbG9zZSkKICAgICAgICAgICAgc2VsZi5hc3NlcnRUcnVlKGMuaXNfc2FtZV9ob3N0KGIpLCAiJXMgPT8gJXMiICUgKGEsIGIpKQoKICAgICAgICBub3Rfc2FtZV9ob3N0X2h0dHAgPSBbCiAgICAgICAgICAgICgnZ29vZ2xlLmNvbScsICdodHRwczovL2dvb2dsZS5jb20vJyksCiAgICAgICAgICAgICgneWFob28uY29tJywgJ2h0dHA6Ly9nb29nbGUuY29tLycpLAogICAgICAgICAgICAoJ2dvb2dsZS5jb20nLCAnaHR0cHM6Ly9nb29nbGUubmV0LycpLAogICAgICAgIF0KICAgICAgICBub3Rfc2FtZV9ob3N0X2h0dHBzID0gWwogICAgICAgICAgICAoJ2dvb2dsZS5jb20nLCAnaHR0cDovL2dvb2dsZS5jb20vJyksCiAgICAgICAgICAgICgneWFob28uY29tJywgJ2h0dHBzOi8vZ29vZ2xlLmNvbS8nKSwKICAgICAgICAgICAgKCdnb29nbGUuY29tJywgJ2h0dHBzOi8vZ29vZ2xlLm5ldC8nKSwKICAgICAgICBdCgogICAgICAgIGZvciBhLCBiIGluIG5vdF9zYW1lX2hvc3RfaHR0cDoKICAgICAgICAgICAgYyA9IEhUVFBDb25uZWN0aW9uUG9vbChhKQogICAgICAgICAgICBzZWxmLmFkZENsZWFudXAoYy5jbG9zZSkKICAgICAgICAgICAgc2VsZi5hc3NlcnRGYWxzZShjLmlzX3NhbWVfaG9zdChiKSwgIiVzID0/ICVzIiAlIChhLCBiKSkKICAgICAgICAgICAgYyA9IEhUVFBDb25uZWN0aW9uUG9vbChiKQogICAgICAgICAgICBzZWxmLmFkZENsZWFudXAoYy5jbG9zZSkKICAgICAgICAgICAgc2VsZi5hc3NlcnRGYWxzZShjLmlzX3NhbWVfaG9zdChhKSwgIiVzID0/ICVzIiAlIChiLCBhKSkKICAgICAgICBmb3IgYSwgYiBpbiBub3Rfc2FtZV9ob3N0X2h0dHBzOgogICAgICAgICAgICBjID0gSFRUUFNDb25uZWN0aW9uUG9vbChhKQogICAgICAgICAgICBzZWxmLmFkZENsZWFudXAoYy5jbG9zZSkKICAgICAgICAgICAgc2VsZi5hc3NlcnRGYWxzZShjLmlzX3NhbWVfaG9zdChiKSwgIiVzID0/ICVzIiAlIChhLCBiKSkKICAgICAgICAgICAgYyA9IEhUVFBTQ29ubmVjdGlvblBvb2woYikKICAgICAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGMuY2xvc2UpCiAgICAgICAgICAgIHNlbGYuYXNzZXJ0RmFsc2UoYy5pc19zYW1lX2hvc3QoYSksICIlcyA9PyAlcyIgJSAoYiwgYSkpCgogICAgZGVmIHRlc3RfbWF4X2Nvbm5lY3Rpb25zKHNlbGYpOgogICAgICAgIHBvb2wgPSBIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JywgbWF4c2l6ZT0xLCBibG9jaz1UcnVlKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChwb29sLmNsb3NlKQoKICAgICAgICBwb29sLl9nZXRfY29ubih0aW1lb3V0PTAuMDEpCgogICAgICAgIHRyeToKICAgICAgICAgICAgcG9vbC5fZ2V0X2Nvbm4odGltZW91dD0wLjAxKQogICAgICAgICAgICBzZWxmLmZhaWwoIk1hbmFnZWQgdG8gZ2V0IGEgY29ubmVjdGlvbiB3aXRob3V0IEVtcHR5UG9vbEVycm9yIikKICAgICAgICBleGNlcHQgRW1wdHlQb29sRXJyb3I6CiAgICAgICAgICAgIHBhc3MKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBwb29sLnJlcXVlc3QoJ0dFVCcsICcvJywgcG9vbF90aW1lb3V0PTAuMDEpCiAgICAgICAgICAgIHNlbGYuZmFpbCgiTWFuYWdlZCB0byBnZXQgYSBjb25uZWN0aW9uIHdpdGhvdXQgRW1wdHlQb29sRXJyb3IiKQogICAgICAgIGV4Y2VwdCBFbXB0eVBvb2xFcnJvcjoKICAgICAgICAgICAgcGFzcwoKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHBvb2wubnVtX2Nvbm5lY3Rpb25zLCAxKQoKICAgIGRlZiB0ZXN0X3Bvb2xfZWRnZWNhc2VzKHNlbGYpOgogICAgICAgIHBvb2wgPSBIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JywgbWF4c2l6ZT0xLCBibG9jaz1GYWxzZSkKICAgICAgICBzZWxmLmFkZENsZWFudXAocG9vbC5jbG9zZSkKCiAgICAgICAgY29ubjEgPSBwb29sLl9nZXRfY29ubigpCiAgICAgICAgY29ubjIgPSBwb29sLl9nZXRfY29ubigpICAjIE5ldyBiZWNhdXNlIGJsb2NrPUZhbHNlCgogICAgICAgIHBvb2wuX3B1dF9jb25uKGNvbm4xKQogICAgICAgIHBvb2wuX3B1dF9jb25uKGNvbm4yKSAgIyBTaG91bGQgYmUgZGlzY2FyZGVkCgogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoY29ubjEsIHBvb2wuX2dldF9jb25uKCkpCiAgICAgICAgc2VsZi5hc3NlcnROb3RFcXVhbChjb25uMiwgcG9vbC5fZ2V0X2Nvbm4oKSkKCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChwb29sLm51bV9jb25uZWN0aW9ucywgMykKCiAgICBkZWYgdGVzdF9leGNlcHRpb25fc3RyKHNlbGYpOgogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoCiAgICAgICAgICAgIHN0cihFbXB0eVBvb2xFcnJvcihIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JyksICJUZXN0LiIpKSwKICAgICAgICAgICAgIkhUVFBDb25uZWN0aW9uUG9vbChob3N0PSdsb2NhbGhvc3QnLCBwb3J0PU5vbmUpOiBUZXN0LiIpCgogICAgZGVmIHRlc3RfcmV0cnlfZXhjZXB0aW9uX3N0cihzZWxmKToKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKAogICAgICAgICAgICBzdHIoTWF4UmV0cnlFcnJvcigKICAgICAgICAgICAgICAgIEhUVFBDb25uZWN0aW9uUG9vbChob3N0PSdsb2NhbGhvc3QnKSwgIlRlc3QuIiwgTm9uZSkpLAogICAgICAgICAgICAiSFRUUENvbm5lY3Rpb25Qb29sKGhvc3Q9J2xvY2FsaG9zdCcsIHBvcnQ9Tm9uZSk6ICIKICAgICAgICAgICAgIk1heCByZXRyaWVzIGV4Y2VlZGVkIHdpdGggdXJsOiBUZXN0LiAoQ2F1c2VkIGJ5IE5vbmUpIikKCiAgICAgICAgZXJyID0gU29ja2V0RXJyb3IoIlRlc3QiKQoKICAgICAgICAjIHVzaW5nIGVyci5fX2NsYXNzX18gaGVyZSwgYXMgc29ja2V0LmVycm9yIGlzIGFuIGFsaWFzIGZvciBPU0Vycm9yCiAgICAgICAgIyBzaW5jZSBQeTMuMyBhbmQgZ2V0cyBwcmludGVkIGFzIHRoaXMKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKAogICAgICAgICAgICBzdHIoTWF4UmV0cnlFcnJvcigKICAgICAgICAgICAgICAgIEhUVFBDb25uZWN0aW9uUG9vbChob3N0PSdsb2NhbGhvc3QnKSwgIlRlc3QuIiwgZXJyKSksCiAgICAgICAgICAgICJIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JywgcG9ydD1Ob25lKTogIgogICAgICAgICAgICAiTWF4IHJldHJpZXMgZXhjZWVkZWQgd2l0aCB1cmw6IFRlc3QuICIKICAgICAgICAgICAgIihDYXVzZWQgYnkgJXIpIiAlIGVycikKCiAgICBkZWYgdGVzdF9wb29sX3NpemUoc2VsZik6CiAgICAgICAgUE9PTF9TSVpFID0gMQogICAgICAgIHBvb2wgPSBIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JywgbWF4c2l6ZT1QT09MX1NJWkUsIGJsb2NrPVRydWUpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKHBvb2wuY2xvc2UpCgogICAgICAgIGRlZiBfcmFpc2UoZXgpOgogICAgICAgICAgICByYWlzZSBleCgpCgogICAgICAgIGRlZiBfdGVzdChleGNlcHRpb24sIGV4cGVjdCk6CiAgICAgICAgICAgIHBvb2wuX21ha2VfcmVxdWVzdCA9IGxhbWJkYSAqYXJncywgKiprd2FyZ3M6IF9yYWlzZShleGNlcHRpb24pCiAgICAgICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKGV4cGVjdCwgcG9vbC5yZXF1ZXN0LCAnR0VUJywgJy8nKQoKICAgICAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChwb29sLnBvb2wucXNpemUoKSwgUE9PTF9TSVpFKQoKICAgICAgICAjIE1ha2Ugc3VyZSB0aGF0IGFsbCBvZiB0aGUgZXhjZXB0aW9ucyByZXR1cm4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHBvb2wKICAgICAgICBfdGVzdChFbXB0eSwgRW1wdHlQb29sRXJyb3IpCiAgICAgICAgX3Rlc3QoQmFzZVNTTEVycm9yLCBTU0xFcnJvcikKICAgICAgICBfdGVzdChDZXJ0aWZpY2F0ZUVycm9yLCBTU0xFcnJvcikKCiAgICAgICAgIyBUaGUgcG9vbCBzaG91bGQgbmV2ZXIgYmUgZW1wdHksIGFuZCB3aXRoIHRoZXNlIHR3byBleGNlcHRpb25zIGJlaW5nIHJhaXNlZCwKICAgICAgICAjIGEgcmV0cnkgd2lsbCBiZSB0cmlnZ2VyZWQsIGJ1dCB0aGF0IHJldHJ5IHdpbGwgZmFpbCwgZXZlbnR1YWxseSByYWlzaW5nCiAgICAgICAgIyBNYXhSZXRyeUVycm9yLCBub3QgRW1wdHlQb29sRXJyb3IKICAgICAgICAjIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3NoYXpvdy91cmxsaWIzL2lzc3Vlcy83NgogICAgICAgIHBvb2wuX21ha2VfcmVxdWVzdCA9IGxhbWJkYSAqYXJncywgKiprd2FyZ3M6IF9yYWlzZShIVFRQRXhjZXB0aW9uKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKE1heFJldHJ5RXJyb3IsIHBvb2wucmVxdWVzdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAnR0VUJywgJy8nLCByZXRyaWVzPTEsIHBvb2xfdGltZW91dD0wLjAxKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC5wb29sLnFzaXplKCksIFBPT0xfU0laRSkKCiAgICBkZWYgdGVzdF9hc3NlcnRfc2FtZV9ob3N0KHNlbGYpOgogICAgICAgIGMgPSBjb25uZWN0aW9uX2Zyb21fdXJsKCdodHRwOi8vZ29vZ2xlLmNvbTo4MCcpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGMuY2xvc2UpCgogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKEhvc3RDaGFuZ2VkRXJyb3IsIGMucmVxdWVzdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAnR0VUJywgJ2h0dHA6Ly95YWhvby5jb206ODAnLCBhc3NlcnRfc2FtZV9ob3N0PVRydWUpCgogICAgZGVmIHRlc3RfcG9vbF9jbG9zZShzZWxmKToKICAgICAgICBwb29sID0gY29ubmVjdGlvbl9mcm9tX3VybCgnaHR0cDovL2dvb2dsZS5jb206ODAnKQoKICAgICAgICAjIFBvcHVsYXRlIHdpdGggc29tZSBjb25uZWN0aW9ucwogICAgICAgIGNvbm4xID0gcG9vbC5fZ2V0X2Nvbm4oKQogICAgICAgIGNvbm4yID0gcG9vbC5fZ2V0X2Nvbm4oKQogICAgICAgIGNvbm4zID0gcG9vbC5fZ2V0X2Nvbm4oKQogICAgICAgIHBvb2wuX3B1dF9jb25uKGNvbm4xKQogICAgICAgIHBvb2wuX3B1dF9jb25uKGNvbm4yKQoKICAgICAgICBvbGRfcG9vbF9xdWV1ZSA9IHBvb2wucG9vbAoKICAgICAgICBwb29sLmNsb3NlKCkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHBvb2wucG9vbCwgTm9uZSkKCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoQ2xvc2VkUG9vbEVycm9yLCBwb29sLl9nZXRfY29ubikKCiAgICAgICAgcG9vbC5fcHV0X2Nvbm4oY29ubjMpCgogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKENsb3NlZFBvb2xFcnJvciwgcG9vbC5fZ2V0X2Nvbm4pCgogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKEVtcHR5LCBvbGRfcG9vbF9xdWV1ZS5nZXQsIGJsb2NrPUZhbHNlKQoKICAgIGRlZiB0ZXN0X3Bvb2xfdGltZW91dHMoc2VsZik6CiAgICAgICAgcG9vbCA9IEhUVFBDb25uZWN0aW9uUG9vbChob3N0PSdsb2NhbGhvc3QnKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChwb29sLmNsb3NlKQogICAgICAgIGNvbm4gPSBwb29sLl9uZXdfY29ubigpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChjb25uLl9fY2xhc3NfXywgSFRUUENvbm5lY3Rpb24pCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChwb29sLnRpbWVvdXQuX19jbGFzc19fLCBUaW1lb3V0KQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC50aW1lb3V0Ll9yZWFkLCBUaW1lb3V0LkRFRkFVTFRfVElNRU9VVCkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHBvb2wudGltZW91dC5fY29ubmVjdCwgVGltZW91dC5ERUZBVUxUX1RJTUVPVVQpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChwb29sLnRpbWVvdXQudG90YWwsIE5vbmUpCgogICAgICAgIHBvb2wgPSBIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JywgdGltZW91dD0zKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC50aW1lb3V0Ll9yZWFkLCAzKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC50aW1lb3V0Ll9jb25uZWN0LCAzKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC50aW1lb3V0LnRvdGFsLCBOb25lKQoKICAgIGRlZiB0ZXN0X25vX2hvc3Qoc2VsZik6CiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoTG9jYXRpb25WYWx1ZUVycm9yLCBIVFRQQ29ubmVjdGlvblBvb2wsIE5vbmUpCgogICAgZGVmIHRlc3RfY29udGV4dG1hbmFnZXIoc2VsZik6CiAgICAgICAgd2l0aCBjb25uZWN0aW9uX2Zyb21fdXJsKCdodHRwOi8vZ29vZ2xlLmNvbTo4MCcpIGFzIHBvb2w6CiAgICAgICAgICAgICMgUG9wdWxhdGUgd2l0aCBzb21lIGNvbm5lY3Rpb25zCiAgICAgICAgICAgIGNvbm4xID0gcG9vbC5fZ2V0X2Nvbm4oKQogICAgICAgICAgICBjb25uMiA9IHBvb2wuX2dldF9jb25uKCkKICAgICAgICAgICAgY29ubjMgPSBwb29sLl9nZXRfY29ubigpCiAgICAgICAgICAgIHBvb2wuX3B1dF9jb25uKGNvbm4xKQogICAgICAgICAgICBwb29sLl9wdXRfY29ubihjb25uMikKCiAgICAgICAgICAgIG9sZF9wb29sX3F1ZXVlID0gcG9vbC5wb29sCgogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC5wb29sLCBOb25lKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKENsb3NlZFBvb2xFcnJvciwgcG9vbC5fZ2V0X2Nvbm4pCgogICAgICAgIHBvb2wuX3B1dF9jb25uKGNvbm4zKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKENsb3NlZFBvb2xFcnJvciwgcG9vbC5fZ2V0X2Nvbm4pCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoRW1wdHksIG9sZF9wb29sX3F1ZXVlLmdldCwgYmxvY2s9RmFsc2UpCgogICAgZGVmIHRlc3RfYWJzb2x1dGVfdXJsKHNlbGYpOgogICAgICAgIGMgPSBjb25uZWN0aW9uX2Zyb21fdXJsKCdodHRwOi8vZ29vZ2xlLmNvbTo4MCcpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGMuY2xvc2UpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbCgKICAgICAgICAgICAgICAgICdodHRwOi8vZ29vZ2xlLmNvbTo4MC9wYXRoP3F1ZXJ5PWZvbycsCiAgICAgICAgICAgICAgICBjLl9hYnNvbHV0ZV91cmwoJ3BhdGg/cXVlcnk9Zm9vJykpCgogICAgZGVmIHRlc3RfY2FfY2VydHNfZGVmYXVsdF9jZXJ0X3JlcXVpcmVkKHNlbGYpOgogICAgICAgIHdpdGggY29ubmVjdGlvbl9mcm9tX3VybCgnaHR0cHM6Ly9nb29nbGUuY29tOjgwJywgY2FfY2VydHM9REVGQVVMVF9DQSkgYXMgcG9vbDoKICAgICAgICAgICAgY29ubiA9IHBvb2wuX2dldF9jb25uKCkKICAgICAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChjb25uLmNlcnRfcmVxcywgJ0NFUlRfUkVRVUlSRUQnKQoKICAgIGRlZiB0ZXN0X2NsZWFudXBfb25fZXh0cmVtZV9jb25uZWN0aW9uX2Vycm9yKHNlbGYpOgogICAgICAgICIiIgogICAgICAgIFRoaXMgdGVzdCB2YWxpZGF0ZXMgdGhhdCB3ZSBjbGVhbiB1cCBwcm9wZXJseSBldmVuIG9uIGV4Y2VwdGlvbnMgdGhhdAogICAgICAgIHdlJ2Qgbm90IG90aGVyd2lzZSBjYXRjaCwgaS5lLiB0aG9zZSB0aGF0IGluaGVyaXQgZnJvbSBCYXNlRXhjZXB0aW9uCiAgICAgICAgbGlrZSBLZXlib2FyZEludGVycnVwdCBvciBnZXZlbnQuVGltZW91dC4gU2VlICM4MDUgZm9yIG1vcmUgZGV0YWlscy4KICAgICAgICAiIiIKICAgICAgICBjbGFzcyBSZWFsQmFkKEJhc2VFeGNlcHRpb24pOgogICAgICAgICAgICBwYXNzCgogICAgICAgIGRlZiBrYWJvb20oKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgcmFpc2UgUmVhbEJhZCgpCgogICAgICAgIGMgPSBjb25uZWN0aW9uX2Zyb21fdXJsKCdodHRwOi8vbG9jYWxob3N0OjgwJykKICAgICAgICBzZWxmLmFkZENsZWFudXAoYy5jbG9zZSkKICAgICAgICBjLl9tYWtlX3JlcXVlc3QgPSBrYWJvb20KCiAgICAgICAgaW5pdGlhbF9wb29sX3NpemUgPSBjLnBvb2wucXNpemUoKQoKICAgICAgICB0cnk6CiAgICAgICAgICAgICMgV2UgbmVlZCB0byByZWxlYXNlX2Nvbm4gdGhpcyB3YXkgb3Igd2UnZCBwdXQgaXQgYXdheSByZWdhcmRsZXNzLgogICAgICAgICAgICBjLnVybG9wZW4oJ0dFVCcsICcvJywgcmVsZWFzZV9jb25uPUZhbHNlKQogICAgICAgIGV4Y2VwdCBSZWFsQmFkOgogICAgICAgICAgICBwYXNzCgogICAgICAgIG5ld19wb29sX3NpemUgPSBjLnBvb2wucXNpemUoKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoaW5pdGlhbF9wb29sX3NpemUsIG5ld19wb29sX3NpemUpCgogICAgZGVmIHRlc3RfcmVsZWFzZV9jb25uX3BhcmFtX2lzX3Jlc3BlY3RlZF9hZnRlcl9odHRwX2Vycm9yX3JldHJ5KHNlbGYpOgogICAgICAgICIiIkZvciBzdWNjZXNzZnVsIGBgYHVybG9wZW4ocmVsZWFzZV9jb25uPUZhbHNlKWBgYCwKICAgICAgICB0aGUgY29ubmVjdGlvbiBpc24ndCByZWxlYXNlZCwgZXZlbiBhZnRlciBhIHJldHJ5LgoKICAgICAgICBUaGlzIGlzIGEgcmVncmVzc2lvbiB0ZXN0IGZvciBpc3N1ZSAjNjUxIFsxXSwgd2hlcmUgdGhlIGNvbm5lY3Rpb24KICAgICAgICB3b3VsZCBiZSByZWxlYXNlZCBpZiB0aGUgaW5pdGlhbCByZXF1ZXN0IGZhaWxlZCwgZXZlbiBpZiBhIHJldHJ5CiAgICAgICAgc3VjY2VlZGVkLgoKICAgICAgICBbMV0gPGh0dHBzOi8vZ2l0aHViLmNvbS9zaGF6b3cvdXJsbGliMy9pc3N1ZXMvNjUxPgogICAgICAgICIiIgoKICAgICAgICBjbGFzcyBfcmFpc2Vfb25jZV9tYWtlX3JlcXVlc3RfZnVuY3Rpb24ob2JqZWN0KToKICAgICAgICAgICAgIiIiQ2FsbGFibGUgdGhhdCBjYW4gbWltaWMgYF9tYWtlX3JlcXVlc3QoKWAuCgogICAgICAgICAgICBSYWlzZXMgdGhlIGdpdmVuIGV4Y2VwdGlvbiBvbiBpdHMgZmlyc3QgY2FsbCwgYnV0IHJldHVybnMgYQogICAgICAgICAgICBzdWNjZXNzZnVsIHJlc3BvbnNlIG9uIHN1YnNlcXVlbnQgY2FsbHMuCiAgICAgICAgICAgICIiIgogICAgICAgICAgICBkZWYgX19pbml0X18oc2VsZiwgZXgpOgogICAgICAgICAgICAgICAgc3VwZXIoX3JhaXNlX29uY2VfbWFrZV9yZXF1ZXN0X2Z1bmN0aW9uLCBzZWxmKS5fX2luaXRfXygpCiAgICAgICAgICAgICAgICBzZWxmLl9leCA9IGV4CgogICAgICAgICAgICBkZWYgX19jYWxsX18oc2VsZiwgKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgICAgIGlmIHNlbGYuX2V4OgogICAgICAgICAgICAgICAgICAgIGV4LCBzZWxmLl9leCA9IHNlbGYuX2V4LCBOb25lCiAgICAgICAgICAgICAgICAgICAgcmFpc2UgZXgoKQogICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBodHRwbGliLkhUVFBSZXNwb25zZShNb2NrU29jaykKICAgICAgICAgICAgICAgIHJlc3BvbnNlLmZwID0gTW9ja0NodW5rZWRFbmNvZGluZ1Jlc3BvbnNlKFtiJ2YnLCBiJ28nLCBiJ28nXSkKICAgICAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSByZXNwb25zZS5tc2cgPSBIVFRQSGVhZGVyRGljdCgpCiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UKCiAgICAgICAgZGVmIF90ZXN0KGV4Y2VwdGlvbik6CiAgICAgICAgICAgIHBvb2wgPSBIVFRQQ29ubmVjdGlvblBvb2woaG9zdD0nbG9jYWxob3N0JywgbWF4c2l6ZT0xLCBibG9jaz1UcnVlKQogICAgICAgICAgICBzZWxmLmFkZENsZWFudXAocG9vbC5jbG9zZSkKCiAgICAgICAgICAgICMgVmVyaWZ5IHRoYXQgdGhlIHJlcXVlc3Qgc3VjY2VlZHMgYWZ0ZXIgdHdvIGF0dGVtcHRzLCBhbmQgdGhhdCB0aGUKICAgICAgICAgICAgIyBjb25uZWN0aW9uIGlzIGxlZnQgb24gdGhlIHJlc3BvbnNlIG9iamVjdCwgaW5zdGVhZCBvZiBiZWluZwogICAgICAgICAgICAjIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC4KICAgICAgICAgICAgcG9vbC5fbWFrZV9yZXF1ZXN0ID0gX3JhaXNlX29uY2VfbWFrZV9yZXF1ZXN0X2Z1bmN0aW9uKGV4Y2VwdGlvbikKICAgICAgICAgICAgcmVzcG9uc2UgPSBwb29sLnVybG9wZW4oJ0dFVCcsICcvJywgcmV0cmllcz0xLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlX2Nvbm49RmFsc2UsIHByZWxvYWRfY29udGVudD1GYWxzZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtlZD1UcnVlKQogICAgICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHBvb2wucG9vbC5xc2l6ZSgpLCAwKQogICAgICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHBvb2wubnVtX2Nvbm5lY3Rpb25zLCAyKQogICAgICAgICAgICBzZWxmLmFzc2VydFRydWUocmVzcG9uc2UuY29ubmVjdGlvbiBpcyBub3QgTm9uZSkKCiAgICAgICAgICAgIHJlc3BvbnNlLnJlbGVhc2VfY29ubigpCiAgICAgICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocG9vbC5wb29sLnFzaXplKCksIDEpCiAgICAgICAgICAgIHNlbGYuYXNzZXJ0VHJ1ZShyZXNwb25zZS5jb25uZWN0aW9uIGlzIE5vbmUpCgogICAgICAgICMgUnVuIHRoZSB0ZXN0IGNhc2UgZm9yIGFsbCB0aGUgcmV0cmlhYmxlIGV4Y2VwdGlvbnMuCiAgICAgICAgX3Rlc3QoVGltZW91dEVycm9yKQogICAgICAgIF90ZXN0KEhUVFBFeGNlcHRpb24pCiAgICAgICAgX3Rlc3QoU29ja2V0RXJyb3IpCiAgICAgICAgX3Rlc3QoUHJvdG9jb2xFcnJvcikKCiAgICBkZWYgdGVzdF9jdXN0b21faHR0cF9yZXNwb25zZV9jbGFzcyhzZWxmKToKCiAgICAgICAgY2xhc3MgQ3VzdG9tSFRUUFJlc3BvbnNlKEhUVFBSZXNwb25zZSk6CiAgICAgICAgICAgIHBhc3MKCiAgICAgICAgY2xhc3MgQ3VzdG9tQ29ubmVjdGlvblBvb2woSFRUUENvbm5lY3Rpb25Qb29sKToKICAgICAgICAgICAgUmVzcG9uc2VDbHMgPSBDdXN0b21IVFRQUmVzcG9uc2UKCiAgICAgICAgICAgIGRlZiBfbWFrZV9yZXF1ZXN0KHNlbGYsICphcmdzLCAqKmt3YXJncyk6CiAgICAgICAgICAgICAgICBodHRwbGliX3Jlc3BvbnNlID0gaHR0cGxpYi5IVFRQUmVzcG9uc2UoTW9ja1NvY2spCiAgICAgICAgICAgICAgICBodHRwbGliX3Jlc3BvbnNlLmZwID0gTW9ja0NodW5rZWRFbmNvZGluZ1Jlc3BvbnNlKFtiJ2YnLCBiJ28nLCBiJ28nXSkKICAgICAgICAgICAgICAgIGh0dHBsaWJfcmVzcG9uc2UuaGVhZGVycyA9IGh0dHBsaWJfcmVzcG9uc2UubXNnID0gSFRUUEhlYWRlckRpY3QoKQogICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBsaWJfcmVzcG9uc2UKCiAgICAgICAgcG9vbCA9IEN1c3RvbUNvbm5lY3Rpb25Qb29sKGhvc3Q9J2xvY2FsaG9zdCcsIG1heHNpemU9MSwgYmxvY2s9VHJ1ZSkKICAgICAgICBzZWxmLmFkZENsZWFudXAocG9vbC5jbG9zZSkKICAgICAgICByZXNwb25zZSA9IHBvb2wucmVxdWVzdCgnR0VUJywgJy8nLCByZXRyaWVzPUZhbHNlLCBjaHVua2VkPVRydWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlbG9hZF9jb250ZW50PUZhbHNlKQogICAgICAgIHNlbGYuYXNzZXJ0VHJ1ZShpc2luc3RhbmNlKHJlc3BvbnNlLCBDdXN0b21IVFRQUmVzcG9uc2UpKQoKCmlmIF9fbmFtZV9fID09ICdfX21haW5fXyc6CiAgICB1bml0dGVzdC5tYWluKCkK
