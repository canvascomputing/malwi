statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/test/with_dummyserver/test_proxy_poolmanager.py
  contents:
  - name: <module>
    score: 0.0
    code: |-
      import json
      import socket
      import unittest

      from nose.tools import timed

      from dummyserver.testcase import HTTPDummyProxyTestCase, IPv6HTTPDummyProxyTestCase
      from dummyserver.server import (
          DEFAULT_CA, DEFAULT_CA_BAD, get_unreachable_address)
      from .. import TARPIT_HOST, requires_network

      from urllib3._collections import HTTPHeaderDict
      from urllib3.poolmanager import proxy_from_url, ProxyManager
      from urllib3.exceptions import (
          MaxRetryError, SSLError, ProxyError, ConnectTimeoutError)
      from urllib3.connectionpool import connection_from_url, VerifiedHTTPSConnection


      class TestHTTPProxyManager(HTTPDummyProxyTestCase):

          def setUp(self):
              self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
              self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                                    self.http_port)
              self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
              self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                      self.https_port)
              self.proxy_url = 'http://%s:%d' % (self.proxy_host, self.proxy_port)

          def test_basic_proxy(self):
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)

              r = http.request('GET', '%s/' % self.http_url)
              self.assertEqual(r.status, 200)

              r = http.request('GET', '%s/' % self.https_url)
              self.assertEqual(r.status, 200)

          def test_nagle_proxy(self):
              """ Test that proxy connections do not have TCP_NODELAY turned on """
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)
              hc2 = http.connection_from_host(self.http_host, self.http_port)
              conn = hc2._get_conn()
              hc2._make_request(conn, 'GET', '/')
              tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
              self.assertEqual(tcp_nodelay_setting, 0,
                               ("Expected TCP_NODELAY for proxies to be set "
                                "to zero, instead was %s" % tcp_nodelay_setting))

          def test_proxy_conn_fail(self):
              host, port = get_unreachable_address()
              http = proxy_from_url('http://%s:%s/' % (host, port), retries=1, timeout=0.05)
              self.addCleanup(http.clear)
              self.assertRaises(MaxRetryError, http.request, 'GET',
                                '%s/' % self.https_url)
              self.assertRaises(MaxRetryError, http.request, 'GET',
                                '%s/' % self.http_url)

              try:
                  http.request('GET', '%s/' % self.http_url)
                  self.fail("Failed to raise retry error.")
              except MaxRetryError as e:
                  self.assertEqual(type(e.reason), ProxyError)

          def test_oldapi(self):
              http = ProxyManager(connection_from_url(self.proxy_url))
              self.addCleanup(http.clear)

              r = http.request('GET', '%s/' % self.http_url)
              self.assertEqual(r.status, 200)

              r = http.request('GET', '%s/' % self.https_url)
              self.assertEqual(r.status, 200)

          def test_proxy_verified(self):
              http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                                    ca_certs=DEFAULT_CA_BAD)
              self.addCleanup(http.clear)
              https_pool = http._new_pool('https', self.https_host,
                                          self.https_port)
              try:
                  https_pool.request('GET', '/')
                  self.fail("Didn't raise SSL error with wrong CA")
              except SSLError as e:
                  self.assertTrue('certificate verify failed' in str(e),
                                  "Expected 'certificate verify failed',"
                                  "instead got: %r" % e)

              http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                                    ca_certs=DEFAULT_CA)
              https_pool = http._new_pool('https', self.https_host,
                                          self.https_port)

              conn = https_pool._new_conn()
              self.assertEqual(conn.__class__, VerifiedHTTPSConnection)
              https_pool.request('GET', '/')  # Should succeed without exceptions.

              http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                                    ca_certs=DEFAULT_CA)
              https_fail_pool = http._new_pool('https', '127.0.0.1', self.https_port)

              try:
                  https_fail_pool.request('GET', '/')
                  self.fail("Didn't raise SSL invalid common name")
              except SSLError as e:
                  self.assertTrue("doesn't match" in str(e))

          def test_redirect(self):
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)

              r = http.request('GET', '%s/redirect' % self.http_url,
                               fields={'target': '%s/' % self.http_url},
                               redirect=False)

              self.assertEqual(r.status, 303)

              r = http.request('GET', '%s/redirect' % self.http_url,
                               fields={'target': '%s/' % self.http_url})

              self.assertEqual(r.status, 200)
              self.assertEqual(r.data, b'Dummy server!')

          def test_cross_host_redirect(self):
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)

              cross_host_location = '%s/echo?a=b' % self.http_url_alt
              try:
                  http.request('GET', '%s/redirect' % self.http_url,
                               fields={'target': cross_host_location},
                               timeout=1, retries=0)
                  self.fail("We don't want to follow redirects here.")

              except MaxRetryError:
                  pass

              r = http.request('GET', '%s/redirect' % self.http_url,
                               fields={'target': '%s/echo?a=b' % self.http_url_alt},
                               timeout=1, retries=1)
              self.assertNotEqual(r._pool.host, self.http_host_alt)

          def test_cross_protocol_redirect(self):
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)

              cross_protocol_location = '%s/echo?a=b' % self.https_url
              try:
                  http.request('GET', '%s/redirect' % self.http_url,
                               fields={'target': cross_protocol_location},
                               timeout=1, retries=0)
                  self.fail("We don't want to follow redirects here.")

              except MaxRetryError:
                  pass

              r = http.request('GET', '%s/redirect' % self.http_url,
                               fields={'target': '%s/echo?a=b' % self.https_url},
                               timeout=1, retries=1)
              self.assertEqual(r._pool.host, self.https_host)

          def test_headers(self):
              http = proxy_from_url(self.proxy_url, headers={'Foo': 'bar'},
                                    proxy_headers={'Hickory': 'dickory'})
              self.addCleanup(http.clear)

              r = http.request_encode_url('GET', '%s/headers' % self.http_url)
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), 'bar')
              self.assertEqual(returned_headers.get('Hickory'), 'dickory')
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.http_host, self.http_port))

              r = http.request_encode_url('GET', '%s/headers' % self.http_url_alt)
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), 'bar')
              self.assertEqual(returned_headers.get('Hickory'), 'dickory')
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.http_host_alt, self.http_port))

              r = http.request_encode_url('GET', '%s/headers' % self.https_url)
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), 'bar')
              self.assertEqual(returned_headers.get('Hickory'), None)
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.https_host, self.https_port))

              r = http.request_encode_url('GET', '%s/headers' % self.https_url_alt)
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), 'bar')
              self.assertEqual(returned_headers.get('Hickory'), None)
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.https_host_alt, self.https_port))

              r = http.request_encode_body('POST', '%s/headers' % self.http_url)
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), 'bar')
              self.assertEqual(returned_headers.get('Hickory'), 'dickory')
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.http_host, self.http_port))

              r = http.request_encode_url('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), None)
              self.assertEqual(returned_headers.get('Baz'), 'quux')
              self.assertEqual(returned_headers.get('Hickory'), 'dickory')
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.http_host, self.http_port))

              r = http.request_encode_url('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), None)
              self.assertEqual(returned_headers.get('Baz'), 'quux')
              self.assertEqual(returned_headers.get('Hickory'), None)
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.https_host, self.https_port))

              r = http.request_encode_body('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), None)
              self.assertEqual(returned_headers.get('Baz'), 'quux')
              self.assertEqual(returned_headers.get('Hickory'), 'dickory')
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.http_host, self.http_port))

              r = http.request_encode_body('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), None)
              self.assertEqual(returned_headers.get('Baz'), 'quux')
              self.assertEqual(returned_headers.get('Hickory'), None)
              self.assertEqual(returned_headers.get('Host'),
                               '%s:%s' % (self.https_host, self.https_port))

          def test_headerdict(self):
              default_headers = HTTPHeaderDict(a='b')
              proxy_headers = HTTPHeaderDict()
              proxy_headers.add('foo', 'bar')

              http = proxy_from_url(
                  self.proxy_url,
                  headers=default_headers,
                  proxy_headers=proxy_headers)
              self.addCleanup(http.clear)

              request_headers = HTTPHeaderDict(baz='quux')
              r = http.request('GET', '%s/headers' % self.http_url, headers=request_headers)
              returned_headers = json.loads(r.data.decode())
              self.assertEqual(returned_headers.get('Foo'), 'bar')
              self.assertEqual(returned_headers.get('Baz'), 'quux')

          def test_proxy_pooling(self):
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)

              for x in range(2):
                  http.urlopen('GET', self.http_url)
              self.assertEqual(len(http.pools), 1)

              for x in range(2):
                  http.urlopen('GET', self.http_url_alt)
              self.assertEqual(len(http.pools), 1)

              for x in range(2):
                  http.urlopen('GET', self.https_url)
              self.assertEqual(len(http.pools), 2)

              for x in range(2):
                  http.urlopen('GET', self.https_url_alt)
              self.assertEqual(len(http.pools), 3)

          def test_proxy_pooling_ext(self):
              http = proxy_from_url(self.proxy_url)
              self.addCleanup(http.clear)

              hc1 = http.connection_from_url(self.http_url)
              hc2 = http.connection_from_host(self.http_host, self.http_port)
              hc3 = http.connection_from_url(self.http_url_alt)
              hc4 = http.connection_from_host(self.http_host_alt, self.http_port)
              self.assertEqual(hc1, hc2)
              self.assertEqual(hc2, hc3)
              self.assertEqual(hc3, hc4)

              sc1 = http.connection_from_url(self.https_url)
              sc2 = http.connection_from_host(self.https_host,
                                              self.https_port, scheme='https')
              sc3 = http.connection_from_url(self.https_url_alt)
              sc4 = http.connection_from_host(self.https_host_alt,
                                              self.https_port, scheme='https')
              self.assertEqual(sc1, sc2)
              self.assertNotEqual(sc2, sc3)
              self.assertEqual(sc3, sc4)

          @timed(0.5)
          @requires_network
          def test_https_proxy_timeout(self):
              https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST))
              self.addCleanup(https.clear)
              try:
                  https.request('GET', self.http_url, timeout=0.001)
                  self.fail("Failed to raise retry error.")
              except MaxRetryError as e:
                  self.assertEqual(type(e.reason), ConnectTimeoutError)

          @timed(0.5)
          @requires_network
          def test_https_proxy_pool_timeout(self):
              https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST),
                                     timeout=0.001)
              self.addCleanup(https.clear)
              try:
                  https.request('GET', self.http_url)
                  self.fail("Failed to raise retry error.")
              except MaxRetryError as e:
                  self.assertEqual(type(e.reason), ConnectTimeoutError)

          def test_scheme_host_case_insensitive(self):
              """Assert that upper-case schemes and hosts are normalized."""
              http = proxy_from_url(self.proxy_url.upper())
              self.addCleanup(http.clear)

              r = http.request('GET', '%s/' % self.http_url.upper())
              self.assertEqual(r.status, 200)

              r = http.request('GET', '%s/' % self.https_url.upper())
              self.assertEqual(r.status, 200)
    tokens: resume load_const INTEGER load_const import_name json store_name json load_const INTEGER load_const import_name socket store_name socket load_const INTEGER load_const import_name unittest store_name unittest load_const INTEGER load_const import_name nose.tools import_from timed store_name timed pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from DEFAULT_CA store_name DEFAULT_CA import_from DEFAULT_CA_BAD store_name DEFAULT_CA_BAD import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name import_from TARPIT_HOST store_name TARPIT_HOST import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from HTTPHeaderDict store_name HTTPHeaderDict pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from proxy_from_url store_name proxy_from_url import_from ProxyManager store_name ProxyManager pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from MaxRetryError store_name MaxRetryError import_from SSLError store_name SSLError import_from ProxyError store_name ProxyError import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name STRING_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top push_null load_build_class load_const OBJECT make_function load_const STRING_BASE64_LEN_S_ENT_HIGH load_name STRING_LEN_S_ENT_HIGH call store_name STRING_BASE64_LEN_S_ENT_HIGH push_null load_build_class load_const OBJECT make_function load_const STRING_BASE64_LEN_S_ENT_HIGH load_name STRING_LEN_S_ENT_HIGH call store_name STRING_BASE64_LEN_S_ENT_HIGH load_name __name__ load_const __main__ compare_op == pop_jump_if_false TO_NUMBER push_null load_name unittest load_attr main call pop_top return_const None return_const None
    hash: c5d079eb35b9979242a65cc6bf30bb0e8122f28c1f7e25bd6b64981432fde407
sources:
  ? .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/test/with_dummyserver/test_proxy_poolmanager.py
  : aW1wb3J0IGpzb24KaW1wb3J0IHNvY2tldAppbXBvcnQgdW5pdHRlc3QKCmZyb20gbm9zZS50b29scyBpbXBvcnQgdGltZWQKCmZyb20gZHVtbXlzZXJ2ZXIudGVzdGNhc2UgaW1wb3J0IEhUVFBEdW1teVByb3h5VGVzdENhc2UsIElQdjZIVFRQRHVtbXlQcm94eVRlc3RDYXNlCmZyb20gZHVtbXlzZXJ2ZXIuc2VydmVyIGltcG9ydCAoCiAgICBERUZBVUxUX0NBLCBERUZBVUxUX0NBX0JBRCwgZ2V0X3VucmVhY2hhYmxlX2FkZHJlc3MpCmZyb20gLi4gaW1wb3J0IFRBUlBJVF9IT1NULCByZXF1aXJlc19uZXR3b3JrCgpmcm9tIHVybGxpYjMuX2NvbGxlY3Rpb25zIGltcG9ydCBIVFRQSGVhZGVyRGljdApmcm9tIHVybGxpYjMucG9vbG1hbmFnZXIgaW1wb3J0IHByb3h5X2Zyb21fdXJsLCBQcm94eU1hbmFnZXIKZnJvbSB1cmxsaWIzLmV4Y2VwdGlvbnMgaW1wb3J0ICgKICAgIE1heFJldHJ5RXJyb3IsIFNTTEVycm9yLCBQcm94eUVycm9yLCBDb25uZWN0VGltZW91dEVycm9yKQpmcm9tIHVybGxpYjMuY29ubmVjdGlvbnBvb2wgaW1wb3J0IGNvbm5lY3Rpb25fZnJvbV91cmwsIFZlcmlmaWVkSFRUUFNDb25uZWN0aW9uCgoKY2xhc3MgVGVzdEhUVFBQcm94eU1hbmFnZXIoSFRUUER1bW15UHJveHlUZXN0Q2FzZSk6CgogICAgZGVmIHNldFVwKHNlbGYpOgogICAgICAgIHNlbGYuaHR0cF91cmwgPSAnaHR0cDovLyVzOiVkJyAlIChzZWxmLmh0dHBfaG9zdCwgc2VsZi5odHRwX3BvcnQpCiAgICAgICAgc2VsZi5odHRwX3VybF9hbHQgPSAnaHR0cDovLyVzOiVkJyAlIChzZWxmLmh0dHBfaG9zdF9hbHQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmh0dHBfcG9ydCkKICAgICAgICBzZWxmLmh0dHBzX3VybCA9ICdodHRwczovLyVzOiVkJyAlIChzZWxmLmh0dHBzX2hvc3QsIHNlbGYuaHR0cHNfcG9ydCkKICAgICAgICBzZWxmLmh0dHBzX3VybF9hbHQgPSAnaHR0cHM6Ly8lczolZCcgJSAoc2VsZi5odHRwc19ob3N0X2FsdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5odHRwc19wb3J0KQogICAgICAgIHNlbGYucHJveHlfdXJsID0gJ2h0dHA6Ly8lczolZCcgJSAoc2VsZi5wcm94eV9ob3N0LCBzZWxmLnByb3h5X3BvcnQpCgogICAgZGVmIHRlc3RfYmFzaWNfcHJveHkoc2VsZik6CiAgICAgICAgaHR0cCA9IHByb3h5X2Zyb21fdXJsKHNlbGYucHJveHlfdXJsKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwLmNsZWFyKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0KCdHRVQnLCAnJXMvJyAlIHNlbGYuaHR0cF91cmwpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyLnN0YXR1cywgMjAwKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0KCdHRVQnLCAnJXMvJyAlIHNlbGYuaHR0cHNfdXJsKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoci5zdGF0dXMsIDIwMCkKCiAgICBkZWYgdGVzdF9uYWdsZV9wcm94eShzZWxmKToKICAgICAgICAiIiIgVGVzdCB0aGF0IHByb3h5IGNvbm5lY3Rpb25zIGRvIG5vdCBoYXZlIFRDUF9OT0RFTEFZIHR1cm5lZCBvbiAiIiIKICAgICAgICBodHRwID0gcHJveHlfZnJvbV91cmwoc2VsZi5wcm94eV91cmwpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGh0dHAuY2xlYXIpCiAgICAgICAgaGMyID0gaHR0cC5jb25uZWN0aW9uX2Zyb21faG9zdChzZWxmLmh0dHBfaG9zdCwgc2VsZi5odHRwX3BvcnQpCiAgICAgICAgY29ubiA9IGhjMi5fZ2V0X2Nvbm4oKQogICAgICAgIGhjMi5fbWFrZV9yZXF1ZXN0KGNvbm4sICdHRVQnLCAnLycpCiAgICAgICAgdGNwX25vZGVsYXlfc2V0dGluZyA9IGNvbm4uc29jay5nZXRzb2Nrb3B0KHNvY2tldC5JUFBST1RPX1RDUCwgc29ja2V0LlRDUF9OT0RFTEFZKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwodGNwX25vZGVsYXlfc2V0dGluZywgMCwKICAgICAgICAgICAgICAgICAgICAgICAgICgiRXhwZWN0ZWQgVENQX05PREVMQVkgZm9yIHByb3hpZXMgdG8gYmUgc2V0ICIKICAgICAgICAgICAgICAgICAgICAgICAgICAidG8gemVybywgaW5zdGVhZCB3YXMgJXMiICUgdGNwX25vZGVsYXlfc2V0dGluZykpCgogICAgZGVmIHRlc3RfcHJveHlfY29ubl9mYWlsKHNlbGYpOgogICAgICAgIGhvc3QsIHBvcnQgPSBnZXRfdW5yZWFjaGFibGVfYWRkcmVzcygpCiAgICAgICAgaHR0cCA9IHByb3h5X2Zyb21fdXJsKCdodHRwOi8vJXM6JXMvJyAlIChob3N0LCBwb3J0KSwgcmV0cmllcz0xLCB0aW1lb3V0PTAuMDUpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGh0dHAuY2xlYXIpCiAgICAgICAgc2VsZi5hc3NlcnRSYWlzZXMoTWF4UmV0cnlFcnJvciwgaHR0cC5yZXF1ZXN0LCAnR0VUJywKICAgICAgICAgICAgICAgICAgICAgICAgICAnJXMvJyAlIHNlbGYuaHR0cHNfdXJsKQogICAgICAgIHNlbGYuYXNzZXJ0UmFpc2VzKE1heFJldHJ5RXJyb3IsIGh0dHAucmVxdWVzdCwgJ0dFVCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgJyVzLycgJSBzZWxmLmh0dHBfdXJsKQoKICAgICAgICB0cnk6CiAgICAgICAgICAgIGh0dHAucmVxdWVzdCgnR0VUJywgJyVzLycgJSBzZWxmLmh0dHBfdXJsKQogICAgICAgICAgICBzZWxmLmZhaWwoIkZhaWxlZCB0byByYWlzZSByZXRyeSBlcnJvci4iKQogICAgICAgIGV4Y2VwdCBNYXhSZXRyeUVycm9yIGFzIGU6CiAgICAgICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwodHlwZShlLnJlYXNvbiksIFByb3h5RXJyb3IpCgogICAgZGVmIHRlc3Rfb2xkYXBpKHNlbGYpOgogICAgICAgIGh0dHAgPSBQcm94eU1hbmFnZXIoY29ubmVjdGlvbl9mcm9tX3VybChzZWxmLnByb3h5X3VybCkpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGh0dHAuY2xlYXIpCgogICAgICAgIHIgPSBodHRwLnJlcXVlc3QoJ0dFVCcsICclcy8nICUgc2VsZi5odHRwX3VybCkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHIuc3RhdHVzLCAyMDApCgogICAgICAgIHIgPSBodHRwLnJlcXVlc3QoJ0dFVCcsICclcy8nICUgc2VsZi5odHRwc191cmwpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyLnN0YXR1cywgMjAwKQoKICAgIGRlZiB0ZXN0X3Byb3h5X3ZlcmlmaWVkKHNlbGYpOgogICAgICAgIGh0dHAgPSBwcm94eV9mcm9tX3VybChzZWxmLnByb3h5X3VybCwgY2VydF9yZXFzPSdSRVFVSVJFRCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhX2NlcnRzPURFRkFVTFRfQ0FfQkFEKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwLmNsZWFyKQogICAgICAgIGh0dHBzX3Bvb2wgPSBodHRwLl9uZXdfcG9vbCgnaHR0cHMnLCBzZWxmLmh0dHBzX2hvc3QsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaHR0cHNfcG9ydCkKICAgICAgICB0cnk6CiAgICAgICAgICAgIGh0dHBzX3Bvb2wucmVxdWVzdCgnR0VUJywgJy8nKQogICAgICAgICAgICBzZWxmLmZhaWwoIkRpZG4ndCByYWlzZSBTU0wgZXJyb3Igd2l0aCB3cm9uZyBDQSIpCiAgICAgICAgZXhjZXB0IFNTTEVycm9yIGFzIGU6CiAgICAgICAgICAgIHNlbGYuYXNzZXJ0VHJ1ZSgnY2VydGlmaWNhdGUgdmVyaWZ5IGZhaWxlZCcgaW4gc3RyKGUpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgIkV4cGVjdGVkICdjZXJ0aWZpY2F0ZSB2ZXJpZnkgZmFpbGVkJywiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW5zdGVhZCBnb3Q6ICVyIiAlIGUpCgogICAgICAgIGh0dHAgPSBwcm94eV9mcm9tX3VybChzZWxmLnByb3h5X3VybCwgY2VydF9yZXFzPSdSRVFVSVJFRCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhX2NlcnRzPURFRkFVTFRfQ0EpCiAgICAgICAgaHR0cHNfcG9vbCA9IGh0dHAuX25ld19wb29sKCdodHRwcycsIHNlbGYuaHR0cHNfaG9zdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5odHRwc19wb3J0KQoKICAgICAgICBjb25uID0gaHR0cHNfcG9vbC5fbmV3X2Nvbm4oKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoY29ubi5fX2NsYXNzX18sIFZlcmlmaWVkSFRUUFNDb25uZWN0aW9uKQogICAgICAgIGh0dHBzX3Bvb2wucmVxdWVzdCgnR0VUJywgJy8nKSAgIyBTaG91bGQgc3VjY2VlZCB3aXRob3V0IGV4Y2VwdGlvbnMuCgogICAgICAgIGh0dHAgPSBwcm94eV9mcm9tX3VybChzZWxmLnByb3h5X3VybCwgY2VydF9yZXFzPSdSRVFVSVJFRCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhX2NlcnRzPURFRkFVTFRfQ0EpCiAgICAgICAgaHR0cHNfZmFpbF9wb29sID0gaHR0cC5fbmV3X3Bvb2woJ2h0dHBzJywgJzEyNy4wLjAuMScsIHNlbGYuaHR0cHNfcG9ydCkKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBodHRwc19mYWlsX3Bvb2wucmVxdWVzdCgnR0VUJywgJy8nKQogICAgICAgICAgICBzZWxmLmZhaWwoIkRpZG4ndCByYWlzZSBTU0wgaW52YWxpZCBjb21tb24gbmFtZSIpCiAgICAgICAgZXhjZXB0IFNTTEVycm9yIGFzIGU6CiAgICAgICAgICAgIHNlbGYuYXNzZXJ0VHJ1ZSgiZG9lc24ndCBtYXRjaCIgaW4gc3RyKGUpKQoKICAgIGRlZiB0ZXN0X3JlZGlyZWN0KHNlbGYpOgogICAgICAgIGh0dHAgPSBwcm94eV9mcm9tX3VybChzZWxmLnByb3h5X3VybCkKICAgICAgICBzZWxmLmFkZENsZWFudXAoaHR0cC5jbGVhcikKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdCgnR0VUJywgJyVzL3JlZGlyZWN0JyAlIHNlbGYuaHR0cF91cmwsCiAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM9eyd0YXJnZXQnOiAnJXMvJyAlIHNlbGYuaHR0cF91cmx9LAogICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3Q9RmFsc2UpCgogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoci5zdGF0dXMsIDMwMykKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdCgnR0VUJywgJyVzL3JlZGlyZWN0JyAlIHNlbGYuaHR0cF91cmwsCiAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM9eyd0YXJnZXQnOiAnJXMvJyAlIHNlbGYuaHR0cF91cmx9KQoKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHIuc3RhdHVzLCAyMDApCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyLmRhdGEsIGInRHVtbXkgc2VydmVyIScpCgogICAgZGVmIHRlc3RfY3Jvc3NfaG9zdF9yZWRpcmVjdChzZWxmKToKICAgICAgICBodHRwID0gcHJveHlfZnJvbV91cmwoc2VsZi5wcm94eV91cmwpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGh0dHAuY2xlYXIpCgogICAgICAgIGNyb3NzX2hvc3RfbG9jYXRpb24gPSAnJXMvZWNobz9hPWInICUgc2VsZi5odHRwX3VybF9hbHQKICAgICAgICB0cnk6CiAgICAgICAgICAgIGh0dHAucmVxdWVzdCgnR0VUJywgJyVzL3JlZGlyZWN0JyAlIHNlbGYuaHR0cF91cmwsCiAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM9eyd0YXJnZXQnOiBjcm9zc19ob3N0X2xvY2F0aW9ufSwKICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ9MSwgcmV0cmllcz0wKQogICAgICAgICAgICBzZWxmLmZhaWwoIldlIGRvbid0IHdhbnQgdG8gZm9sbG93IHJlZGlyZWN0cyBoZXJlLiIpCgogICAgICAgIGV4Y2VwdCBNYXhSZXRyeUVycm9yOgogICAgICAgICAgICBwYXNzCgogICAgICAgIHIgPSBodHRwLnJlcXVlc3QoJ0dFVCcsICclcy9yZWRpcmVjdCcgJSBzZWxmLmh0dHBfdXJsLAogICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzPXsndGFyZ2V0JzogJyVzL2VjaG8/YT1iJyAlIHNlbGYuaHR0cF91cmxfYWx0fSwKICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ9MSwgcmV0cmllcz0xKQogICAgICAgIHNlbGYuYXNzZXJ0Tm90RXF1YWwoci5fcG9vbC5ob3N0LCBzZWxmLmh0dHBfaG9zdF9hbHQpCgogICAgZGVmIHRlc3RfY3Jvc3NfcHJvdG9jb2xfcmVkaXJlY3Qoc2VsZik6CiAgICAgICAgaHR0cCA9IHByb3h5X2Zyb21fdXJsKHNlbGYucHJveHlfdXJsKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwLmNsZWFyKQoKICAgICAgICBjcm9zc19wcm90b2NvbF9sb2NhdGlvbiA9ICclcy9lY2hvP2E9YicgJSBzZWxmLmh0dHBzX3VybAogICAgICAgIHRyeToKICAgICAgICAgICAgaHR0cC5yZXF1ZXN0KCdHRVQnLCAnJXMvcmVkaXJlY3QnICUgc2VsZi5odHRwX3VybCwKICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcz17J3RhcmdldCc6IGNyb3NzX3Byb3RvY29sX2xvY2F0aW9ufSwKICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ9MSwgcmV0cmllcz0wKQogICAgICAgICAgICBzZWxmLmZhaWwoIldlIGRvbid0IHdhbnQgdG8gZm9sbG93IHJlZGlyZWN0cyBoZXJlLiIpCgogICAgICAgIGV4Y2VwdCBNYXhSZXRyeUVycm9yOgogICAgICAgICAgICBwYXNzCgogICAgICAgIHIgPSBodHRwLnJlcXVlc3QoJ0dFVCcsICclcy9yZWRpcmVjdCcgJSBzZWxmLmh0dHBfdXJsLAogICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzPXsndGFyZ2V0JzogJyVzL2VjaG8/YT1iJyAlIHNlbGYuaHR0cHNfdXJsfSwKICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ9MSwgcmV0cmllcz0xKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoci5fcG9vbC5ob3N0LCBzZWxmLmh0dHBzX2hvc3QpCgogICAgZGVmIHRlc3RfaGVhZGVycyhzZWxmKToKICAgICAgICBodHRwID0gcHJveHlfZnJvbV91cmwoc2VsZi5wcm94eV91cmwsIGhlYWRlcnM9eydGb28nOiAnYmFyJ30sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5X2hlYWRlcnM9eydIaWNrb3J5JzogJ2RpY2tvcnknfSkKICAgICAgICBzZWxmLmFkZENsZWFudXAoaHR0cC5jbGVhcikKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdF9lbmNvZGVfdXJsKCdHRVQnLCAnJXMvaGVhZGVycycgJSBzZWxmLmh0dHBfdXJsKQogICAgICAgIHJldHVybmVkX2hlYWRlcnMgPSBqc29uLmxvYWRzKHIuZGF0YS5kZWNvZGUoKSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdGb28nKSwgJ2JhcicpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSGlja29yeScpLCAnZGlja29yeScpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSG9zdCcpLAogICAgICAgICAgICAgICAgICAgICAgICAgJyVzOiVzJyAlIChzZWxmLmh0dHBfaG9zdCwgc2VsZi5odHRwX3BvcnQpKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0X2VuY29kZV91cmwoJ0dFVCcsICclcy9oZWFkZXJzJyAlIHNlbGYuaHR0cF91cmxfYWx0KQogICAgICAgIHJldHVybmVkX2hlYWRlcnMgPSBqc29uLmxvYWRzKHIuZGF0YS5kZWNvZGUoKSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdGb28nKSwgJ2JhcicpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSGlja29yeScpLCAnZGlja29yeScpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSG9zdCcpLAogICAgICAgICAgICAgICAgICAgICAgICAgJyVzOiVzJyAlIChzZWxmLmh0dHBfaG9zdF9hbHQsIHNlbGYuaHR0cF9wb3J0KSkKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdF9lbmNvZGVfdXJsKCdHRVQnLCAnJXMvaGVhZGVycycgJSBzZWxmLmh0dHBzX3VybCkKICAgICAgICByZXR1cm5lZF9oZWFkZXJzID0ganNvbi5sb2FkcyhyLmRhdGEuZGVjb2RlKCkpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnRm9vJyksICdiYXInKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0hpY2tvcnknKSwgTm9uZSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdIb3N0JyksCiAgICAgICAgICAgICAgICAgICAgICAgICAnJXM6JXMnICUgKHNlbGYuaHR0cHNfaG9zdCwgc2VsZi5odHRwc19wb3J0KSkKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdF9lbmNvZGVfdXJsKCdHRVQnLCAnJXMvaGVhZGVycycgJSBzZWxmLmh0dHBzX3VybF9hbHQpCiAgICAgICAgcmV0dXJuZWRfaGVhZGVycyA9IGpzb24ubG9hZHMoci5kYXRhLmRlY29kZSgpKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0ZvbycpLCAnYmFyJykKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdIaWNrb3J5JyksIE5vbmUpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSG9zdCcpLAogICAgICAgICAgICAgICAgICAgICAgICAgJyVzOiVzJyAlIChzZWxmLmh0dHBzX2hvc3RfYWx0LCBzZWxmLmh0dHBzX3BvcnQpKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0X2VuY29kZV9ib2R5KCdQT1NUJywgJyVzL2hlYWRlcnMnICUgc2VsZi5odHRwX3VybCkKICAgICAgICByZXR1cm5lZF9oZWFkZXJzID0ganNvbi5sb2FkcyhyLmRhdGEuZGVjb2RlKCkpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnRm9vJyksICdiYXInKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0hpY2tvcnknKSwgJ2RpY2tvcnknKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0hvc3QnKSwKICAgICAgICAgICAgICAgICAgICAgICAgICclczolcycgJSAoc2VsZi5odHRwX2hvc3QsIHNlbGYuaHR0cF9wb3J0KSkKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdF9lbmNvZGVfdXJsKCdHRVQnLCAnJXMvaGVhZGVycycgJSBzZWxmLmh0dHBfdXJsLCBoZWFkZXJzPXsnQmF6JzogJ3F1dXgnfSkKICAgICAgICByZXR1cm5lZF9oZWFkZXJzID0ganNvbi5sb2FkcyhyLmRhdGEuZGVjb2RlKCkpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnRm9vJyksIE5vbmUpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnQmF6JyksICdxdXV4JykKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdIaWNrb3J5JyksICdkaWNrb3J5JykKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdIb3N0JyksCiAgICAgICAgICAgICAgICAgICAgICAgICAnJXM6JXMnICUgKHNlbGYuaHR0cF9ob3N0LCBzZWxmLmh0dHBfcG9ydCkpCgogICAgICAgIHIgPSBodHRwLnJlcXVlc3RfZW5jb2RlX3VybCgnR0VUJywgJyVzL2hlYWRlcnMnICUgc2VsZi5odHRwc191cmwsIGhlYWRlcnM9eydCYXonOiAncXV1eCd9KQogICAgICAgIHJldHVybmVkX2hlYWRlcnMgPSBqc29uLmxvYWRzKHIuZGF0YS5kZWNvZGUoKSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdGb28nKSwgTm9uZSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdCYXonKSwgJ3F1dXgnKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0hpY2tvcnknKSwgTm9uZSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdIb3N0JyksCiAgICAgICAgICAgICAgICAgICAgICAgICAnJXM6JXMnICUgKHNlbGYuaHR0cHNfaG9zdCwgc2VsZi5odHRwc19wb3J0KSkKCiAgICAgICAgciA9IGh0dHAucmVxdWVzdF9lbmNvZGVfYm9keSgnR0VUJywgJyVzL2hlYWRlcnMnICUgc2VsZi5odHRwX3VybCwgaGVhZGVycz17J0Jheic6ICdxdXV4J30pCiAgICAgICAgcmV0dXJuZWRfaGVhZGVycyA9IGpzb24ubG9hZHMoci5kYXRhLmRlY29kZSgpKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0ZvbycpLCBOb25lKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0JheicpLCAncXV1eCcpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSGlja29yeScpLCAnZGlja29yeScpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSG9zdCcpLAogICAgICAgICAgICAgICAgICAgICAgICAgJyVzOiVzJyAlIChzZWxmLmh0dHBfaG9zdCwgc2VsZi5odHRwX3BvcnQpKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0X2VuY29kZV9ib2R5KCdHRVQnLCAnJXMvaGVhZGVycycgJSBzZWxmLmh0dHBzX3VybCwgaGVhZGVycz17J0Jheic6ICdxdXV4J30pCiAgICAgICAgcmV0dXJuZWRfaGVhZGVycyA9IGpzb24ubG9hZHMoci5kYXRhLmRlY29kZSgpKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0ZvbycpLCBOb25lKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0JheicpLCAncXV1eCcpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyZXR1cm5lZF9oZWFkZXJzLmdldCgnSGlja29yeScpLCBOb25lKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0hvc3QnKSwKICAgICAgICAgICAgICAgICAgICAgICAgICclczolcycgJSAoc2VsZi5odHRwc19ob3N0LCBzZWxmLmh0dHBzX3BvcnQpKQoKICAgIGRlZiB0ZXN0X2hlYWRlcmRpY3Qoc2VsZik6CiAgICAgICAgZGVmYXVsdF9oZWFkZXJzID0gSFRUUEhlYWRlckRpY3QoYT0nYicpCiAgICAgICAgcHJveHlfaGVhZGVycyA9IEhUVFBIZWFkZXJEaWN0KCkKICAgICAgICBwcm94eV9oZWFkZXJzLmFkZCgnZm9vJywgJ2JhcicpCgogICAgICAgIGh0dHAgPSBwcm94eV9mcm9tX3VybCgKICAgICAgICAgICAgc2VsZi5wcm94eV91cmwsCiAgICAgICAgICAgIGhlYWRlcnM9ZGVmYXVsdF9oZWFkZXJzLAogICAgICAgICAgICBwcm94eV9oZWFkZXJzPXByb3h5X2hlYWRlcnMpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGh0dHAuY2xlYXIpCgogICAgICAgIHJlcXVlc3RfaGVhZGVycyA9IEhUVFBIZWFkZXJEaWN0KGJhej0ncXV1eCcpCiAgICAgICAgciA9IGh0dHAucmVxdWVzdCgnR0VUJywgJyVzL2hlYWRlcnMnICUgc2VsZi5odHRwX3VybCwgaGVhZGVycz1yZXF1ZXN0X2hlYWRlcnMpCiAgICAgICAgcmV0dXJuZWRfaGVhZGVycyA9IGpzb24ubG9hZHMoci5kYXRhLmRlY29kZSgpKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwocmV0dXJuZWRfaGVhZGVycy5nZXQoJ0ZvbycpLCAnYmFyJykKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHJldHVybmVkX2hlYWRlcnMuZ2V0KCdCYXonKSwgJ3F1dXgnKQoKICAgIGRlZiB0ZXN0X3Byb3h5X3Bvb2xpbmcoc2VsZik6CiAgICAgICAgaHR0cCA9IHByb3h5X2Zyb21fdXJsKHNlbGYucHJveHlfdXJsKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwLmNsZWFyKQoKICAgICAgICBmb3IgeCBpbiByYW5nZSgyKToKICAgICAgICAgICAgaHR0cC51cmxvcGVuKCdHRVQnLCBzZWxmLmh0dHBfdXJsKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwobGVuKGh0dHAucG9vbHMpLCAxKQoKICAgICAgICBmb3IgeCBpbiByYW5nZSgyKToKICAgICAgICAgICAgaHR0cC51cmxvcGVuKCdHRVQnLCBzZWxmLmh0dHBfdXJsX2FsdCkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKGxlbihodHRwLnBvb2xzKSwgMSkKCiAgICAgICAgZm9yIHggaW4gcmFuZ2UoMik6CiAgICAgICAgICAgIGh0dHAudXJsb3BlbignR0VUJywgc2VsZi5odHRwc191cmwpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChsZW4oaHR0cC5wb29scyksIDIpCgogICAgICAgIGZvciB4IGluIHJhbmdlKDIpOgogICAgICAgICAgICBodHRwLnVybG9wZW4oJ0dFVCcsIHNlbGYuaHR0cHNfdXJsX2FsdCkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKGxlbihodHRwLnBvb2xzKSwgMykKCiAgICBkZWYgdGVzdF9wcm94eV9wb29saW5nX2V4dChzZWxmKToKICAgICAgICBodHRwID0gcHJveHlfZnJvbV91cmwoc2VsZi5wcm94eV91cmwpCiAgICAgICAgc2VsZi5hZGRDbGVhbnVwKGh0dHAuY2xlYXIpCgogICAgICAgIGhjMSA9IGh0dHAuY29ubmVjdGlvbl9mcm9tX3VybChzZWxmLmh0dHBfdXJsKQogICAgICAgIGhjMiA9IGh0dHAuY29ubmVjdGlvbl9mcm9tX2hvc3Qoc2VsZi5odHRwX2hvc3QsIHNlbGYuaHR0cF9wb3J0KQogICAgICAgIGhjMyA9IGh0dHAuY29ubmVjdGlvbl9mcm9tX3VybChzZWxmLmh0dHBfdXJsX2FsdCkKICAgICAgICBoYzQgPSBodHRwLmNvbm5lY3Rpb25fZnJvbV9ob3N0KHNlbGYuaHR0cF9ob3N0X2FsdCwgc2VsZi5odHRwX3BvcnQpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChoYzEsIGhjMikKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKGhjMiwgaGMzKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoaGMzLCBoYzQpCgogICAgICAgIHNjMSA9IGh0dHAuY29ubmVjdGlvbl9mcm9tX3VybChzZWxmLmh0dHBzX3VybCkKICAgICAgICBzYzIgPSBodHRwLmNvbm5lY3Rpb25fZnJvbV9ob3N0KHNlbGYuaHR0cHNfaG9zdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaHR0cHNfcG9ydCwgc2NoZW1lPSdodHRwcycpCiAgICAgICAgc2MzID0gaHR0cC5jb25uZWN0aW9uX2Zyb21fdXJsKHNlbGYuaHR0cHNfdXJsX2FsdCkKICAgICAgICBzYzQgPSBodHRwLmNvbm5lY3Rpb25fZnJvbV9ob3N0KHNlbGYuaHR0cHNfaG9zdF9hbHQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmh0dHBzX3BvcnQsIHNjaGVtZT0naHR0cHMnKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoc2MxLCBzYzIpCiAgICAgICAgc2VsZi5hc3NlcnROb3RFcXVhbChzYzIsIHNjMykKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHNjMywgc2M0KQoKICAgIEB0aW1lZCgwLjUpCiAgICBAcmVxdWlyZXNfbmV0d29yawogICAgZGVmIHRlc3RfaHR0cHNfcHJveHlfdGltZW91dChzZWxmKToKICAgICAgICBodHRwcyA9IHByb3h5X2Zyb21fdXJsKCdodHRwczovL3tob3N0fScuZm9ybWF0KGhvc3Q9VEFSUElUX0hPU1QpKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwcy5jbGVhcikKICAgICAgICB0cnk6CiAgICAgICAgICAgIGh0dHBzLnJlcXVlc3QoJ0dFVCcsIHNlbGYuaHR0cF91cmwsIHRpbWVvdXQ9MC4wMDEpCiAgICAgICAgICAgIHNlbGYuZmFpbCgiRmFpbGVkIHRvIHJhaXNlIHJldHJ5IGVycm9yLiIpCiAgICAgICAgZXhjZXB0IE1heFJldHJ5RXJyb3IgYXMgZToKICAgICAgICAgICAgc2VsZi5hc3NlcnRFcXVhbCh0eXBlKGUucmVhc29uKSwgQ29ubmVjdFRpbWVvdXRFcnJvcikKCiAgICBAdGltZWQoMC41KQogICAgQHJlcXVpcmVzX25ldHdvcmsKICAgIGRlZiB0ZXN0X2h0dHBzX3Byb3h5X3Bvb2xfdGltZW91dChzZWxmKToKICAgICAgICBodHRwcyA9IHByb3h5X2Zyb21fdXJsKCdodHRwczovL3tob3N0fScuZm9ybWF0KGhvc3Q9VEFSUElUX0hPU1QpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dD0wLjAwMSkKICAgICAgICBzZWxmLmFkZENsZWFudXAoaHR0cHMuY2xlYXIpCiAgICAgICAgdHJ5OgogICAgICAgICAgICBodHRwcy5yZXF1ZXN0KCdHRVQnLCBzZWxmLmh0dHBfdXJsKQogICAgICAgICAgICBzZWxmLmZhaWwoIkZhaWxlZCB0byByYWlzZSByZXRyeSBlcnJvci4iKQogICAgICAgIGV4Y2VwdCBNYXhSZXRyeUVycm9yIGFzIGU6CiAgICAgICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwodHlwZShlLnJlYXNvbiksIENvbm5lY3RUaW1lb3V0RXJyb3IpCgogICAgZGVmIHRlc3Rfc2NoZW1lX2hvc3RfY2FzZV9pbnNlbnNpdGl2ZShzZWxmKToKICAgICAgICAiIiJBc3NlcnQgdGhhdCB1cHBlci1jYXNlIHNjaGVtZXMgYW5kIGhvc3RzIGFyZSBub3JtYWxpemVkLiIiIgogICAgICAgIGh0dHAgPSBwcm94eV9mcm9tX3VybChzZWxmLnByb3h5X3VybC51cHBlcigpKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwLmNsZWFyKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0KCdHRVQnLCAnJXMvJyAlIHNlbGYuaHR0cF91cmwudXBwZXIoKSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHIuc3RhdHVzLCAyMDApCgogICAgICAgIHIgPSBodHRwLnJlcXVlc3QoJ0dFVCcsICclcy8nICUgc2VsZi5odHRwc191cmwudXBwZXIoKSkKICAgICAgICBzZWxmLmFzc2VydEVxdWFsKHIuc3RhdHVzLCAyMDApCgoKY2xhc3MgVGVzdElQdjZIVFRQUHJveHlNYW5hZ2VyKElQdjZIVFRQRHVtbXlQcm94eVRlc3RDYXNlKToKCiAgICBkZWYgc2V0VXAoc2VsZik6CiAgICAgICAgc2VsZi5odHRwX3VybCA9ICdodHRwOi8vJXM6JWQnICUgKHNlbGYuaHR0cF9ob3N0LCBzZWxmLmh0dHBfcG9ydCkKICAgICAgICBzZWxmLmh0dHBfdXJsX2FsdCA9ICdodHRwOi8vJXM6JWQnICUgKHNlbGYuaHR0cF9ob3N0X2FsdCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaHR0cF9wb3J0KQogICAgICAgIHNlbGYuaHR0cHNfdXJsID0gJ2h0dHBzOi8vJXM6JWQnICUgKHNlbGYuaHR0cHNfaG9zdCwgc2VsZi5odHRwc19wb3J0KQogICAgICAgIHNlbGYuaHR0cHNfdXJsX2FsdCA9ICdodHRwczovLyVzOiVkJyAlIChzZWxmLmh0dHBzX2hvc3RfYWx0LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmh0dHBzX3BvcnQpCiAgICAgICAgc2VsZi5wcm94eV91cmwgPSAnaHR0cDovL1slc106JWQnICUgKHNlbGYucHJveHlfaG9zdCwgc2VsZi5wcm94eV9wb3J0KQoKICAgIGRlZiB0ZXN0X2Jhc2ljX2lwdjZfcHJveHkoc2VsZik6CiAgICAgICAgaHR0cCA9IHByb3h5X2Zyb21fdXJsKHNlbGYucHJveHlfdXJsKQogICAgICAgIHNlbGYuYWRkQ2xlYW51cChodHRwLmNsZWFyKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0KCdHRVQnLCAnJXMvJyAlIHNlbGYuaHR0cF91cmwpCiAgICAgICAgc2VsZi5hc3NlcnRFcXVhbChyLnN0YXR1cywgMjAwKQoKICAgICAgICByID0gaHR0cC5yZXF1ZXN0KCdHRVQnLCAnJXMvJyAlIHNlbGYuaHR0cHNfdXJsKQogICAgICAgIHNlbGYuYXNzZXJ0RXF1YWwoci5zdGF0dXMsIDIwMCkKCgppZiBfX25hbWVfXyA9PSAnX19tYWluX18nOgogICAgdW5pdHRlc3QubWFpbigpCg==
