statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/shaasigma/2.0.0/shaasigma-2.0.0/shaasigma-2.0.0/shaasigma/modern.py
  contents:
  - name: <module>
    score: 0.0
    code: |-
      # ISO calendar and Internet time

      # Copyright (c) 2013-2022 Francesco Ricciardi
      #
      # All rights reserved.
      #
      # Redistribution and use in source and binary forms, with or without
      # modification, are permitted provided that the following conditions are met:
      #
      # * Redistributions of source code must retain the above copyright notice,
      #   this list of conditions and the following disclaimer.
      # * Redistributions in binary form must reproduce the above copyright notice,
      #   this list of conditions and the following disclaimer in the documentation
      #   and/or other materials provided with the distribution.
      # * Neither the name(s) of the copyright holders nor the names of its
      #   contributors may be used to endorse or promote products derived from this
      #   software without specific prior written permission.
      #
      # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AS IS AND ANY EXPRESS OR
      # IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
      # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
      # EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DIRECT, INDIRECT,
      # INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
      # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
      # OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
      # LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      # NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
      # EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

      __author__ = "Francesco Ricciardi <francescor2010 at yahoo.it>"


      __all__ = ["IsoCalendar"]


      import bisect
      from fractions import Fraction
      from math import floor

      from datetime2 import verify_fractional_value

      _long_years = frozenset(
          [
              4,
              9,
              15,
              20,
              26,
              32,
              37,
              43,
              48,
              54,
              60,
              65,
              71,
              76,
              82,
              88,
              93,
              99,
              105,
              111,
              116,
              122,
              128,
              133,
              139,
              144,
              150,
              156,
              161,
              167,
              172,
              178,
              184,
              189,
              195,
              201,
              207,
              212,
              218,
              224,
              229,
              235,
              240,
              246,
              252,
              257,
              263,
              268,
              274,
              280,
              285,
              291,
              296,
              303,
              308,
              314,
              320,
              325,
              331,
              336,
              342,
              348,
              353,
              359,
              364,
              370,
              376,
              381,
              387,
              392,
              398,
          ]
      )

      _weeks_in_previous_years = [0]
      for year_index in range(1, 400):
          _weeks_in_previous_years.append(_weeks_in_previous_years[-1] + (52 if year_index not in _long_years else 53))


      # This code pretty prints the week-in-previous-years list
      # for row in range (20):
      #    print('{:3d}: {}'.format(row * 20, " ".join(['{:5d}'.format(_weeks_in_previous_years[y + row * 20]) for y in range(20)])))


      ##############################################################################
      # Iso calendar
      #
      class IsoCalendar:
          def __init__(self, year, week, day):
              if not isinstance(year, int) or not isinstance(week, int) or not isinstance(day, int):
                  raise TypeError("integer argument expected")
              if week < 1 or week > IsoCalendar.weeks_in_year(year):
                  raise ValueError(f"Week must be between 1 and number of weeks in year, while it is {week}.")
              if day < 1 or day > 7:
                  raise ValueError(f"Day must be between 1 and 7, while it is {day}.")
              self._year = year
              self._week = week
              self._day = day
              self._rata_die = None

          @property
          def year(self):
              return self._year

          @property
          def week(self):
              return self._week

          @property
          def day(self):
              return self._day

          @classmethod
          def from_rata_die(cls, day_count):
              if not isinstance(day_count, int):
                  raise TypeError("integer argument expected")
              week_no_less_1, day_less_1 = divmod(day_count - 1, 7)  # ranges: week_no_less_1: free, day_less_1: 0..6
              four_hundred_years, no_of_weeks_in_400 = divmod(week_no_less_1, 20871)  # ranges: four_hundred_years: free, no_of_weeks_in_400: 0..20870
              year_in_400 = bisect.bisect_right(_weeks_in_previous_years, no_of_weeks_in_400)  # range: year_in_400: 1..400
              year = year_in_400 + four_hundred_years * 400
              week = no_of_weeks_in_400 - _weeks_in_previous_years[year_in_400 - 1] + 1
              day = day_less_1 + 1
              iso_day = cls(year, week, day)
              iso_day._rata_die = day_count
              return iso_day

          @staticmethod
          def is_long_year(year):
              return year % 400 in _long_years

          @staticmethod
          def weeks_in_year(year):
              return 52 if year % 400 not in _long_years else 53

          def to_rata_die(self):
              if self._rata_die is None:
                  y400, year_in_400 = divmod(self.year - 1, 400)
                  self._rata_die = (y400 * 146097 + 7 * (_weeks_in_previous_years[year_in_400] + self.week - 1) + self.day)
              return self._rata_die

          def day_of_year(self):
              return 7 * (self.week - 1) + self.day

          def replace(self, *, year=None, week=None, day=None):
              if year is None:
                  year = self.year
              if week is None:
                  week = self.week
              if day is None:
                  day = self.day
              return type(self)(year, week, day)

          def __repr__(self):
              return f"datetime2.modern.{type(self).__name__}({self.year}, {self.week}, {self.day})"

          def __str__(self):
              if self.year >= 0:
                  return f"{self.year:04d}-W{self.week:02d}-{self.day:1d}"
              else:
                  return f"{self.year:05d}-W{self.week:02d}-{self.day:1d}"

          name_weekdays = [
              "Monday",
              "Tuesday",
              "Wednesday",
              "Thursday",
              "Friday",
              "Saturday",
              "Sunday",
          ]

          format_functions = {
              "a": lambda self: IsoCalendar.name_weekdays[self.day - 1][:3],
              "A": lambda self: IsoCalendar.name_weekdays[self.day - 1],
              "j": lambda self: f"{self.day_of_year():03d}",
              "w": lambda self: f"{self.day:1d}",
              "W": lambda self: f"{(self.day_of_year() + 7 - self.day) // 7:02d}",
              "y": lambda self: f"{self.year:03d}"[-2:],
              "Y": lambda self: f"{self.year:04d}" if self.year >= 0 else f"-{-self.year:04d}"
          }

          def cformat(self, format_string):
              if not isinstance(format_string, str):
                  raise TypeError("Format must be specified with string.")
              output_pieces = []
              for format_chunk in format_string.split("%%"):
                  format_parts = format_chunk.split("%")
                  chunk_pieces = [format_parts[0]]
                  for part in format_parts[1:]:
                      if part == "":  # special case: last char is '%'
                          value = "%"
                      else:
                          try:
                              value = self.format_functions[part[0]](self)
                          except KeyError:
                              value = "%" + part[0]
                      chunk_pieces.append(value)
                      chunk_pieces.append(part[1:])
                  output_pieces.append("".join(chunk_pieces))
              return "%".join(output_pieces)
    tokens: resume load_const STRING_LEN_S_ENT_HIGH store_name __author__ load_const IsoCalendar build_list store_name __all__ load_const INTEGER load_const import_name bisect store_name bisect load_const INTEGER load_const import_name fractions import_from Fraction store_name Fraction pop_top load_const INTEGER load_const import_name math import_from floor store_name floor pop_top load_const INTEGER load_const import_name datetime2 import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top push_null load_name frozenset build_list load_const list_extend call store_name _long_years load_const INTEGER build_list store_name STRING_LEN_S_ENT_HIGH push_null load_name range load_const INTEGER load_const INTEGER call get_iter for_iter TO_NUMBER store_name year_index load_name STRING_LEN_S_ENT_HIGH load_attr append load_name STRING_LEN_S_ENT_HIGH load_const INTEGER binary_subscr load_name year_index load_name _long_years contains_op pop_jump_if_false TO_NUMBER load_const INTEGER jump_forward TO_NUMBER load_const INTEGER binary_op + call pop_top jump_backward TO_NUMBER end_for push_null load_build_class load_const OBJECT make_function load_const IsoCalendar call store_name IsoCalendar push_null load_build_class load_const OBJECT make_function load_const InternetTime call store_name InternetTime return_const None
    hash: 39b32374df1ba11220d746450d5404417a06f88d04c5067f606c45f6ab12beff
sources:
  .repo_cache/malicious_repos/pypi_malregistry/shaasigma/2.0.0/shaasigma-2.0.0/shaasigma-2.0.0/shaasigma/modern.py: IyBJU08gY2FsZW5kYXIgYW5kIEludGVybmV0IHRpbWUKCiMgQ29weXJpZ2h0IChjKSAyMDEzLTIwMjIgRnJhbmNlc2NvIFJpY2NpYXJkaQojCiMgQWxsIHJpZ2h0cyByZXNlcnZlZC4KIwojIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dAojIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OgojCiMgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsCiMgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLgojICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLAojICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbgojICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uCiMgKiBOZWl0aGVyIHRoZSBuYW1lKHMpIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVycyBub3IgdGhlIG5hbWVzIG9mIGl0cwojICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcwojICAgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uCiMKIyBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBUyBJUyBBTkQgQU5ZIEVYUFJFU1MgT1IKIyBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GCiMgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8KIyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwKIyBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UCiMgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsCiMgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRgojIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HCiMgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLAojIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuCgpfX2F1dGhvcl9fID0gIkZyYW5jZXNjbyBSaWNjaWFyZGkgPGZyYW5jZXNjb3IyMDEwIGF0IHlhaG9vLml0PiIKCgpfX2FsbF9fID0gWyJJc29DYWxlbmRhciJdCgoKaW1wb3J0IGJpc2VjdApmcm9tIGZyYWN0aW9ucyBpbXBvcnQgRnJhY3Rpb24KZnJvbSBtYXRoIGltcG9ydCBmbG9vcgoKZnJvbSBkYXRldGltZTIgaW1wb3J0IHZlcmlmeV9mcmFjdGlvbmFsX3ZhbHVlCgpfbG9uZ195ZWFycyA9IGZyb3plbnNldCgKICAgIFsKICAgICAgICA0LAogICAgICAgIDksCiAgICAgICAgMTUsCiAgICAgICAgMjAsCiAgICAgICAgMjYsCiAgICAgICAgMzIsCiAgICAgICAgMzcsCiAgICAgICAgNDMsCiAgICAgICAgNDgsCiAgICAgICAgNTQsCiAgICAgICAgNjAsCiAgICAgICAgNjUsCiAgICAgICAgNzEsCiAgICAgICAgNzYsCiAgICAgICAgODIsCiAgICAgICAgODgsCiAgICAgICAgOTMsCiAgICAgICAgOTksCiAgICAgICAgMTA1LAogICAgICAgIDExMSwKICAgICAgICAxMTYsCiAgICAgICAgMTIyLAogICAgICAgIDEyOCwKICAgICAgICAxMzMsCiAgICAgICAgMTM5LAogICAgICAgIDE0NCwKICAgICAgICAxNTAsCiAgICAgICAgMTU2LAogICAgICAgIDE2MSwKICAgICAgICAxNjcsCiAgICAgICAgMTcyLAogICAgICAgIDE3OCwKICAgICAgICAxODQsCiAgICAgICAgMTg5LAogICAgICAgIDE5NSwKICAgICAgICAyMDEsCiAgICAgICAgMjA3LAogICAgICAgIDIxMiwKICAgICAgICAyMTgsCiAgICAgICAgMjI0LAogICAgICAgIDIyOSwKICAgICAgICAyMzUsCiAgICAgICAgMjQwLAogICAgICAgIDI0NiwKICAgICAgICAyNTIsCiAgICAgICAgMjU3LAogICAgICAgIDI2MywKICAgICAgICAyNjgsCiAgICAgICAgMjc0LAogICAgICAgIDI4MCwKICAgICAgICAyODUsCiAgICAgICAgMjkxLAogICAgICAgIDI5NiwKICAgICAgICAzMDMsCiAgICAgICAgMzA4LAogICAgICAgIDMxNCwKICAgICAgICAzMjAsCiAgICAgICAgMzI1LAogICAgICAgIDMzMSwKICAgICAgICAzMzYsCiAgICAgICAgMzQyLAogICAgICAgIDM0OCwKICAgICAgICAzNTMsCiAgICAgICAgMzU5LAogICAgICAgIDM2NCwKICAgICAgICAzNzAsCiAgICAgICAgMzc2LAogICAgICAgIDM4MSwKICAgICAgICAzODcsCiAgICAgICAgMzkyLAogICAgICAgIDM5OCwKICAgIF0KKQoKX3dlZWtzX2luX3ByZXZpb3VzX3llYXJzID0gWzBdCmZvciB5ZWFyX2luZGV4IGluIHJhbmdlKDEsIDQwMCk6CiAgICBfd2Vla3NfaW5fcHJldmlvdXNfeWVhcnMuYXBwZW5kKF93ZWVrc19pbl9wcmV2aW91c195ZWFyc1stMV0gKyAoNTIgaWYgeWVhcl9pbmRleCBub3QgaW4gX2xvbmdfeWVhcnMgZWxzZSA1MykpCgoKIyBUaGlzIGNvZGUgcHJldHR5IHByaW50cyB0aGUgd2Vlay1pbi1wcmV2aW91cy15ZWFycyBsaXN0CiMgZm9yIHJvdyBpbiByYW5nZSAoMjApOgojICAgIHByaW50KCd7OjNkfToge30nLmZvcm1hdChyb3cgKiAyMCwgIiAiLmpvaW4oWyd7OjVkfScuZm9ybWF0KF93ZWVrc19pbl9wcmV2aW91c195ZWFyc1t5ICsgcm93ICogMjBdKSBmb3IgeSBpbiByYW5nZSgyMCldKSkpCgoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMgSXNvIGNhbGVuZGFyCiMKY2xhc3MgSXNvQ2FsZW5kYXI6CiAgICBkZWYgX19pbml0X18oc2VsZiwgeWVhciwgd2VlaywgZGF5KToKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZSh5ZWFyLCBpbnQpIG9yIG5vdCBpc2luc3RhbmNlKHdlZWssIGludCkgb3Igbm90IGlzaW5zdGFuY2UoZGF5LCBpbnQpOgogICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoImludGVnZXIgYXJndW1lbnQgZXhwZWN0ZWQiKQogICAgICAgIGlmIHdlZWsgPCAxIG9yIHdlZWsgPiBJc29DYWxlbmRhci53ZWVrc19pbl95ZWFyKHllYXIpOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKGYiV2VlayBtdXN0IGJlIGJldHdlZW4gMSBhbmQgbnVtYmVyIG9mIHdlZWtzIGluIHllYXIsIHdoaWxlIGl0IGlzIHt3ZWVrfS4iKQogICAgICAgIGlmIGRheSA8IDEgb3IgZGF5ID4gNzoKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcihmIkRheSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNywgd2hpbGUgaXQgaXMge2RheX0uIikKICAgICAgICBzZWxmLl95ZWFyID0geWVhcgogICAgICAgIHNlbGYuX3dlZWsgPSB3ZWVrCiAgICAgICAgc2VsZi5fZGF5ID0gZGF5CiAgICAgICAgc2VsZi5fcmF0YV9kaWUgPSBOb25lCgogICAgQHByb3BlcnR5CiAgICBkZWYgeWVhcihzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5feWVhcgoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHdlZWsoc2VsZik6CiAgICAgICAgcmV0dXJuIHNlbGYuX3dlZWsKCiAgICBAcHJvcGVydHkKICAgIGRlZiBkYXkoc2VsZik6CiAgICAgICAgcmV0dXJuIHNlbGYuX2RheQoKICAgIEBjbGFzc21ldGhvZAogICAgZGVmIGZyb21fcmF0YV9kaWUoY2xzLCBkYXlfY291bnQpOgogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRheV9jb3VudCwgaW50KToKICAgICAgICAgICAgcmFpc2UgVHlwZUVycm9yKCJpbnRlZ2VyIGFyZ3VtZW50IGV4cGVjdGVkIikKICAgICAgICB3ZWVrX25vX2xlc3NfMSwgZGF5X2xlc3NfMSA9IGRpdm1vZChkYXlfY291bnQgLSAxLCA3KSAgIyByYW5nZXM6IHdlZWtfbm9fbGVzc18xOiBmcmVlLCBkYXlfbGVzc18xOiAwLi42CiAgICAgICAgZm91cl9odW5kcmVkX3llYXJzLCBub19vZl93ZWVrc19pbl80MDAgPSBkaXZtb2Qod2Vla19ub19sZXNzXzEsIDIwODcxKSAgIyByYW5nZXM6IGZvdXJfaHVuZHJlZF95ZWFyczogZnJlZSwgbm9fb2Zfd2Vla3NfaW5fNDAwOiAwLi4yMDg3MAogICAgICAgIHllYXJfaW5fNDAwID0gYmlzZWN0LmJpc2VjdF9yaWdodChfd2Vla3NfaW5fcHJldmlvdXNfeWVhcnMsIG5vX29mX3dlZWtzX2luXzQwMCkgICMgcmFuZ2U6IHllYXJfaW5fNDAwOiAxLi40MDAKICAgICAgICB5ZWFyID0geWVhcl9pbl80MDAgKyBmb3VyX2h1bmRyZWRfeWVhcnMgKiA0MDAKICAgICAgICB3ZWVrID0gbm9fb2Zfd2Vla3NfaW5fNDAwIC0gX3dlZWtzX2luX3ByZXZpb3VzX3llYXJzW3llYXJfaW5fNDAwIC0gMV0gKyAxCiAgICAgICAgZGF5ID0gZGF5X2xlc3NfMSArIDEKICAgICAgICBpc29fZGF5ID0gY2xzKHllYXIsIHdlZWssIGRheSkKICAgICAgICBpc29fZGF5Ll9yYXRhX2RpZSA9IGRheV9jb3VudAogICAgICAgIHJldHVybiBpc29fZGF5CgogICAgQHN0YXRpY21ldGhvZAogICAgZGVmIGlzX2xvbmdfeWVhcih5ZWFyKToKICAgICAgICByZXR1cm4geWVhciAlIDQwMCBpbiBfbG9uZ195ZWFycwoKICAgIEBzdGF0aWNtZXRob2QKICAgIGRlZiB3ZWVrc19pbl95ZWFyKHllYXIpOgogICAgICAgIHJldHVybiA1MiBpZiB5ZWFyICUgNDAwIG5vdCBpbiBfbG9uZ195ZWFycyBlbHNlIDUzCgogICAgZGVmIHRvX3JhdGFfZGllKHNlbGYpOgogICAgICAgIGlmIHNlbGYuX3JhdGFfZGllIGlzIE5vbmU6CiAgICAgICAgICAgIHk0MDAsIHllYXJfaW5fNDAwID0gZGl2bW9kKHNlbGYueWVhciAtIDEsIDQwMCkKICAgICAgICAgICAgc2VsZi5fcmF0YV9kaWUgPSAoeTQwMCAqIDE0NjA5NyArIDcgKiAoX3dlZWtzX2luX3ByZXZpb3VzX3llYXJzW3llYXJfaW5fNDAwXSArIHNlbGYud2VlayAtIDEpICsgc2VsZi5kYXkpCiAgICAgICAgcmV0dXJuIHNlbGYuX3JhdGFfZGllCgogICAgZGVmIGRheV9vZl95ZWFyKHNlbGYpOgogICAgICAgIHJldHVybiA3ICogKHNlbGYud2VlayAtIDEpICsgc2VsZi5kYXkKCiAgICBkZWYgcmVwbGFjZShzZWxmLCAqLCB5ZWFyPU5vbmUsIHdlZWs9Tm9uZSwgZGF5PU5vbmUpOgogICAgICAgIGlmIHllYXIgaXMgTm9uZToKICAgICAgICAgICAgeWVhciA9IHNlbGYueWVhcgogICAgICAgIGlmIHdlZWsgaXMgTm9uZToKICAgICAgICAgICAgd2VlayA9IHNlbGYud2VlawogICAgICAgIGlmIGRheSBpcyBOb25lOgogICAgICAgICAgICBkYXkgPSBzZWxmLmRheQogICAgICAgIHJldHVybiB0eXBlKHNlbGYpKHllYXIsIHdlZWssIGRheSkKCiAgICBkZWYgX19yZXByX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiZGF0ZXRpbWUyLm1vZGVybi57dHlwZShzZWxmKS5fX25hbWVfX30oe3NlbGYueWVhcn0sIHtzZWxmLndlZWt9LCB7c2VsZi5kYXl9KSIKCiAgICBkZWYgX19zdHJfXyhzZWxmKToKICAgICAgICBpZiBzZWxmLnllYXIgPj0gMDoKICAgICAgICAgICAgcmV0dXJuIGYie3NlbGYueWVhcjowNGR9LVd7c2VsZi53ZWVrOjAyZH0te3NlbGYuZGF5OjFkfSIKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXR1cm4gZiJ7c2VsZi55ZWFyOjA1ZH0tV3tzZWxmLndlZWs6MDJkfS17c2VsZi5kYXk6MWR9IgoKICAgIG5hbWVfd2Vla2RheXMgPSBbCiAgICAgICAgIk1vbmRheSIsCiAgICAgICAgIlR1ZXNkYXkiLAogICAgICAgICJXZWRuZXNkYXkiLAogICAgICAgICJUaHVyc2RheSIsCiAgICAgICAgIkZyaWRheSIsCiAgICAgICAgIlNhdHVyZGF5IiwKICAgICAgICAiU3VuZGF5IiwKICAgIF0KCiAgICBmb3JtYXRfZnVuY3Rpb25zID0gewogICAgICAgICJhIjogbGFtYmRhIHNlbGY6IElzb0NhbGVuZGFyLm5hbWVfd2Vla2RheXNbc2VsZi5kYXkgLSAxXVs6M10sCiAgICAgICAgIkEiOiBsYW1iZGEgc2VsZjogSXNvQ2FsZW5kYXIubmFtZV93ZWVrZGF5c1tzZWxmLmRheSAtIDFdLAogICAgICAgICJqIjogbGFtYmRhIHNlbGY6IGYie3NlbGYuZGF5X29mX3llYXIoKTowM2R9IiwKICAgICAgICAidyI6IGxhbWJkYSBzZWxmOiBmIntzZWxmLmRheToxZH0iLAogICAgICAgICJXIjogbGFtYmRhIHNlbGY6IGYieyhzZWxmLmRheV9vZl95ZWFyKCkgKyA3IC0gc2VsZi5kYXkpIC8vIDc6MDJkfSIsCiAgICAgICAgInkiOiBsYW1iZGEgc2VsZjogZiJ7c2VsZi55ZWFyOjAzZH0iWy0yOl0sCiAgICAgICAgIlkiOiBsYW1iZGEgc2VsZjogZiJ7c2VsZi55ZWFyOjA0ZH0iIGlmIHNlbGYueWVhciA+PSAwIGVsc2UgZiItey1zZWxmLnllYXI6MDRkfSIKICAgIH0KCiAgICBkZWYgY2Zvcm1hdChzZWxmLCBmb3JtYXRfc3RyaW5nKToKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShmb3JtYXRfc3RyaW5nLCBzdHIpOgogICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoIkZvcm1hdCBtdXN0IGJlIHNwZWNpZmllZCB3aXRoIHN0cmluZy4iKQogICAgICAgIG91dHB1dF9waWVjZXMgPSBbXQogICAgICAgIGZvciBmb3JtYXRfY2h1bmsgaW4gZm9ybWF0X3N0cmluZy5zcGxpdCgiJSUiKToKICAgICAgICAgICAgZm9ybWF0X3BhcnRzID0gZm9ybWF0X2NodW5rLnNwbGl0KCIlIikKICAgICAgICAgICAgY2h1bmtfcGllY2VzID0gW2Zvcm1hdF9wYXJ0c1swXV0KICAgICAgICAgICAgZm9yIHBhcnQgaW4gZm9ybWF0X3BhcnRzWzE6XToKICAgICAgICAgICAgICAgIGlmIHBhcnQgPT0gIiI6ICAjIHNwZWNpYWwgY2FzZTogbGFzdCBjaGFyIGlzICclJwogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gIiUiCiAgICAgICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWxmLmZvcm1hdF9mdW5jdGlvbnNbcGFydFswXV0oc2VsZikKICAgICAgICAgICAgICAgICAgICBleGNlcHQgS2V5RXJyb3I6CiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gIiUiICsgcGFydFswXQogICAgICAgICAgICAgICAgY2h1bmtfcGllY2VzLmFwcGVuZCh2YWx1ZSkKICAgICAgICAgICAgICAgIGNodW5rX3BpZWNlcy5hcHBlbmQocGFydFsxOl0pCiAgICAgICAgICAgIG91dHB1dF9waWVjZXMuYXBwZW5kKCIiLmpvaW4oY2h1bmtfcGllY2VzKSkKICAgICAgICByZXR1cm4gIiUiLmpvaW4ob3V0cHV0X3BpZWNlcykKCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIyBJbnRlcm5ldCB0aW1lIHJlcHJlc2VudGF0aW9uCiMKY2xhc3MgSW50ZXJuZXRUaW1lOgogICAgZGVmIF9faW5pdF9fKHNlbGYsIGJlYXQpOgogICAgICAgIHRyeToKICAgICAgICAgICAgYmVhdF9mcmFjdGlvbiA9IHZlcmlmeV9mcmFjdGlvbmFsX3ZhbHVlKGJlYXQsIG1pbj0wLCBtYXhfZXhjbD0xMDAwKQogICAgICAgIGV4Y2VwdCBUeXBlRXJyb3IgYXMgZXhjOgogICAgICAgICAgICByYWlzZSBUeXBlRXJyb3IoImJlYXQgaXMgbm90IGEgdmFsaWQgZnJhY3Rpb25hbCB2YWx1ZSIpIGZyb20gZXhjCiAgICAgICAgZXhjZXB0IFZhbHVlRXJyb3IgYXMgZXhjOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKCJiZWF0IG11c3QgYmUgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxMDAwLiIpIGZyb20gZXhjCiAgICAgICAgc2VsZi5fYmVhdCA9IGJlYXRfZnJhY3Rpb24KCiAgICBAcHJvcGVydHkKICAgIGRlZiBiZWF0KHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLl9iZWF0CgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgZnJvbV90aW1lX3BhaXIoY2xzLCBkYXlfZnJhYywgdXRjb2Zmc2V0KToKICAgICAgICBkYXlfZnJhY192YWxpZCA9IHZlcmlmeV9mcmFjdGlvbmFsX3ZhbHVlKGRheV9mcmFjLCBtaW49MCwgbWF4X2V4Y2w9MSwgc3RyaWN0PVRydWUpCiAgICAgICAgaWYgdXRjb2Zmc2V0IGlzIE5vbmU6CiAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcigiSW50ZXJuZXQgdGltZSBjYW4gb25seSBiZSB1c2VkIGZvciBhd2FyZSBUaW1lIGluc3RhbmNlcy4iKQogICAgICAgIHV0Y29mZnNldF92YWxpZCA9IHZlcmlmeV9mcmFjdGlvbmFsX3ZhbHVlKHV0Y29mZnNldCwgbWluPS0xLCBtYXg9MSwgc3RyaWN0PVRydWUpCiAgICAgICAgdXRjX3RpbWUgPSBkYXlfZnJhY192YWxpZCAtIHV0Y29mZnNldF92YWxpZAogICAgICAgIGJlYXQgPSAodXRjX3RpbWUgLSBmbG9vcih1dGNfdGltZSkpICogMTAwMAogICAgICAgIGludGVybmV0ID0gY2xzKGJlYXQpCiAgICAgICAgcmV0dXJuIGludGVybmV0CgogICAgZGVmIHRvX3RpbWVfcGFpcihzZWxmKToKICAgICAgICByZXR1cm4gc2VsZi5fYmVhdCAvIDEwMDAsIEZyYWN0aW9uKC0xLCAyNCkKCiAgICBkZWYgX19yZXByX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiZGF0ZXRpbWUyLm1vZGVybi57dHlwZShzZWxmKS5fX25hbWVfX30oe3NlbGYuYmVhdCFyfSkiCgogICAgZGVmIF9fc3RyX18oc2VsZik6CiAgICAgICAgcmV0dXJuIGYiQHtpbnQoc2VsZi5iZWF0KTowM2R9IgoKICAgIGZvcm1hdF9mdW5jdGlvbnMgPSB7CiAgICAgICAgImIiOiBsYW1iZGEgc2VsZjogZiJ7aW50KHNlbGYuYmVhdCk6MDNkfSIsCiAgICAgICAgImYiOiBsYW1iZGEgc2VsZjogZiJ7aW50KChzZWxmLmJlYXQgLSBpbnQoc2VsZi5iZWF0KSkgKiAxMDAwKTowM2R9IgogICAgfQoKICAgIGRlZiBjZm9ybWF0KHNlbGYsIGZvcm1hdF9zdHJpbmcpOgogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGZvcm1hdF9zdHJpbmcsIHN0cik6CiAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvcigiRm9ybWF0IG11c3QgYmUgc3BlY2lmaWVkIHdpdGggc3RyaW5nLiIpCiAgICAgICAgb3V0cHV0X3BpZWNlcyA9IFtdCiAgICAgICAgZm9yIGZvcm1hdF9jaHVuayBpbiBmb3JtYXRfc3RyaW5nLnNwbGl0KCIlJSIpOgogICAgICAgICAgICBmb3JtYXRfcGFydHMgPSBmb3JtYXRfY2h1bmsuc3BsaXQoIiUiKQogICAgICAgICAgICBjaHVua19waWVjZXMgPSBbZm9ybWF0X3BhcnRzWzBdXQogICAgICAgICAgICBmb3IgcGFydCBpbiBmb3JtYXRfcGFydHNbMTpdOgogICAgICAgICAgICAgICAgaWYgcGFydCA9PSAiIjogICMgc3BlY2lhbCBjYXNlOiBsYXN0IGNoYXIgaXMgJyUnCiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAiJSIKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlbGYuZm9ybWF0X2Z1bmN0aW9uc1twYXJ0WzBdXShzZWxmKQogICAgICAgICAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAiJSIgKyBwYXJ0WzBdCiAgICAgICAgICAgICAgICBjaHVua19waWVjZXMuYXBwZW5kKHZhbHVlKQogICAgICAgICAgICAgICAgY2h1bmtfcGllY2VzLmFwcGVuZChwYXJ0WzE6XSkKICAgICAgICAgICAgb3V0cHV0X3BpZWNlcy5hcHBlbmQoIiIuam9pbihjaHVua19waWVjZXMpKQogICAgICAgIHJldHVybiAiJSIuam9pbihvdXRwdXRfcGllY2VzKQo=
