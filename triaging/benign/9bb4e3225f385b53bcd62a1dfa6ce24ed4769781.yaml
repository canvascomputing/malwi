statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/python-aliyun-sdk-core/2.13.36/python-aliyun-sdk-core-2.13.36/python-aliyun-sdk-core-2.13.36/aliyunsdkcore/vendored/requests/packages/urllib3/util/ssl_.py
  contents:
  - name: create_urllib3_context
    score: 0.0
    code: |-
      def create_urllib3_context(ssl_version=None, cert_reqs=None,
                                 options=None, ciphers=None):
          """All arguments have the same meaning as ``ssl_wrap_socket``.

          By default, this function does a lot of the same work that
          ``ssl.create_default_context`` does on Python 3.4+. It:

          - Disables SSLv2, SSLv3, and compression
          - Sets a restricted set of server ciphers

          If you wish to enable SSLv3, you can do::

              from urllib3.util import ssl_
              context = ssl_.create_urllib3_context()
              context.options &= ~ssl_.OP_NO_SSLv3

          You can do the same to enable compression (substituting ``COMPRESSION``
          for ``SSLv3`` in the last line above).

          :param ssl_version:
              The desired protocol version to use. This will default to
              PROTOCOL_SSLv23 which will negotiate the highest protocol that both
              the server and your installation of OpenSSL support.
          :param cert_reqs:
              Whether to require the certificate verification. This defaults to
              ``ssl.CERT_REQUIRED``.
          :param options:
              Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
              ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.
          :param ciphers:
              Which cipher suites to allow the server to select.
          :returns:
              Constructed SSLContext object with specified options
          :rtype: SSLContext
          """
          context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)

          context.set_ciphers(ciphers or DEFAULT_CIPHERS)

          # Setting the default here, as we may have no ssl module on import
          cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

          if options is None:
              options = 0
              # SSLv2 is easily broken and is considered harmful and dangerous
              options |= OP_NO_SSLv2
              # SSLv3 has several problems and is now dangerous
              options |= OP_NO_SSLv3
              # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
              # (issue #309)
              options |= OP_NO_COMPRESSION

          context.options |= options

          context.verify_mode = cert_reqs
          if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2
              # We do our own verification, including fingerprints and alternative
              # hostnames. So disable it here
              context.check_hostname = False
          return context
    tokens: resume load_global SSLContext load_fast ssl_version copy pop_jump_if_true TO_NUMBER pop_top load_global ssl load_attr PROTOCOL_SSLv23 call store_fast context load_fast context load_attr set_ciphers load_fast ciphers copy pop_jump_if_true TO_NUMBER pop_top load_global DEFAULT_CIPHERS call pop_top load_fast cert_reqs pop_jump_if_not_none TO_NUMBER load_global ssl load_attr CERT_REQUIRED jump_forward TO_NUMBER load_fast cert_reqs store_fast cert_reqs load_fast options pop_jump_if_not_none TO_NUMBER load_const INTEGER store_fast options load_fast options load_global OP_NO_SSLv2 binary_op |= store_fast options load_fast options load_global OP_NO_SSLv3 binary_op |= store_fast options load_fast options load_global STRING_LEN_S_ENT_HIGH binary_op |= store_fast options load_fast context copy load_attr options load_fast options binary_op |= swap store_attr options load_fast cert_reqs load_fast context store_attr verify_mode load_global REFLECTION_DYNAMIC_READ load_fast context load_const check_hostname load_const call pop_jump_if_none TO_NUMBER load_const INTEGER load_fast context store_attr check_hostname load_fast context return_value
    hash: 692681140b722cc47260122cb9d5c82945eae74d0a871db2ac3913e64b349716
sources:
  ? .repo_cache/malicious_repos/pypi_malregistry/python-aliyun-sdk-core/2.13.36/python-aliyun-sdk-core-2.13.36/python-aliyun-sdk-core-2.13.36/aliyunsdkcore/vendored/requests/packages/urllib3/util/ssl_.py
  : ZnJvbSBfX2Z1dHVyZV9fIGltcG9ydCBhYnNvbHV0ZV9pbXBvcnQKaW1wb3J0IGVycm5vCmltcG9ydCB3YXJuaW5ncwppbXBvcnQgaG1hYwppbXBvcnQgc29ja2V0Cgpmcm9tIGJpbmFzY2lpIGltcG9ydCBoZXhsaWZ5LCB1bmhleGxpZnkKZnJvbSBoYXNobGliIGltcG9ydCBtZDUsIHNoYTEsIHNoYTI1NgoKZnJvbSAuLmV4Y2VwdGlvbnMgaW1wb3J0IFNTTEVycm9yLCBJbnNlY3VyZVBsYXRmb3JtV2FybmluZywgU05JTWlzc2luZ1dhcm5pbmcKZnJvbSAuLnBhY2thZ2VzIGltcG9ydCBzaXgKCgpTU0xDb250ZXh0ID0gTm9uZQpIQVNfU05JID0gRmFsc2UKSVNfUFlPUEVOU1NMID0gRmFsc2UKSVNfU0VDVVJFVFJBTlNQT1JUID0gRmFsc2UKCiMgTWFwcyB0aGUgbGVuZ3RoIG9mIGEgZGlnZXN0IHRvIGEgcG9zc2libGUgaGFzaCBmdW5jdGlvbiBwcm9kdWNpbmcgdGhpcyBkaWdlc3QKSEFTSEZVTkNfTUFQID0gewogICAgMzI6IG1kNSwKICAgIDQwOiBzaGExLAogICAgNjQ6IHNoYTI1NiwKfQoKCmRlZiBfY29uc3RfY29tcGFyZV9kaWdlc3RfYmFja3BvcnQoYSwgYik6CiAgICAiIiIKICAgIENvbXBhcmUgdHdvIGRpZ2VzdHMgb2YgZXF1YWwgbGVuZ3RoIGluIGNvbnN0YW50IHRpbWUuCgogICAgVGhlIGRpZ2VzdHMgbXVzdCBiZSBvZiB0eXBlIHN0ci9ieXRlcy4KICAgIFJldHVybnMgVHJ1ZSBpZiB0aGUgZGlnZXN0cyBtYXRjaCwgYW5kIEZhbHNlIG90aGVyd2lzZS4KICAgICIiIgogICAgcmVzdWx0ID0gYWJzKGxlbihhKSAtIGxlbihiKSkKICAgIGZvciBsLCByIGluIHppcChieXRlYXJyYXkoYSksIGJ5dGVhcnJheShiKSk6CiAgICAgICAgcmVzdWx0IHw9IGwgXiByCiAgICByZXR1cm4gcmVzdWx0ID09IDAKCgpfY29uc3RfY29tcGFyZV9kaWdlc3QgPSBnZXRhdHRyKGhtYWMsICdjb21wYXJlX2RpZ2VzdCcsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnN0X2NvbXBhcmVfZGlnZXN0X2JhY2twb3J0KQoKCnRyeTogICMgVGVzdCBmb3IgU1NMIGZlYXR1cmVzCiAgICBpbXBvcnQgc3NsCiAgICBmcm9tIHNzbCBpbXBvcnQgd3JhcF9zb2NrZXQsIENFUlRfTk9ORSwgUFJPVE9DT0xfU1NMdjIzCiAgICBmcm9tIHNzbCBpbXBvcnQgSEFTX1NOSSAgIyBIYXMgU05JPwpleGNlcHQgSW1wb3J0RXJyb3I6CiAgICBwYXNzCgoKdHJ5OgogICAgZnJvbSBzc2wgaW1wb3J0IE9QX05PX1NTTHYyLCBPUF9OT19TU0x2MywgT1BfTk9fQ09NUFJFU1NJT04KZXhjZXB0IEltcG9ydEVycm9yOgogICAgT1BfTk9fU1NMdjIsIE9QX05PX1NTTHYzID0gMHgxMDAwMDAwLCAweDIwMDAwMDAKICAgIE9QX05PX0NPTVBSRVNTSU9OID0gMHgyMDAwMAoKCiMgUHl0aG9uIDIuNyBkb2Vzbid0IGhhdmUgaW5ldF9wdG9uIG9uIG5vbi1MaW51eCBzbyB3ZSBmYWxsYmFjayBvbiBpbmV0X2F0b24gaW4KIyB0aG9zZSBjYXNlcy4gVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBvbmx5IGRldGVjdCBJUHY0IGFkZHJlc3NlcyBpbiB0aGlzIGNhc2UuCmlmIGhhc2F0dHIoc29ja2V0LCAnaW5ldF9wdG9uJyk6CiAgICBpbmV0X3B0b24gPSBzb2NrZXQuaW5ldF9wdG9uCmVsc2U6CiAgICAjIE1heWJlIHdlIGNhbiB1c2UgaXBhZGRyZXNzIGlmIHRoZSB1c2VyIGhhcyB1cmxsaWIzW3NlY3VyZV0/CiAgICB0cnk6CiAgICAgICAgaW1wb3J0IGlwYWRkcmVzcwoKICAgICAgICBkZWYgaW5ldF9wdG9uKF8sIGhvc3QpOgogICAgICAgICAgICBpZiBpc2luc3RhbmNlKGhvc3QsIGJ5dGVzKToKICAgICAgICAgICAgICAgIGhvc3QgPSBob3N0LmRlY29kZSgnYXNjaWknKQogICAgICAgICAgICByZXR1cm4gaXBhZGRyZXNzLmlwX2FkZHJlc3MoaG9zdCkKCiAgICBleGNlcHQgSW1wb3J0RXJyb3I6ICAjIFBsYXRmb3JtLXNwZWNpZmljOiBOb24tTGludXgKICAgICAgICBkZWYgaW5ldF9wdG9uKF8sIGhvc3QpOgogICAgICAgICAgICByZXR1cm4gc29ja2V0LmluZXRfYXRvbihob3N0KQoKCiMgQSBzZWN1cmUgZGVmYXVsdC4KIyBTb3VyY2VzIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIFRMUyBjaXBoZXJzOgojCiMgLSBodHRwczovL3dpa2kubW96aWxsYS5vcmcvU2VjdXJpdHkvU2VydmVyX1NpZGVfVExTCiMgLSBodHRwczovL3d3dy5zc2xsYWJzLmNvbS9wcm9qZWN0cy9iZXN0LXByYWN0aWNlcy9pbmRleC5odG1sCiMgLSBodHRwczovL2h5bmVrLm1lL2FydGljbGVzL2hhcmRlbmluZy15b3VyLXdlYi1zZXJ2ZXJzLXNzbC1jaXBoZXJzLwojCiMgVGhlIGdlbmVyYWwgaW50ZW50IGlzOgojIC0gUHJlZmVyIFRMUyAxLjMgY2lwaGVyIHN1aXRlcwojIC0gcHJlZmVyIGNpcGhlciBzdWl0ZXMgdGhhdCBvZmZlciBwZXJmZWN0IGZvcndhcmQgc2VjcmVjeSAoREhFL0VDREhFKSwKIyAtIHByZWZlciBFQ0RIRSBvdmVyIERIRSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLAojIC0gcHJlZmVyIGFueSBBRVMtR0NNIGFuZCBDaGFDaGEyMCBvdmVyIGFueSBBRVMtQ0JDIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UgYW5kCiMgICBzZWN1cml0eSwKIyAtIHByZWZlciBBRVMtR0NNIG92ZXIgQ2hhQ2hhMjAgYmVjYXVzZSBoYXJkd2FyZS1hY2NlbGVyYXRlZCBBRVMgaXMgY29tbW9uLAojIC0gZGlzYWJsZSBOVUxMIGF1dGhlbnRpY2F0aW9uLCBNRDUgTUFDcyBhbmQgRFNTIGZvciBzZWN1cml0eSByZWFzb25zLgpERUZBVUxUX0NJUEhFUlMgPSAnOicuam9pbihbCiAgICAnVExTMTMtQUVTLTI1Ni1HQ00tU0hBMzg0JywKICAgICdUTFMxMy1DSEFDSEEyMC1QT0xZMTMwNS1TSEEyNTYnLAogICAgJ1RMUzEzLUFFUy0xMjgtR0NNLVNIQTI1NicsCiAgICAnRUNESCtBRVNHQ00nLAogICAgJ0VDREgrQ0hBQ0hBMjAnLAogICAgJ0RIK0FFU0dDTScsCiAgICAnREgrQ0hBQ0hBMjAnLAogICAgJ0VDREgrQUVTMjU2JywKICAgICdESCtBRVMyNTYnLAogICAgJ0VDREgrQUVTMTI4JywKICAgICdESCtBRVMnLAogICAgJ1JTQStBRVNHQ00nLAogICAgJ1JTQStBRVMnLAogICAgJyFhTlVMTCcsCiAgICAnIWVOVUxMJywKICAgICchTUQ1JywKXSkKCnRyeToKICAgIGZyb20gc3NsIGltcG9ydCBTU0xDb250ZXh0ICAjIE1vZGVybiBTU0w/CmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIGNsYXNzIFNTTENvbnRleHQob2JqZWN0KTogICMgUGxhdGZvcm0tc3BlY2lmaWM6IFB5dGhvbiAyCiAgICAgICAgZGVmIF9faW5pdF9fKHNlbGYsIHByb3RvY29sX3ZlcnNpb24pOgogICAgICAgICAgICBzZWxmLnByb3RvY29sID0gcHJvdG9jb2xfdmVyc2lvbgogICAgICAgICAgICAjIFVzZSBkZWZhdWx0IHZhbHVlcyBmcm9tIGEgcmVhbCBTU0xDb250ZXh0CiAgICAgICAgICAgIHNlbGYuY2hlY2tfaG9zdG5hbWUgPSBGYWxzZQogICAgICAgICAgICBzZWxmLnZlcmlmeV9tb2RlID0gc3NsLkNFUlRfTk9ORQogICAgICAgICAgICBzZWxmLmNhX2NlcnRzID0gTm9uZQogICAgICAgICAgICBzZWxmLm9wdGlvbnMgPSAwCiAgICAgICAgICAgIHNlbGYuY2VydGZpbGUgPSBOb25lCiAgICAgICAgICAgIHNlbGYua2V5ZmlsZSA9IE5vbmUKICAgICAgICAgICAgc2VsZi5jaXBoZXJzID0gTm9uZQoKICAgICAgICBkZWYgbG9hZF9jZXJ0X2NoYWluKHNlbGYsIGNlcnRmaWxlLCBrZXlmaWxlKToKICAgICAgICAgICAgc2VsZi5jZXJ0ZmlsZSA9IGNlcnRmaWxlCiAgICAgICAgICAgIHNlbGYua2V5ZmlsZSA9IGtleWZpbGUKCiAgICAgICAgZGVmIGxvYWRfdmVyaWZ5X2xvY2F0aW9ucyhzZWxmLCBjYWZpbGU9Tm9uZSwgY2FwYXRoPU5vbmUpOgogICAgICAgICAgICBzZWxmLmNhX2NlcnRzID0gY2FmaWxlCgogICAgICAgICAgICBpZiBjYXBhdGggaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICByYWlzZSBTU0xFcnJvcigiQ0EgZGlyZWN0b3JpZXMgbm90IHN1cHBvcnRlZCBpbiBvbGRlciBQeXRob25zIikKCiAgICAgICAgZGVmIHNldF9jaXBoZXJzKHNlbGYsIGNpcGhlcl9zdWl0ZSk6CiAgICAgICAgICAgIHNlbGYuY2lwaGVycyA9IGNpcGhlcl9zdWl0ZQoKICAgICAgICBkZWYgd3JhcF9zb2NrZXQoc2VsZiwgc29ja2V0LCBzZXJ2ZXJfaG9zdG5hbWU9Tm9uZSwgc2VydmVyX3NpZGU9RmFsc2UpOgogICAgICAgICAgICB3YXJuaW5ncy53YXJuKAogICAgICAgICAgICAgICAgJ0EgdHJ1ZSBTU0xDb250ZXh0IG9iamVjdCBpcyBub3QgYXZhaWxhYmxlLiBUaGlzIHByZXZlbnRzICcKICAgICAgICAgICAgICAgICd1cmxsaWIzIGZyb20gY29uZmlndXJpbmcgU1NMIGFwcHJvcHJpYXRlbHkgYW5kIG1heSBjYXVzZSAnCiAgICAgICAgICAgICAgICAnY2VydGFpbiBTU0wgY29ubmVjdGlvbnMgdG8gZmFpbC4gWW91IGNhbiB1cGdyYWRlIHRvIGEgbmV3ZXIgJwogICAgICAgICAgICAgICAgJ3ZlcnNpb24gb2YgUHl0aG9uIHRvIHNvbHZlIHRoaXMuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJwogICAgICAgICAgICAgICAgJ2h0dHBzOi8vdXJsbGliMy5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvYWR2YW5jZWQtdXNhZ2UuaHRtbCcKICAgICAgICAgICAgICAgICcjc3NsLXdhcm5pbmdzJywKICAgICAgICAgICAgICAgIEluc2VjdXJlUGxhdGZvcm1XYXJuaW5nCiAgICAgICAgICAgICkKICAgICAgICAgICAga3dhcmdzID0gewogICAgICAgICAgICAgICAgJ2tleWZpbGUnOiBzZWxmLmtleWZpbGUsCiAgICAgICAgICAgICAgICAnY2VydGZpbGUnOiBzZWxmLmNlcnRmaWxlLAogICAgICAgICAgICAgICAgJ2NhX2NlcnRzJzogc2VsZi5jYV9jZXJ0cywKICAgICAgICAgICAgICAgICdjZXJ0X3JlcXMnOiBzZWxmLnZlcmlmeV9tb2RlLAogICAgICAgICAgICAgICAgJ3NzbF92ZXJzaW9uJzogc2VsZi5wcm90b2NvbCwKICAgICAgICAgICAgICAgICdzZXJ2ZXJfc2lkZSc6IHNlcnZlcl9zaWRlLAogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB3cmFwX3NvY2tldChzb2NrZXQsIGNpcGhlcnM9c2VsZi5jaXBoZXJzLCAqKmt3YXJncykKCgpkZWYgYXNzZXJ0X2ZpbmdlcnByaW50KGNlcnQsIGZpbmdlcnByaW50KToKICAgICIiIgogICAgQ2hlY2tzIGlmIGdpdmVuIGZpbmdlcnByaW50IG1hdGNoZXMgdGhlIHN1cHBsaWVkIGNlcnRpZmljYXRlLgoKICAgIDpwYXJhbSBjZXJ0OgogICAgICAgIENlcnRpZmljYXRlIGFzIGJ5dGVzIG9iamVjdC4KICAgIDpwYXJhbSBmaW5nZXJwcmludDoKICAgICAgICBGaW5nZXJwcmludCBhcyBzdHJpbmcgb2YgaGV4ZGlnaXRzLCBjYW4gYmUgaW50ZXJzcGVyc2VkIGJ5IGNvbG9ucy4KICAgICIiIgoKICAgIGZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQucmVwbGFjZSgnOicsICcnKS5sb3dlcigpCiAgICBkaWdlc3RfbGVuZ3RoID0gbGVuKGZpbmdlcnByaW50KQogICAgaGFzaGZ1bmMgPSBIQVNIRlVOQ19NQVAuZ2V0KGRpZ2VzdF9sZW5ndGgpCiAgICBpZiBub3QgaGFzaGZ1bmM6CiAgICAgICAgcmFpc2UgU1NMRXJyb3IoCiAgICAgICAgICAgICdGaW5nZXJwcmludCBvZiBpbnZhbGlkIGxlbmd0aDogezB9Jy5mb3JtYXQoZmluZ2VycHJpbnQpKQoKICAgICMgV2UgbmVlZCBlbmNvZGUoKSBoZXJlIGZvciBweTMyOyB3b3JrcyBvbiBweTIgYW5kIHAzMy4KICAgIGZpbmdlcnByaW50X2J5dGVzID0gdW5oZXhsaWZ5KGZpbmdlcnByaW50LmVuY29kZSgpKQoKICAgIGNlcnRfZGlnZXN0ID0gaGFzaGZ1bmMoY2VydCkuZGlnZXN0KCkKCiAgICBpZiBub3QgX2NvbnN0X2NvbXBhcmVfZGlnZXN0KGNlcnRfZGlnZXN0LCBmaW5nZXJwcmludF9ieXRlcyk6CiAgICAgICAgcmFpc2UgU1NMRXJyb3IoJ0ZpbmdlcnByaW50cyBkaWQgbm90IG1hdGNoLiBFeHBlY3RlZCAiezB9IiwgZ290ICJ7MX0iLicKICAgICAgICAgICAgICAgICAgICAgICAuZm9ybWF0KGZpbmdlcnByaW50LCBoZXhsaWZ5KGNlcnRfZGlnZXN0KSkpCgoKZGVmIHJlc29sdmVfY2VydF9yZXFzKGNhbmRpZGF0ZSk6CiAgICAiIiIKICAgIFJlc29sdmVzIHRoZSBhcmd1bWVudCB0byBhIG51bWVyaWMgY29uc3RhbnQsIHdoaWNoIGNhbiBiZSBwYXNzZWQgdG8KICAgIHRoZSB3cmFwX3NvY2tldCBmdW5jdGlvbi9tZXRob2QgZnJvbSB0aGUgc3NsIG1vZHVsZS4KICAgIERlZmF1bHRzIHRvIDpkYXRhOmBzc2wuQ0VSVF9OT05FYC4KICAgIElmIGdpdmVuIGEgc3RyaW5nIGl0IGlzIGFzc3VtZWQgdG8gYmUgdGhlIG5hbWUgb2YgdGhlIGNvbnN0YW50IGluIHRoZQogICAgOm1vZDpgc3NsYCBtb2R1bGUgb3IgaXRzIGFiYnJldmlhdGlvbi4KICAgIChTbyB5b3UgY2FuIHNwZWNpZnkgYFJFUVVJUkVEYCBpbnN0ZWFkIG9mIGBDRVJUX1JFUVVJUkVEYC4KICAgIElmIGl0J3MgbmVpdGhlciBgTm9uZWAgbm9yIGEgc3RyaW5nIHdlIGFzc3VtZSBpdCBpcyBhbHJlYWR5IHRoZSBudW1lcmljCiAgICBjb25zdGFudCB3aGljaCBjYW4gZGlyZWN0bHkgYmUgcGFzc2VkIHRvIHdyYXBfc29ja2V0LgogICAgIiIiCiAgICBpZiBjYW5kaWRhdGUgaXMgTm9uZToKICAgICAgICByZXR1cm4gQ0VSVF9OT05FCgogICAgaWYgaXNpbnN0YW5jZShjYW5kaWRhdGUsIHN0cik6CiAgICAgICAgcmVzID0gZ2V0YXR0cihzc2wsIGNhbmRpZGF0ZSwgTm9uZSkKICAgICAgICBpZiByZXMgaXMgTm9uZToKICAgICAgICAgICAgcmVzID0gZ2V0YXR0cihzc2wsICdDRVJUXycgKyBjYW5kaWRhdGUpCiAgICAgICAgcmV0dXJuIHJlcwoKICAgIHJldHVybiBjYW5kaWRhdGUKCgpkZWYgcmVzb2x2ZV9zc2xfdmVyc2lvbihjYW5kaWRhdGUpOgogICAgIiIiCiAgICBsaWtlIHJlc29sdmVfY2VydF9yZXFzCiAgICAiIiIKICAgIGlmIGNhbmRpZGF0ZSBpcyBOb25lOgogICAgICAgIHJldHVybiBQUk9UT0NPTF9TU0x2MjMKCiAgICBpZiBpc2luc3RhbmNlKGNhbmRpZGF0ZSwgc3RyKToKICAgICAgICByZXMgPSBnZXRhdHRyKHNzbCwgY2FuZGlkYXRlLCBOb25lKQogICAgICAgIGlmIHJlcyBpcyBOb25lOgogICAgICAgICAgICByZXMgPSBnZXRhdHRyKHNzbCwgJ1BST1RPQ09MXycgKyBjYW5kaWRhdGUpCiAgICAgICAgcmV0dXJuIHJlcwoKICAgIHJldHVybiBjYW5kaWRhdGUKCgpkZWYgY3JlYXRlX3VybGxpYjNfY29udGV4dChzc2xfdmVyc2lvbj1Ob25lLCBjZXJ0X3JlcXM9Tm9uZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucz1Ob25lLCBjaXBoZXJzPU5vbmUpOgogICAgIiIiQWxsIGFyZ3VtZW50cyBoYXZlIHRoZSBzYW1lIG1lYW5pbmcgYXMgYGBzc2xfd3JhcF9zb2NrZXRgYC4KCiAgICBCeSBkZWZhdWx0LCB0aGlzIGZ1bmN0aW9uIGRvZXMgYSBsb3Qgb2YgdGhlIHNhbWUgd29yayB0aGF0CiAgICBgYHNzbC5jcmVhdGVfZGVmYXVsdF9jb250ZXh0YGAgZG9lcyBvbiBQeXRob24gMy40Ky4gSXQ6CgogICAgLSBEaXNhYmxlcyBTU0x2MiwgU1NMdjMsIGFuZCBjb21wcmVzc2lvbgogICAgLSBTZXRzIGEgcmVzdHJpY3RlZCBzZXQgb2Ygc2VydmVyIGNpcGhlcnMKCiAgICBJZiB5b3Ugd2lzaCB0byBlbmFibGUgU1NMdjMsIHlvdSBjYW4gZG86OgoKICAgICAgICBmcm9tIHVybGxpYjMudXRpbCBpbXBvcnQgc3NsXwogICAgICAgIGNvbnRleHQgPSBzc2xfLmNyZWF0ZV91cmxsaWIzX2NvbnRleHQoKQogICAgICAgIGNvbnRleHQub3B0aW9ucyAmPSB+c3NsXy5PUF9OT19TU0x2MwoKICAgIFlvdSBjYW4gZG8gdGhlIHNhbWUgdG8gZW5hYmxlIGNvbXByZXNzaW9uIChzdWJzdGl0dXRpbmcgYGBDT01QUkVTU0lPTmBgCiAgICBmb3IgYGBTU0x2M2BgIGluIHRoZSBsYXN0IGxpbmUgYWJvdmUpLgoKICAgIDpwYXJhbSBzc2xfdmVyc2lvbjoKICAgICAgICBUaGUgZGVzaXJlZCBwcm90b2NvbCB2ZXJzaW9uIHRvIHVzZS4gVGhpcyB3aWxsIGRlZmF1bHQgdG8KICAgICAgICBQUk9UT0NPTF9TU0x2MjMgd2hpY2ggd2lsbCBuZWdvdGlhdGUgdGhlIGhpZ2hlc3QgcHJvdG9jb2wgdGhhdCBib3RoCiAgICAgICAgdGhlIHNlcnZlciBhbmQgeW91ciBpbnN0YWxsYXRpb24gb2YgT3BlblNTTCBzdXBwb3J0LgogICAgOnBhcmFtIGNlcnRfcmVxczoKICAgICAgICBXaGV0aGVyIHRvIHJlcXVpcmUgdGhlIGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvbi4gVGhpcyBkZWZhdWx0cyB0bwogICAgICAgIGBgc3NsLkNFUlRfUkVRVUlSRURgYC4KICAgIDpwYXJhbSBvcHRpb25zOgogICAgICAgIFNwZWNpZmljIE9wZW5TU0wgb3B0aW9ucy4gVGhlc2UgZGVmYXVsdCB0byBgYHNzbC5PUF9OT19TU0x2MmBgLAogICAgICAgIGBgc3NsLk9QX05PX1NTTHYzYGAsIGBgc3NsLk9QX05PX0NPTVBSRVNTSU9OYGAuCiAgICA6cGFyYW0gY2lwaGVyczoKICAgICAgICBXaGljaCBjaXBoZXIgc3VpdGVzIHRvIGFsbG93IHRoZSBzZXJ2ZXIgdG8gc2VsZWN0LgogICAgOnJldHVybnM6CiAgICAgICAgQ29uc3RydWN0ZWQgU1NMQ29udGV4dCBvYmplY3Qgd2l0aCBzcGVjaWZpZWQgb3B0aW9ucwogICAgOnJ0eXBlOiBTU0xDb250ZXh0CiAgICAiIiIKICAgIGNvbnRleHQgPSBTU0xDb250ZXh0KHNzbF92ZXJzaW9uIG9yIHNzbC5QUk9UT0NPTF9TU0x2MjMpCgogICAgY29udGV4dC5zZXRfY2lwaGVycyhjaXBoZXJzIG9yIERFRkFVTFRfQ0lQSEVSUykKCiAgICAjIFNldHRpbmcgdGhlIGRlZmF1bHQgaGVyZSwgYXMgd2UgbWF5IGhhdmUgbm8gc3NsIG1vZHVsZSBvbiBpbXBvcnQKICAgIGNlcnRfcmVxcyA9IHNzbC5DRVJUX1JFUVVJUkVEIGlmIGNlcnRfcmVxcyBpcyBOb25lIGVsc2UgY2VydF9yZXFzCgogICAgaWYgb3B0aW9ucyBpcyBOb25lOgogICAgICAgIG9wdGlvbnMgPSAwCiAgICAgICAgIyBTU0x2MiBpcyBlYXNpbHkgYnJva2VuIGFuZCBpcyBjb25zaWRlcmVkIGhhcm1mdWwgYW5kIGRhbmdlcm91cwogICAgICAgIG9wdGlvbnMgfD0gT1BfTk9fU1NMdjIKICAgICAgICAjIFNTTHYzIGhhcyBzZXZlcmFsIHByb2JsZW1zIGFuZCBpcyBub3cgZGFuZ2Vyb3VzCiAgICAgICAgb3B0aW9ucyB8PSBPUF9OT19TU0x2MwogICAgICAgICMgRGlzYWJsZSBjb21wcmVzc2lvbiB0byBwcmV2ZW50IENSSU1FIGF0dGFja3MgZm9yIE9wZW5TU0wgMS4wKwogICAgICAgICMgKGlzc3VlICMzMDkpCiAgICAgICAgb3B0aW9ucyB8PSBPUF9OT19DT01QUkVTU0lPTgoKICAgIGNvbnRleHQub3B0aW9ucyB8PSBvcHRpb25zCgogICAgY29udGV4dC52ZXJpZnlfbW9kZSA9IGNlcnRfcmVxcwogICAgaWYgZ2V0YXR0cihjb250ZXh0LCAnY2hlY2tfaG9zdG5hbWUnLCBOb25lKSBpcyBub3QgTm9uZTogICMgUGxhdGZvcm0tc3BlY2lmaWM6IFB5dGhvbiAzLjIKICAgICAgICAjIFdlIGRvIG91ciBvd24gdmVyaWZpY2F0aW9uLCBpbmNsdWRpbmcgZmluZ2VycHJpbnRzIGFuZCBhbHRlcm5hdGl2ZQogICAgICAgICMgaG9zdG5hbWVzLiBTbyBkaXNhYmxlIGl0IGhlcmUKICAgICAgICBjb250ZXh0LmNoZWNrX2hvc3RuYW1lID0gRmFsc2UKICAgIHJldHVybiBjb250ZXh0CgoKZGVmIHNzbF93cmFwX3NvY2tldChzb2NrLCBrZXlmaWxlPU5vbmUsIGNlcnRmaWxlPU5vbmUsIGNlcnRfcmVxcz1Ob25lLAogICAgICAgICAgICAgICAgICAgIGNhX2NlcnRzPU5vbmUsIHNlcnZlcl9ob3N0bmFtZT1Ob25lLAogICAgICAgICAgICAgICAgICAgIHNzbF92ZXJzaW9uPU5vbmUsIGNpcGhlcnM9Tm9uZSwgc3NsX2NvbnRleHQ9Tm9uZSwKICAgICAgICAgICAgICAgICAgICBjYV9jZXJ0X2Rpcj1Ob25lKToKICAgICIiIgogICAgQWxsIGFyZ3VtZW50cyBleGNlcHQgZm9yIHNlcnZlcl9ob3N0bmFtZSwgc3NsX2NvbnRleHQsIGFuZCBjYV9jZXJ0X2RpciBoYXZlCiAgICB0aGUgc2FtZSBtZWFuaW5nIGFzIHRoZXkgZG8gd2hlbiB1c2luZyA6ZnVuYzpgc3NsLndyYXBfc29ja2V0YC4KCiAgICA6cGFyYW0gc2VydmVyX2hvc3RuYW1lOgogICAgICAgIFdoZW4gU05JIGlzIHN1cHBvcnRlZCwgdGhlIGV4cGVjdGVkIGhvc3RuYW1lIG9mIHRoZSBjZXJ0aWZpY2F0ZQogICAgOnBhcmFtIHNzbF9jb250ZXh0OgogICAgICAgIEEgcHJlLW1hZGUgOmNsYXNzOmBTU0xDb250ZXh0YCBvYmplY3QuIElmIG5vbmUgaXMgcHJvdmlkZWQsIG9uZSB3aWxsCiAgICAgICAgYmUgY3JlYXRlZCB1c2luZyA6ZnVuYzpgY3JlYXRlX3VybGxpYjNfY29udGV4dGAuCiAgICA6cGFyYW0gY2lwaGVyczoKICAgICAgICBBIHN0cmluZyBvZiBjaXBoZXJzIHdlIHdpc2ggdGhlIGNsaWVudCB0byBzdXBwb3J0LgogICAgOnBhcmFtIGNhX2NlcnRfZGlyOgogICAgICAgIEEgZGlyZWN0b3J5IGNvbnRhaW5pbmcgQ0EgY2VydGlmaWNhdGVzIGluIG11bHRpcGxlIHNlcGFyYXRlIGZpbGVzLCBhcwogICAgICAgIHN1cHBvcnRlZCBieSBPcGVuU1NMJ3MgLUNBcGF0aCBmbGFnIG9yIHRoZSBjYXBhdGggYXJndW1lbnQgdG8KICAgICAgICBTU0xDb250ZXh0LmxvYWRfdmVyaWZ5X2xvY2F0aW9ucygpLgogICAgIiIiCiAgICBjb250ZXh0ID0gc3NsX2NvbnRleHQKICAgIGlmIGNvbnRleHQgaXMgTm9uZToKICAgICAgICAjIE5vdGU6IFRoaXMgYnJhbmNoIG9mIGNvZGUgYW5kIGFsbCB0aGUgdmFyaWFibGVzIGluIGl0IGFyZSBubyBsb25nZXIKICAgICAgICAjIHVzZWQgYnkgdXJsbGliMyBpdHNlbGYuIFdlIHNob3VsZCBjb25zaWRlciBkZXByZWNhdGluZyBhbmQgcmVtb3ZpbmcKICAgICAgICAjIHRoaXMgY29kZS4KICAgICAgICBjb250ZXh0ID0gY3JlYXRlX3VybGxpYjNfY29udGV4dChzc2xfdmVyc2lvbiwgY2VydF9yZXFzLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcGhlcnM9Y2lwaGVycykKCiAgICBpZiBjYV9jZXJ0cyBvciBjYV9jZXJ0X2RpcjoKICAgICAgICB0cnk6CiAgICAgICAgICAgIGNvbnRleHQubG9hZF92ZXJpZnlfbG9jYXRpb25zKGNhX2NlcnRzLCBjYV9jZXJ0X2RpcikKICAgICAgICBleGNlcHQgSU9FcnJvciBhcyBlOiAgIyBQbGF0Zm9ybS1zcGVjaWZpYzogUHl0aG9uIDIuNwogICAgICAgICAgICByYWlzZSBTU0xFcnJvcihlKQogICAgICAgICMgUHkzMyByYWlzZXMgRmlsZU5vdEZvdW5kRXJyb3Igd2hpY2ggc3ViY2xhc3NlcyBPU0Vycm9yCiAgICAgICAgIyBUaGVzZSBhcmUgbm90IGVxdWl2YWxlbnQgdW5sZXNzIHdlIGNoZWNrIHRoZSBlcnJubyBhdHRyaWJ1dGUKICAgICAgICBleGNlcHQgT1NFcnJvciBhcyBlOiAgIyBQbGF0Zm9ybS1zcGVjaWZpYzogUHl0aG9uIDMuMyBhbmQgYmV5b25kCiAgICAgICAgICAgIGlmIGUuZXJybm8gPT0gZXJybm8uRU5PRU5UOgogICAgICAgICAgICAgICAgcmFpc2UgU1NMRXJyb3IoZSkKICAgICAgICAgICAgcmFpc2UKCiAgICAjIERvbid0IGxvYWQgc3lzdGVtIGNlcnRzIHVubGVzcyB0aGVyZSB3ZXJlIG5vIENBIGNlcnRzIG9yCiAgICAjIFNTTENvbnRleHQgb2JqZWN0IHNwZWNpZmllZCBtYW51YWxseS4KICAgIGVsaWYgc3NsX2NvbnRleHQgaXMgTm9uZSBhbmQgaGFzYXR0cihjb250ZXh0LCAnbG9hZF9kZWZhdWx0X2NlcnRzJyk6CiAgICAgICAgIyB0cnkgdG8gbG9hZCBPUyBkZWZhdWx0IGNlcnRzOyB3b3JrcyB3ZWxsIG9uIFdpbmRvd3MgKHJlcXVpcmUgUHl0aG9uMy40KykKICAgICAgICBjb250ZXh0LmxvYWRfZGVmYXVsdF9jZXJ0cygpCgogICAgaWYgY2VydGZpbGU6CiAgICAgICAgY29udGV4dC5sb2FkX2NlcnRfY2hhaW4oY2VydGZpbGUsIGtleWZpbGUpCgogICAgIyBJZiB3ZSBkZXRlY3Qgc2VydmVyX2hvc3RuYW1lIGlzIGFuIElQIGFkZHJlc3MgdGhlbiB0aGUgU05JCiAgICAjIGV4dGVuc2lvbiBzaG91bGQgbm90IGJlIHVzZWQgYWNjb3JkaW5nIHRvIFJGQzM1NDYgU2VjdGlvbiAzLjEKICAgICMgV2Ugc2hvdWxkbid0IHdhcm4gdGhlIHVzZXIgaWYgU05JIGlzbid0IGF2YWlsYWJsZSBidXQgd2Ugd291bGQKICAgICMgbm90IGJlIHVzaW5nIFNOSSBhbnl3YXlzIGR1ZSB0byBJUCBhZGRyZXNzIGZvciBzZXJ2ZXJfaG9zdG5hbWUuCiAgICBpZiAoKHNlcnZlcl9ob3N0bmFtZSBpcyBub3QgTm9uZSBhbmQgbm90IGlzX2lwYWRkcmVzcyhzZXJ2ZXJfaG9zdG5hbWUpKQogICAgICAgICAgICBvciBJU19TRUNVUkVUUkFOU1BPUlQpOgogICAgICAgIGlmIEhBU19TTkkgYW5kIHNlcnZlcl9ob3N0bmFtZSBpcyBub3QgTm9uZToKICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQud3JhcF9zb2NrZXQoc29jaywgc2VydmVyX2hvc3RuYW1lPXNlcnZlcl9ob3N0bmFtZSkKCiAgICAgICAgd2FybmluZ3Mud2FybigKICAgICAgICAgICAgJ0FuIEhUVFBTIHJlcXVlc3QgaGFzIGJlZW4gbWFkZSwgYnV0IHRoZSBTTkkgKFNlcnZlciBOYW1lICcKICAgICAgICAgICAgJ0luZGljYXRpb24pIGV4dGVuc2lvbiB0byBUTFMgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGlzIHBsYXRmb3JtLiAnCiAgICAgICAgICAgICdUaGlzIG1heSBjYXVzZSB0aGUgc2VydmVyIHRvIHByZXNlbnQgYW4gaW5jb3JyZWN0IFRMUyAnCiAgICAgICAgICAgICdjZXJ0aWZpY2F0ZSwgd2hpY2ggY2FuIGNhdXNlIHZhbGlkYXRpb24gZmFpbHVyZXMuIFlvdSBjYW4gdXBncmFkZSB0byAnCiAgICAgICAgICAgICdhIG5ld2VyIHZlcnNpb24gb2YgUHl0aG9uIHRvIHNvbHZlIHRoaXMuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJwogICAgICAgICAgICAnaHR0cHM6Ly91cmxsaWIzLnJlYWR0aGVkb2NzLmlvL2VuL2xhdGVzdC9hZHZhbmNlZC11c2FnZS5odG1sJwogICAgICAgICAgICAnI3NzbC13YXJuaW5ncycsCiAgICAgICAgICAgIFNOSU1pc3NpbmdXYXJuaW5nCiAgICAgICAgKQoKICAgIHJldHVybiBjb250ZXh0LndyYXBfc29ja2V0KHNvY2spCgoKZGVmIGlzX2lwYWRkcmVzcyhob3N0bmFtZSk6CiAgICAiIiJEZXRlY3RzIHdoZXRoZXIgdGhlIGhvc3RuYW1lIGdpdmVuIGlzIGFuIElQIGFkZHJlc3MuCgogICAgOnBhcmFtIHN0ciBob3N0bmFtZTogSG9zdG5hbWUgdG8gZXhhbWluZS4KICAgIDpyZXR1cm46IFRydWUgaWYgdGhlIGhvc3RuYW1lIGlzIGFuIElQIGFkZHJlc3MsIEZhbHNlIG90aGVyd2lzZS4KICAgICIiIgogICAgaWYgc2l4LlBZMyBhbmQgaXNpbnN0YW5jZShob3N0bmFtZSwgYnl0ZXMpOgogICAgICAgICMgSUROIEEtbGFiZWwgYnl0ZXMgYXJlIEFTQ0lJIGNvbXBhdGlibGUuCiAgICAgICAgaG9zdG5hbWUgPSBob3N0bmFtZS5kZWNvZGUoJ2FzY2lpJykKCiAgICBmYW1pbGllcyA9IFtzb2NrZXQuQUZfSU5FVF0KICAgIGlmIGhhc2F0dHIoc29ja2V0LCAnQUZfSU5FVDYnKToKICAgICAgICBmYW1pbGllcy5hcHBlbmQoc29ja2V0LkFGX0lORVQ2KQoKICAgIGZvciBhZiBpbiBmYW1pbGllczoKICAgICAgICB0cnk6CiAgICAgICAgICAgIGluZXRfcHRvbihhZiwgaG9zdG5hbWUpCiAgICAgICAgZXhjZXB0IChzb2NrZXQuZXJyb3IsIFZhbHVlRXJyb3IsIE9TRXJyb3IpOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgcmV0dXJuIFRydWUKICAgIHJldHVybiBGYWxzZQo=
