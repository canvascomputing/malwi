statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/rrequests/2.27.1/rrequests-2.27.1/rrequests-2.27.1/requests/adapters.py
  contents:
  - name: HTTPAdapter.send
    score: 0.0
    code: |-
      def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
              """Sends PreparedRequest object. Returns Response object.

              :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
              :param stream: (optional) Whether to stream the request content.
              :param timeout: (optional) How long to wait for the server to send
                  data before giving up, as a float, or a :ref:`(connect timeout,
                  read timeout) <timeouts>` tuple.
              :type timeout: float or tuple or urllib3 Timeout object
              :param verify: (optional) Either a boolean, in which case it controls whether
                  we verify the server's TLS certificate, or a string, in which case it
                  must be a path to a CA bundle to use
              :param cert: (optional) Any user-provided SSL certificate to be trusted.
              :param proxies: (optional) The proxies dictionary to apply to the request.
              :rtype: requests.Response
              """

              try:
                  conn = self.get_connection(request.url, proxies)
              except LocationValueError as e:
                  raise InvalidURL(e, request=request)

              self.cert_verify(conn, request.url, verify, cert)
              url = self.request_url(request, proxies)
              self.add_headers(request, stream=stream, timeout=timeout, verify=verify, cert=cert, proxies=proxies)

              chunked = not (request.body is None or 'Content-Length' in request.headers)

              if isinstance(timeout, tuple):
                  try:
                      connect, read = timeout
                      timeout = TimeoutSauce(connect=connect, read=read)
                  except ValueError as e:
                      # this may raise a string formatting error.
                      err = ("Invalid timeout {}. Pass a (connect, read) "
                             "timeout tuple, or a single float to set "
                             "both timeouts to the same value".format(timeout))
                      raise ValueError(err)
              elif isinstance(timeout, TimeoutSauce):
                  pass
              else:
                  timeout = TimeoutSauce(connect=timeout, read=timeout)

              try:
                  if not chunked:
                      resp = conn.urlopen(
                          method=request.method,
                          url=url,
                          body=request.body,
                          headers=request.headers,
                          redirect=False,
                          assert_same_host=False,
                          preload_content=False,
                          decode_content=False,
                          retries=self.max_retries,
                          timeout=timeout
                      )

                  # Send the request.
                  else:
                      if hasattr(conn, 'proxy_pool'):
                          conn = conn.proxy_pool

                      low_conn = conn._get_conn(timeout=DEFAULT_POOL_TIMEOUT)

                      try:
                          skip_host = 'Host' in request.headers
                          low_conn.putrequest(request.method,
                                              url,
                                              skip_accept_encoding=True,
                                              skip_host=skip_host)

                          for header, value in request.headers.items():
                              low_conn.putheader(header, value)

                          low_conn.endheaders()

                          for i in request.body:
                              low_conn.send(hex(len(i))[2:].encode('utf-8'))
                              low_conn.send(b'\r\n')
                              low_conn.send(i)
                              low_conn.send(b'\r\n')
                          low_conn.send(b'0\r\n\r\n')

                          # Receive the response from the server
                          try:
                              # For Python 2.7, use buffering of HTTP responses
                              r = low_conn.getresponse(buffering=True)
                          except TypeError:
                              # For compatibility with Python 3.3+
                              r = low_conn.getresponse()

                          resp = HTTPResponse.from_httplib(
                              r,
                              pool=conn,
                              connection=low_conn,
                              preload_content=False,
                              decode_content=False
                          )
                      except:
                          # If we hit any problems here, clean up the connection.
                          # Then, reraise so that we can handle the actual exception.
                          low_conn.close()
                          raise

              except (ProtocolError, socket.error) as err:
                  raise ConnectionError(err, request=request)

              except MaxRetryError as e:
                  if isinstance(e.reason, ConnectTimeoutError):
                      # TODO: Remove this in 3.0.0: see #2811
                      if not isinstance(e.reason, NewConnectionError):
                          raise ConnectTimeout(e, request=request)

                  if isinstance(e.reason, ResponseError):
                      raise RetryError(e, request=request)

                  if isinstance(e.reason, _ProxyError):
                      raise ProxyError(e, request=request)

                  if isinstance(e.reason, _SSLError):
                      # This branch is for urllib3 v1.22 and later.
                      raise SSLError(e, request=request)

                  raise ConnectionError(e, request=request)

              except ClosedPoolError as e:
                  raise ConnectionError(e, request=request)

              except _ProxyError as e:
                  raise ProxyError(e)

              except (_SSLError, _HTTPError) as e:
                  if isinstance(e, _SSLError):
                      # This branch is for urllib3 versions earlier than v1.22
                      raise SSLError(e, request=request)
                  elif isinstance(e, ReadTimeoutError):
                      raise ReadTimeout(e, request=request)
                  elif isinstance(e, _InvalidHeader):
                      raise InvalidHeader(e, request=request)
                  else:
                      raise

              return self.build_response(request, resp)
    tokens: resume nop load_fast self load_attr get_connection load_fast request load_attr url load_fast proxies call store_fast conn load_fast self load_attr cert_verify load_fast conn load_fast request load_attr url load_fast verify load_fast cert call pop_top load_fast self load_attr request_url load_fast request load_fast proxies call store_fast url load_fast self load_attr add_headers load_fast request load_fast stream load_fast timeout load_fast verify load_fast cert load_fast proxies kw_names cert proxies stream timeout verify call pop_top load_fast request load_attr body load_const is_op copy pop_jump_if_true TO_NUMBER pop_top load_const Content-Length load_fast request load_attr headers contains_op unary_not store_fast chunked load_global isinstance load_fast timeout load_global tuple call pop_jump_if_false TO_NUMBER nop load_fast timeout unpack_sequence store_fast connect store_fast read load_global TimeoutSauce load_fast connect load_fast read kw_names connect read call store_fast timeout jump_forward TO_NUMBER load_global isinstance load_fast timeout load_global TimeoutSauce call pop_jump_if_false TO_NUMBER jump_forward TO_NUMBER load_global TimeoutSauce load_fast timeout load_fast timeout kw_names connect read call store_fast timeout nop load_fast chunked pop_jump_if_true TO_NUMBER load_fast conn load_attr NETWORK_HTTP_REQUEST load_fast request load_attr method load_fast url load_fast request load_attr body load_fast request load_attr headers load_const INTEGER load_const INTEGER load_const INTEGER load_const INTEGER load_fast self load_attr max_retries load_fast timeout kw_names assert_same_host body decode_content headers method preload_content redirect retries timeout url call store_fast resp extended_arg jump_forward TO_NUMBER load_global REFLECTION_DYNAMIC_READ load_fast conn load_const proxy_pool call pop_jump_if_false TO_NUMBER load_fast conn load_attr proxy_pool store_fast conn load_fast conn load_attr _get_conn load_global STRING_LEN_S_ENT_HIGH kw_names timeout call store_fast low_conn nop load_const Host load_fast request load_attr headers contains_op store_fast skip_host load_fast low_conn load_attr putrequest load_fast request load_attr method load_fast url load_const INTEGER load_fast skip_host kw_names skip_accept_encoding skip_host call pop_top load_fast request load_attr headers load_attr items call get_iter for_iter TO_NUMBER unpack_sequence store_fast header store_fast value load_fast low_conn load_attr putheader load_fast header load_fast value call pop_top jump_backward TO_NUMBER end_for load_fast low_conn load_attr endheaders call pop_top load_fast request load_attr body get_iter for_iter TO_NUMBER store_fast i load_fast low_conn load_attr send load_global ENCODING_DECODING load_global len load_fast i call call load_const INTEGER load_const binary_slice load_attr ENCODING_DECODING load_const utf-8 call call pop_top load_fast low_conn load_attr send load_const call pop_top load_fast low_conn load_attr send load_fast i call pop_top load_fast low_conn load_attr send load_const call pop_top jump_backward TO_NUMBER end_for load_fast low_conn load_attr send load_const call pop_top nop load_fast low_conn load_attr getresponse load_const INTEGER kw_names buffering call store_fast r load_global HTTPResponse load_attr from_httplib load_fast r load_fast conn load_fast low_conn load_const INTEGER load_const INTEGER kw_names connection decode_content pool preload_content call store_fast resp load_fast self load_attr build_response load_fast request load_fast resp call return_value push_exc_info load_global STRING_LEN_S_ENT_HIGH check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global InvalidURL load_fast e load_fast request kw_names request call raise_varargs load_const store_fast e delete_fast e reraise reraise copy pop_except reraise push_exc_info load_global ValueError check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_const STRING_LEN_M_ENT_HIGH load_attr format load_fast timeout call store_fast err load_global ValueError load_fast err call raise_varargs load_const store_fast e delete_fast e reraise reraise copy pop_except reraise push_exc_info load_global TypeError check_exc_match pop_jump_if_false TO_NUMBER pop_top load_fast low_conn load_attr getresponse call store_fast r pop_except jump_backward TO_NUMBER reraise copy pop_except reraise push_exc_info pop_top load_fast low_conn load_attr close call pop_top raise_varargs copy pop_except reraise push_exc_info load_global ProtocolError load_global socket load_attr error build_tuple check_exc_match pop_jump_if_false TO_NUMBER store_fast err load_global ConnectionError load_fast err load_fast request kw_names request call raise_varargs load_const store_fast err delete_fast err reraise load_global MaxRetryError check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global isinstance load_fast e load_attr reason load_global STRING_LEN_S_ENT_HIGH call pop_jump_if_false TO_NUMBER load_global isinstance load_fast e load_attr reason load_global STRING_LEN_S_ENT_HIGH call pop_jump_if_true TO_NUMBER load_global ConnectTimeout load_fast e load_fast request kw_names request call raise_varargs load_global isinstance load_fast e load_attr reason load_global ResponseError call pop_jump_if_false TO_NUMBER load_global RetryError load_fast e load_fast request kw_names request call raise_varargs load_global isinstance load_fast e load_attr reason load_global _ProxyError call pop_jump_if_false TO_NUMBER load_global ProxyError load_fast e load_fast request kw_names request call raise_varargs load_global isinstance load_fast e load_attr reason load_global _SSLError call pop_jump_if_false TO_NUMBER load_global SSLError load_fast e load_fast request kw_names request call raise_varargs load_global ConnectionError load_fast e load_fast request kw_names request call raise_varargs load_const store_fast e delete_fast e reraise load_global ClosedPoolError check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global ConnectionError load_fast e load_fast request kw_names request call raise_varargs load_const store_fast e delete_fast e reraise load_global _ProxyError check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global ProxyError load_fast e call raise_varargs load_const store_fast e delete_fast e reraise load_global _SSLError load_global _HTTPError build_tuple check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global isinstance load_fast e load_global _SSLError call pop_jump_if_false TO_NUMBER load_global SSLError load_fast e load_fast request kw_names request call raise_varargs load_global isinstance load_fast e load_global STRING_BASE64_LEN_S_ENT_HIGH call pop_jump_if_false TO_NUMBER load_global ReadTimeout load_fast e load_fast request kw_names request call raise_varargs load_global isinstance load_fast e load_global _InvalidHeader call pop_jump_if_false TO_NUMBER load_global InvalidHeader load_fast e load_fast request kw_names request call raise_varargs raise_varargs load_const store_fast e delete_fast e reraise reraise copy pop_except reraise
    hash: 8c82c418535fd2e9b5aff01ed0738610d9a76491f9da24445ab8c9a75c22499a
sources:
  .repo_cache/malicious_repos/pypi_malregistry/rrequests/2.27.1/rrequests-2.27.1/rrequests-2.27.1/requests/adapters.py: IyAtKi0gY29kaW5nOiB1dGYtOCAtKi0KCiIiIgpyZXF1ZXN0cy5hZGFwdGVycwp+fn5+fn5+fn5+fn5+fn5+fgoKVGhpcyBtb2R1bGUgY29udGFpbnMgdGhlIHRyYW5zcG9ydCBhZGFwdGVycyB0aGF0IFJlcXVlc3RzIHVzZXMgdG8gZGVmaW5lCmFuZCBtYWludGFpbiBjb25uZWN0aW9ucy4KIiIiCgppbXBvcnQgb3MucGF0aAppbXBvcnQgc29ja2V0Cgpmcm9tIHVybGxpYjMucG9vbG1hbmFnZXIgaW1wb3J0IFBvb2xNYW5hZ2VyLCBwcm94eV9mcm9tX3VybApmcm9tIHVybGxpYjMucmVzcG9uc2UgaW1wb3J0IEhUVFBSZXNwb25zZQpmcm9tIHVybGxpYjMudXRpbCBpbXBvcnQgcGFyc2VfdXJsCmZyb20gdXJsbGliMy51dGlsIGltcG9ydCBUaW1lb3V0IGFzIFRpbWVvdXRTYXVjZQpmcm9tIHVybGxpYjMudXRpbC5yZXRyeSBpbXBvcnQgUmV0cnkKZnJvbSB1cmxsaWIzLmV4Y2VwdGlvbnMgaW1wb3J0IENsb3NlZFBvb2xFcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgQ29ubmVjdFRpbWVvdXRFcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgSFRUUEVycm9yIGFzIF9IVFRQRXJyb3IKZnJvbSB1cmxsaWIzLmV4Y2VwdGlvbnMgaW1wb3J0IEludmFsaWRIZWFkZXIgYXMgX0ludmFsaWRIZWFkZXIKZnJvbSB1cmxsaWIzLmV4Y2VwdGlvbnMgaW1wb3J0IE1heFJldHJ5RXJyb3IKZnJvbSB1cmxsaWIzLmV4Y2VwdGlvbnMgaW1wb3J0IE5ld0Nvbm5lY3Rpb25FcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgUHJveHlFcnJvciBhcyBfUHJveHlFcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgUHJvdG9jb2xFcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgUmVhZFRpbWVvdXRFcnJvcgpmcm9tIHVybGxpYjMuZXhjZXB0aW9ucyBpbXBvcnQgU1NMRXJyb3IgYXMgX1NTTEVycm9yCmZyb20gdXJsbGliMy5leGNlcHRpb25zIGltcG9ydCBSZXNwb25zZUVycm9yCmZyb20gdXJsbGliMy5leGNlcHRpb25zIGltcG9ydCBMb2NhdGlvblZhbHVlRXJyb3IKCmZyb20gLm1vZGVscyBpbXBvcnQgUmVzcG9uc2UKZnJvbSAuY29tcGF0IGltcG9ydCB1cmxwYXJzZSwgYmFzZXN0cmluZwpmcm9tIC51dGlscyBpbXBvcnQgKERFRkFVTFRfQ0FfQlVORExFX1BBVEgsIGV4dHJhY3RfemlwcGVkX3BhdGhzLAogICAgICAgICAgICAgICAgICAgIGdldF9lbmNvZGluZ19mcm9tX2hlYWRlcnMsIHByZXBlbmRfc2NoZW1lX2lmX25lZWRlZCwKICAgICAgICAgICAgICAgICAgICBnZXRfYXV0aF9mcm9tX3VybCwgdXJsZGVmcmFnYXV0aCwgc2VsZWN0X3Byb3h5KQpmcm9tIC5zdHJ1Y3R1cmVzIGltcG9ydCBDYXNlSW5zZW5zaXRpdmVEaWN0CmZyb20gLmNvb2tpZXMgaW1wb3J0IGV4dHJhY3RfY29va2llc190b19qYXIKZnJvbSAuZXhjZXB0aW9ucyBpbXBvcnQgKENvbm5lY3Rpb25FcnJvciwgQ29ubmVjdFRpbWVvdXQsIFJlYWRUaW1lb3V0LCBTU0xFcnJvciwKICAgICAgICAgICAgICAgICAgICAgICAgIFByb3h5RXJyb3IsIFJldHJ5RXJyb3IsIEludmFsaWRTY2hlbWEsIEludmFsaWRQcm94eVVSTCwKICAgICAgICAgICAgICAgICAgICAgICAgIEludmFsaWRVUkwsIEludmFsaWRIZWFkZXIpCmZyb20gLmF1dGggaW1wb3J0IF9iYXNpY19hdXRoX3N0cgoKdHJ5OgogICAgZnJvbSB1cmxsaWIzLmNvbnRyaWIuc29ja3MgaW1wb3J0IFNPQ0tTUHJveHlNYW5hZ2VyCmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIGRlZiBTT0NLU1Byb3h5TWFuYWdlcigqYXJncywgKiprd2FyZ3MpOgogICAgICAgIHJhaXNlIEludmFsaWRTY2hlbWEoIk1pc3NpbmcgZGVwZW5kZW5jaWVzIGZvciBTT0NLUyBzdXBwb3J0LiIpCgpERUZBVUxUX1BPT0xCTE9DSyA9IEZhbHNlCkRFRkFVTFRfUE9PTFNJWkUgPSAxMApERUZBVUxUX1JFVFJJRVMgPSAwCkRFRkFVTFRfUE9PTF9USU1FT1VUID0gTm9uZQoKCmNsYXNzIEJhc2VBZGFwdGVyKG9iamVjdCk6CiAgICAiIiJUaGUgQmFzZSBUcmFuc3BvcnQgQWRhcHRlciIiIgoKICAgIGRlZiBfX2luaXRfXyhzZWxmKToKICAgICAgICBzdXBlcihCYXNlQWRhcHRlciwgc2VsZikuX19pbml0X18oKQoKICAgIGRlZiBzZW5kKHNlbGYsIHJlcXVlc3QsIHN0cmVhbT1GYWxzZSwgdGltZW91dD1Ob25lLCB2ZXJpZnk9VHJ1ZSwKICAgICAgICAgICAgIGNlcnQ9Tm9uZSwgcHJveGllcz1Ob25lKToKICAgICAgICAiIiJTZW5kcyBQcmVwYXJlZFJlcXVlc3Qgb2JqZWN0LiBSZXR1cm5zIFJlc3BvbnNlIG9iamVjdC4KCiAgICAgICAgOnBhcmFtIHJlcXVlc3Q6IFRoZSA6Y2xhc3M6YFByZXBhcmVkUmVxdWVzdCA8UHJlcGFyZWRSZXF1ZXN0PmAgYmVpbmcgc2VudC4KICAgICAgICA6cGFyYW0gc3RyZWFtOiAob3B0aW9uYWwpIFdoZXRoZXIgdG8gc3RyZWFtIHRoZSByZXF1ZXN0IGNvbnRlbnQuCiAgICAgICAgOnBhcmFtIHRpbWVvdXQ6IChvcHRpb25hbCkgSG93IGxvbmcgdG8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBzZW5kCiAgICAgICAgICAgIGRhdGEgYmVmb3JlIGdpdmluZyB1cCwgYXMgYSBmbG9hdCwgb3IgYSA6cmVmOmAoY29ubmVjdCB0aW1lb3V0LAogICAgICAgICAgICByZWFkIHRpbWVvdXQpIDx0aW1lb3V0cz5gIHR1cGxlLgogICAgICAgIDp0eXBlIHRpbWVvdXQ6IGZsb2F0IG9yIHR1cGxlCiAgICAgICAgOnBhcmFtIHZlcmlmeTogKG9wdGlvbmFsKSBFaXRoZXIgYSBib29sZWFuLCBpbiB3aGljaCBjYXNlIGl0IGNvbnRyb2xzIHdoZXRoZXIgd2UgdmVyaWZ5CiAgICAgICAgICAgIHRoZSBzZXJ2ZXIncyBUTFMgY2VydGlmaWNhdGUsIG9yIGEgc3RyaW5nLCBpbiB3aGljaCBjYXNlIGl0IG11c3QgYmUgYSBwYXRoCiAgICAgICAgICAgIHRvIGEgQ0EgYnVuZGxlIHRvIHVzZQogICAgICAgIDpwYXJhbSBjZXJ0OiAob3B0aW9uYWwpIEFueSB1c2VyLXByb3ZpZGVkIFNTTCBjZXJ0aWZpY2F0ZSB0byBiZSB0cnVzdGVkLgogICAgICAgIDpwYXJhbSBwcm94aWVzOiAob3B0aW9uYWwpIFRoZSBwcm94aWVzIGRpY3Rpb25hcnkgdG8gYXBwbHkgdG8gdGhlIHJlcXVlc3QuCiAgICAgICAgIiIiCiAgICAgICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvcgoKICAgIGRlZiBjbG9zZShzZWxmKToKICAgICAgICAiIiJDbGVhbnMgdXAgYWRhcHRlciBzcGVjaWZpYyBpdGVtcy4iIiIKICAgICAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yCgoKY2xhc3MgSFRUUEFkYXB0ZXIoQmFzZUFkYXB0ZXIpOgogICAgIiIiVGhlIGJ1aWx0LWluIEhUVFAgQWRhcHRlciBmb3IgdXJsbGliMy4KCiAgICBQcm92aWRlcyBhIGdlbmVyYWwtY2FzZSBpbnRlcmZhY2UgZm9yIFJlcXVlc3RzIHNlc3Npb25zIHRvIGNvbnRhY3QgSFRUUCBhbmQKICAgIEhUVFBTIHVybHMgYnkgaW1wbGVtZW50aW5nIHRoZSBUcmFuc3BvcnQgQWRhcHRlciBpbnRlcmZhY2UuIFRoaXMgY2xhc3Mgd2lsbAogICAgdXN1YWxseSBiZSBjcmVhdGVkIGJ5IHRoZSA6Y2xhc3M6YFNlc3Npb24gPFNlc3Npb24+YCBjbGFzcyB1bmRlciB0aGUKICAgIGNvdmVycy4KCiAgICA6cGFyYW0gcG9vbF9jb25uZWN0aW9uczogVGhlIG51bWJlciBvZiB1cmxsaWIzIGNvbm5lY3Rpb24gcG9vbHMgdG8gY2FjaGUuCiAgICA6cGFyYW0gcG9vbF9tYXhzaXplOiBUaGUgbWF4aW11bSBudW1iZXIgb2YgY29ubmVjdGlvbnMgdG8gc2F2ZSBpbiB0aGUgcG9vbC4KICAgIDpwYXJhbSBtYXhfcmV0cmllczogVGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgZWFjaCBjb25uZWN0aW9uCiAgICAgICAgc2hvdWxkIGF0dGVtcHQuIE5vdGUsIHRoaXMgYXBwbGllcyBvbmx5IHRvIGZhaWxlZCBETlMgbG9va3Vwcywgc29ja2V0CiAgICAgICAgY29ubmVjdGlvbnMgYW5kIGNvbm5lY3Rpb24gdGltZW91dHMsIG5ldmVyIHRvIHJlcXVlc3RzIHdoZXJlIGRhdGEgaGFzCiAgICAgICAgbWFkZSBpdCB0byB0aGUgc2VydmVyLiBCeSBkZWZhdWx0LCBSZXF1ZXN0cyBkb2VzIG5vdCByZXRyeSBmYWlsZWQKICAgICAgICBjb25uZWN0aW9ucy4gSWYgeW91IG5lZWQgZ3JhbnVsYXIgY29udHJvbCBvdmVyIHRoZSBjb25kaXRpb25zIHVuZGVyCiAgICAgICAgd2hpY2ggd2UgcmV0cnkgYSByZXF1ZXN0LCBpbXBvcnQgdXJsbGliMydzIGBgUmV0cnlgYCBjbGFzcyBhbmQgcGFzcwogICAgICAgIHRoYXQgaW5zdGVhZC4KICAgIDpwYXJhbSBwb29sX2Jsb2NrOiBXaGV0aGVyIHRoZSBjb25uZWN0aW9uIHBvb2wgc2hvdWxkIGJsb2NrIGZvciBjb25uZWN0aW9ucy4KCiAgICBVc2FnZTo6CgogICAgICA+Pj4gaW1wb3J0IHJlcXVlc3RzCiAgICAgID4+PiBzID0gcmVxdWVzdHMuU2Vzc2lvbigpCiAgICAgID4+PiBhID0gcmVxdWVzdHMuYWRhcHRlcnMuSFRUUEFkYXB0ZXIobWF4X3JldHJpZXM9MykKICAgICAgPj4+IHMubW91bnQoJ2h0dHA6Ly8nLCBhKQogICAgIiIiCiAgICBfX2F0dHJzX18gPSBbJ21heF9yZXRyaWVzJywgJ2NvbmZpZycsICdfcG9vbF9jb25uZWN0aW9ucycsICdfcG9vbF9tYXhzaXplJywKICAgICAgICAgICAgICAgICAnX3Bvb2xfYmxvY2snXQoKICAgIGRlZiBfX2luaXRfXyhzZWxmLCBwb29sX2Nvbm5lY3Rpb25zPURFRkFVTFRfUE9PTFNJWkUsCiAgICAgICAgICAgICAgICAgcG9vbF9tYXhzaXplPURFRkFVTFRfUE9PTFNJWkUsIG1heF9yZXRyaWVzPURFRkFVTFRfUkVUUklFUywKICAgICAgICAgICAgICAgICBwb29sX2Jsb2NrPURFRkFVTFRfUE9PTEJMT0NLKToKICAgICAgICBpZiBtYXhfcmV0cmllcyA9PSBERUZBVUxUX1JFVFJJRVM6CiAgICAgICAgICAgIHNlbGYubWF4X3JldHJpZXMgPSBSZXRyeSgwLCByZWFkPUZhbHNlKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHNlbGYubWF4X3JldHJpZXMgPSBSZXRyeS5mcm9tX2ludChtYXhfcmV0cmllcykKICAgICAgICBzZWxmLmNvbmZpZyA9IHt9CiAgICAgICAgc2VsZi5wcm94eV9tYW5hZ2VyID0ge30KCiAgICAgICAgc3VwZXIoSFRUUEFkYXB0ZXIsIHNlbGYpLl9faW5pdF9fKCkKCiAgICAgICAgc2VsZi5fcG9vbF9jb25uZWN0aW9ucyA9IHBvb2xfY29ubmVjdGlvbnMKICAgICAgICBzZWxmLl9wb29sX21heHNpemUgPSBwb29sX21heHNpemUKICAgICAgICBzZWxmLl9wb29sX2Jsb2NrID0gcG9vbF9ibG9jawoKICAgICAgICBzZWxmLmluaXRfcG9vbG1hbmFnZXIocG9vbF9jb25uZWN0aW9ucywgcG9vbF9tYXhzaXplLCBibG9jaz1wb29sX2Jsb2NrKQoKICAgIGRlZiBfX2dldHN0YXRlX18oc2VsZik6CiAgICAgICAgcmV0dXJuIHthdHRyOiBnZXRhdHRyKHNlbGYsIGF0dHIsIE5vbmUpIGZvciBhdHRyIGluIHNlbGYuX19hdHRyc19ffQoKICAgIGRlZiBfX3NldHN0YXRlX18oc2VsZiwgc3RhdGUpOgogICAgICAgICMgQ2FuJ3QgaGFuZGxlIGJ5IGFkZGluZyAncHJveHlfbWFuYWdlcicgdG8gc2VsZi5fX2F0dHJzX18gYmVjYXVzZQogICAgICAgICMgc2VsZi5wb29sbWFuYWdlciB1c2VzIGEgbGFtYmRhIGZ1bmN0aW9uLCB3aGljaCBpc24ndCBwaWNrbGVhYmxlLgogICAgICAgIHNlbGYucHJveHlfbWFuYWdlciA9IHt9CiAgICAgICAgc2VsZi5jb25maWcgPSB7fQoKICAgICAgICBmb3IgYXR0ciwgdmFsdWUgaW4gc3RhdGUuaXRlbXMoKToKICAgICAgICAgICAgc2V0YXR0cihzZWxmLCBhdHRyLCB2YWx1ZSkKCiAgICAgICAgc2VsZi5pbml0X3Bvb2xtYW5hZ2VyKHNlbGYuX3Bvb2xfY29ubmVjdGlvbnMsIHNlbGYuX3Bvb2xfbWF4c2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2s9c2VsZi5fcG9vbF9ibG9jaykKCiAgICBkZWYgaW5pdF9wb29sbWFuYWdlcihzZWxmLCBjb25uZWN0aW9ucywgbWF4c2l6ZSwgYmxvY2s9REVGQVVMVF9QT09MQkxPQ0ssICoqcG9vbF9rd2FyZ3MpOgogICAgICAgICIiIkluaXRpYWxpemVzIGEgdXJsbGliMyBQb29sTWFuYWdlci4KCiAgICAgICAgVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZnJvbSB1c2VyIGNvZGUsIGFuZCBpcyBvbmx5CiAgICAgICAgZXhwb3NlZCBmb3IgdXNlIHdoZW4gc3ViY2xhc3NpbmcgdGhlCiAgICAgICAgOmNsYXNzOmBIVFRQQWRhcHRlciA8cmVxdWVzdHMuYWRhcHRlcnMuSFRUUEFkYXB0ZXI+YC4KCiAgICAgICAgOnBhcmFtIGNvbm5lY3Rpb25zOiBUaGUgbnVtYmVyIG9mIHVybGxpYjMgY29ubmVjdGlvbiBwb29scyB0byBjYWNoZS4KICAgICAgICA6cGFyYW0gbWF4c2l6ZTogVGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbm5lY3Rpb25zIHRvIHNhdmUgaW4gdGhlIHBvb2wuCiAgICAgICAgOnBhcmFtIGJsb2NrOiBCbG9jayB3aGVuIG5vIGZyZWUgY29ubmVjdGlvbnMgYXJlIGF2YWlsYWJsZS4KICAgICAgICA6cGFyYW0gcG9vbF9rd2FyZ3M6IEV4dHJhIGtleXdvcmQgYXJndW1lbnRzIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgUG9vbCBNYW5hZ2VyLgogICAgICAgICIiIgogICAgICAgICMgc2F2ZSB0aGVzZSB2YWx1ZXMgZm9yIHBpY2tsaW5nCiAgICAgICAgc2VsZi5fcG9vbF9jb25uZWN0aW9ucyA9IGNvbm5lY3Rpb25zCiAgICAgICAgc2VsZi5fcG9vbF9tYXhzaXplID0gbWF4c2l6ZQogICAgICAgIHNlbGYuX3Bvb2xfYmxvY2sgPSBibG9jawoKICAgICAgICBzZWxmLnBvb2xtYW5hZ2VyID0gUG9vbE1hbmFnZXIobnVtX3Bvb2xzPWNvbm5lY3Rpb25zLCBtYXhzaXplPW1heHNpemUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrPWJsb2NrLCBzdHJpY3Q9VHJ1ZSwgKipwb29sX2t3YXJncykKCiAgICBkZWYgcHJveHlfbWFuYWdlcl9mb3Ioc2VsZiwgcHJveHksICoqcHJveHlfa3dhcmdzKToKICAgICAgICAiIiJSZXR1cm4gdXJsbGliMyBQcm94eU1hbmFnZXIgZm9yIHRoZSBnaXZlbiBwcm94eS4KCiAgICAgICAgVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZnJvbSB1c2VyIGNvZGUsIGFuZCBpcyBvbmx5CiAgICAgICAgZXhwb3NlZCBmb3IgdXNlIHdoZW4gc3ViY2xhc3NpbmcgdGhlCiAgICAgICAgOmNsYXNzOmBIVFRQQWRhcHRlciA8cmVxdWVzdHMuYWRhcHRlcnMuSFRUUEFkYXB0ZXI+YC4KCiAgICAgICAgOnBhcmFtIHByb3h5OiBUaGUgcHJveHkgdG8gcmV0dXJuIGEgdXJsbGliMyBQcm94eU1hbmFnZXIgZm9yLgogICAgICAgIDpwYXJhbSBwcm94eV9rd2FyZ3M6IEV4dHJhIGtleXdvcmQgYXJndW1lbnRzIHVzZWQgdG8gY29uZmlndXJlIHRoZSBQcm94eSBNYW5hZ2VyLgogICAgICAgIDpyZXR1cm5zOiBQcm94eU1hbmFnZXIKICAgICAgICA6cnR5cGU6IHVybGxpYjMuUHJveHlNYW5hZ2VyCiAgICAgICAgIiIiCiAgICAgICAgaWYgcHJveHkgaW4gc2VsZi5wcm94eV9tYW5hZ2VyOgogICAgICAgICAgICBtYW5hZ2VyID0gc2VsZi5wcm94eV9tYW5hZ2VyW3Byb3h5XQogICAgICAgIGVsaWYgcHJveHkubG93ZXIoKS5zdGFydHN3aXRoKCdzb2NrcycpOgogICAgICAgICAgICB1c2VybmFtZSwgcGFzc3dvcmQgPSBnZXRfYXV0aF9mcm9tX3VybChwcm94eSkKICAgICAgICAgICAgbWFuYWdlciA9IHNlbGYucHJveHlfbWFuYWdlcltwcm94eV0gPSBTT0NLU1Byb3h5TWFuYWdlcigKICAgICAgICAgICAgICAgIHByb3h5LAogICAgICAgICAgICAgICAgdXNlcm5hbWU9dXNlcm5hbWUsCiAgICAgICAgICAgICAgICBwYXNzd29yZD1wYXNzd29yZCwKICAgICAgICAgICAgICAgIG51bV9wb29scz1zZWxmLl9wb29sX2Nvbm5lY3Rpb25zLAogICAgICAgICAgICAgICAgbWF4c2l6ZT1zZWxmLl9wb29sX21heHNpemUsCiAgICAgICAgICAgICAgICBibG9jaz1zZWxmLl9wb29sX2Jsb2NrLAogICAgICAgICAgICAgICAgKipwcm94eV9rd2FyZ3MKICAgICAgICAgICAgKQogICAgICAgIGVsc2U6CiAgICAgICAgICAgIHByb3h5X2hlYWRlcnMgPSBzZWxmLnByb3h5X2hlYWRlcnMocHJveHkpCiAgICAgICAgICAgIG1hbmFnZXIgPSBzZWxmLnByb3h5X21hbmFnZXJbcHJveHldID0gcHJveHlfZnJvbV91cmwoCiAgICAgICAgICAgICAgICBwcm94eSwKICAgICAgICAgICAgICAgIHByb3h5X2hlYWRlcnM9cHJveHlfaGVhZGVycywKICAgICAgICAgICAgICAgIG51bV9wb29scz1zZWxmLl9wb29sX2Nvbm5lY3Rpb25zLAogICAgICAgICAgICAgICAgbWF4c2l6ZT1zZWxmLl9wb29sX21heHNpemUsCiAgICAgICAgICAgICAgICBibG9jaz1zZWxmLl9wb29sX2Jsb2NrLAogICAgICAgICAgICAgICAgKipwcm94eV9rd2FyZ3MpCgogICAgICAgIHJldHVybiBtYW5hZ2VyCgogICAgZGVmIGNlcnRfdmVyaWZ5KHNlbGYsIGNvbm4sIHVybCwgdmVyaWZ5LCBjZXJ0KToKICAgICAgICAiIiJWZXJpZnkgYSBTU0wgY2VydGlmaWNhdGUuIFRoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgY2FsbGVkIGZyb20gdXNlcgogICAgICAgIGNvZGUsIGFuZCBpcyBvbmx5IGV4cG9zZWQgZm9yIHVzZSB3aGVuIHN1YmNsYXNzaW5nIHRoZQogICAgICAgIDpjbGFzczpgSFRUUEFkYXB0ZXIgPHJlcXVlc3RzLmFkYXB0ZXJzLkhUVFBBZGFwdGVyPmAuCgogICAgICAgIDpwYXJhbSBjb25uOiBUaGUgdXJsbGliMyBjb25uZWN0aW9uIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIGNlcnQuCiAgICAgICAgOnBhcmFtIHVybDogVGhlIHJlcXVlc3RlZCBVUkwuCiAgICAgICAgOnBhcmFtIHZlcmlmeTogRWl0aGVyIGEgYm9vbGVhbiwgaW4gd2hpY2ggY2FzZSBpdCBjb250cm9scyB3aGV0aGVyIHdlIHZlcmlmeQogICAgICAgICAgICB0aGUgc2VydmVyJ3MgVExTIGNlcnRpZmljYXRlLCBvciBhIHN0cmluZywgaW4gd2hpY2ggY2FzZSBpdCBtdXN0IGJlIGEgcGF0aAogICAgICAgICAgICB0byBhIENBIGJ1bmRsZSB0byB1c2UKICAgICAgICA6cGFyYW0gY2VydDogVGhlIFNTTCBjZXJ0aWZpY2F0ZSB0byB2ZXJpZnkuCiAgICAgICAgIiIiCiAgICAgICAgaWYgdXJsLmxvd2VyKCkuc3RhcnRzd2l0aCgnaHR0cHMnKSBhbmQgdmVyaWZ5OgoKICAgICAgICAgICAgY2VydF9sb2MgPSBOb25lCgogICAgICAgICAgICAjIEFsbG93IHNlbGYtc3BlY2lmaWVkIGNlcnQgbG9jYXRpb24uCiAgICAgICAgICAgIGlmIHZlcmlmeSBpcyBub3QgVHJ1ZToKICAgICAgICAgICAgICAgIGNlcnRfbG9jID0gdmVyaWZ5CgogICAgICAgICAgICBpZiBub3QgY2VydF9sb2M6CiAgICAgICAgICAgICAgICBjZXJ0X2xvYyA9IGV4dHJhY3RfemlwcGVkX3BhdGhzKERFRkFVTFRfQ0FfQlVORExFX1BBVEgpCgogICAgICAgICAgICBpZiBub3QgY2VydF9sb2Mgb3Igbm90IG9zLnBhdGguZXhpc3RzKGNlcnRfbG9jKToKICAgICAgICAgICAgICAgIHJhaXNlIElPRXJyb3IoIkNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgVExTIENBIGNlcnRpZmljYXRlIGJ1bmRsZSwgIgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiaW52YWxpZCBwYXRoOiB7fSIuZm9ybWF0KGNlcnRfbG9jKSkKCiAgICAgICAgICAgIGNvbm4uY2VydF9yZXFzID0gJ0NFUlRfUkVRVUlSRUQnCgogICAgICAgICAgICBpZiBub3Qgb3MucGF0aC5pc2RpcihjZXJ0X2xvYyk6CiAgICAgICAgICAgICAgICBjb25uLmNhX2NlcnRzID0gY2VydF9sb2MKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGNvbm4uY2FfY2VydF9kaXIgPSBjZXJ0X2xvYwogICAgICAgIGVsc2U6CiAgICAgICAgICAgIGNvbm4uY2VydF9yZXFzID0gJ0NFUlRfTk9ORScKICAgICAgICAgICAgY29ubi5jYV9jZXJ0cyA9IE5vbmUKICAgICAgICAgICAgY29ubi5jYV9jZXJ0X2RpciA9IE5vbmUKCiAgICAgICAgaWYgY2VydDoKICAgICAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UoY2VydCwgYmFzZXN0cmluZyk6CiAgICAgICAgICAgICAgICBjb25uLmNlcnRfZmlsZSA9IGNlcnRbMF0KICAgICAgICAgICAgICAgIGNvbm4ua2V5X2ZpbGUgPSBjZXJ0WzFdCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBjb25uLmNlcnRfZmlsZSA9IGNlcnQKICAgICAgICAgICAgICAgIGNvbm4ua2V5X2ZpbGUgPSBOb25lCiAgICAgICAgICAgIGlmIGNvbm4uY2VydF9maWxlIGFuZCBub3Qgb3MucGF0aC5leGlzdHMoY29ubi5jZXJ0X2ZpbGUpOgogICAgICAgICAgICAgICAgcmFpc2UgSU9FcnJvcigiQ291bGQgbm90IGZpbmQgdGhlIFRMUyBjZXJ0aWZpY2F0ZSBmaWxlLCAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnZhbGlkIHBhdGg6IHt9Ii5mb3JtYXQoY29ubi5jZXJ0X2ZpbGUpKQogICAgICAgICAgICBpZiBjb25uLmtleV9maWxlIGFuZCBub3Qgb3MucGF0aC5leGlzdHMoY29ubi5rZXlfZmlsZSk6CiAgICAgICAgICAgICAgICByYWlzZSBJT0Vycm9yKCJDb3VsZCBub3QgZmluZCB0aGUgVExTIGtleSBmaWxlLCAiCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJpbnZhbGlkIHBhdGg6IHt9Ii5mb3JtYXQoY29ubi5rZXlfZmlsZSkpCgogICAgZGVmIGJ1aWxkX3Jlc3BvbnNlKHNlbGYsIHJlcSwgcmVzcCk6CiAgICAgICAgIiIiQnVpbGRzIGEgOmNsYXNzOmBSZXNwb25zZSA8cmVxdWVzdHMuUmVzcG9uc2U+YCBvYmplY3QgZnJvbSBhIHVybGxpYjMKICAgICAgICByZXNwb25zZS4gVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIHVzZXIgY29kZSwgYW5kIGlzIG9ubHkgZXhwb3NlZAogICAgICAgIGZvciB1c2Ugd2hlbiBzdWJjbGFzc2luZyB0aGUKICAgICAgICA6Y2xhc3M6YEhUVFBBZGFwdGVyIDxyZXF1ZXN0cy5hZGFwdGVycy5IVFRQQWRhcHRlcj5gCgogICAgICAgIDpwYXJhbSByZXE6IFRoZSA6Y2xhc3M6YFByZXBhcmVkUmVxdWVzdCA8UHJlcGFyZWRSZXF1ZXN0PmAgdXNlZCB0byBnZW5lcmF0ZSB0aGUgcmVzcG9uc2UuCiAgICAgICAgOnBhcmFtIHJlc3A6IFRoZSB1cmxsaWIzIHJlc3BvbnNlIG9iamVjdC4KICAgICAgICA6cnR5cGU6IHJlcXVlc3RzLlJlc3BvbnNlCiAgICAgICAgIiIiCiAgICAgICAgcmVzcG9uc2UgPSBSZXNwb25zZSgpCgogICAgICAgICMgRmFsbGJhY2sgdG8gTm9uZSBpZiB0aGVyZSdzIG5vIHN0YXR1c19jb2RlLCBmb3Igd2hhdGV2ZXIgcmVhc29uLgogICAgICAgIHJlc3BvbnNlLnN0YXR1c19jb2RlID0gZ2V0YXR0cihyZXNwLCAnc3RhdHVzJywgTm9uZSkKCiAgICAgICAgIyBNYWtlIGhlYWRlcnMgY2FzZS1pbnNlbnNpdGl2ZS4KICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gQ2FzZUluc2Vuc2l0aXZlRGljdChnZXRhdHRyKHJlc3AsICdoZWFkZXJzJywge30pKQoKICAgICAgICAjIFNldCBlbmNvZGluZy4KICAgICAgICByZXNwb25zZS5lbmNvZGluZyA9IGdldF9lbmNvZGluZ19mcm9tX2hlYWRlcnMocmVzcG9uc2UuaGVhZGVycykKICAgICAgICByZXNwb25zZS5yYXcgPSByZXNwCiAgICAgICAgcmVzcG9uc2UucmVhc29uID0gcmVzcG9uc2UucmF3LnJlYXNvbgoKICAgICAgICBpZiBpc2luc3RhbmNlKHJlcS51cmwsIGJ5dGVzKToKICAgICAgICAgICAgcmVzcG9uc2UudXJsID0gcmVxLnVybC5kZWNvZGUoJ3V0Zi04JykKICAgICAgICBlbHNlOgogICAgICAgICAgICByZXNwb25zZS51cmwgPSByZXEudXJsCgogICAgICAgICMgQWRkIG5ldyBjb29raWVzIGZyb20gdGhlIHNlcnZlci4KICAgICAgICBleHRyYWN0X2Nvb2tpZXNfdG9famFyKHJlc3BvbnNlLmNvb2tpZXMsIHJlcSwgcmVzcCkKCiAgICAgICAgIyBHaXZlIHRoZSBSZXNwb25zZSBzb21lIGNvbnRleHQuCiAgICAgICAgcmVzcG9uc2UucmVxdWVzdCA9IHJlcQogICAgICAgIHJlc3BvbnNlLmNvbm5lY3Rpb24gPSBzZWxmCgogICAgICAgIHJldHVybiByZXNwb25zZQoKICAgIGRlZiBnZXRfY29ubmVjdGlvbihzZWxmLCB1cmwsIHByb3hpZXM9Tm9uZSk6CiAgICAgICAgIiIiUmV0dXJucyBhIHVybGxpYjMgY29ubmVjdGlvbiBmb3IgdGhlIGdpdmVuIFVSTC4gVGhpcyBzaG91bGQgbm90IGJlCiAgICAgICAgY2FsbGVkIGZyb20gdXNlciBjb2RlLCBhbmQgaXMgb25seSBleHBvc2VkIGZvciB1c2Ugd2hlbiBzdWJjbGFzc2luZyB0aGUKICAgICAgICA6Y2xhc3M6YEhUVFBBZGFwdGVyIDxyZXF1ZXN0cy5hZGFwdGVycy5IVFRQQWRhcHRlcj5gLgoKICAgICAgICA6cGFyYW0gdXJsOiBUaGUgVVJMIHRvIGNvbm5lY3QgdG8uCiAgICAgICAgOnBhcmFtIHByb3hpZXM6IChvcHRpb25hbCkgQSBSZXF1ZXN0cy1zdHlsZSBkaWN0aW9uYXJ5IG9mIHByb3hpZXMgdXNlZCBvbiB0aGlzIHJlcXVlc3QuCiAgICAgICAgOnJ0eXBlOiB1cmxsaWIzLkNvbm5lY3Rpb25Qb29sCiAgICAgICAgIiIiCiAgICAgICAgcHJveHkgPSBzZWxlY3RfcHJveHkodXJsLCBwcm94aWVzKQoKICAgICAgICBpZiBwcm94eToKICAgICAgICAgICAgcHJveHkgPSBwcmVwZW5kX3NjaGVtZV9pZl9uZWVkZWQocHJveHksICdodHRwJykKICAgICAgICAgICAgcHJveHlfdXJsID0gcGFyc2VfdXJsKHByb3h5KQogICAgICAgICAgICBpZiBub3QgcHJveHlfdXJsLmhvc3Q6CiAgICAgICAgICAgICAgICByYWlzZSBJbnZhbGlkUHJveHlVUkwoIlBsZWFzZSBjaGVjayBwcm94eSBVUkwuIEl0IGlzIG1hbGZvcm1lZCIKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiIGFuZCBjb3VsZCBiZSBtaXNzaW5nIHRoZSBob3N0LiIpCiAgICAgICAgICAgIHByb3h5X21hbmFnZXIgPSBzZWxmLnByb3h5X21hbmFnZXJfZm9yKHByb3h5KQogICAgICAgICAgICBjb25uID0gcHJveHlfbWFuYWdlci5jb25uZWN0aW9uX2Zyb21fdXJsKHVybCkKICAgICAgICBlbHNlOgogICAgICAgICAgICAjIE9ubHkgc2NoZW1lIHNob3VsZCBiZSBsb3dlciBjYXNlCiAgICAgICAgICAgIHBhcnNlZCA9IHVybHBhcnNlKHVybCkKICAgICAgICAgICAgdXJsID0gcGFyc2VkLmdldHVybCgpCiAgICAgICAgICAgIGNvbm4gPSBzZWxmLnBvb2xtYW5hZ2VyLmNvbm5lY3Rpb25fZnJvbV91cmwodXJsKQoKICAgICAgICByZXR1cm4gY29ubgoKICAgIGRlZiBjbG9zZShzZWxmKToKICAgICAgICAiIiJEaXNwb3NlcyBvZiBhbnkgaW50ZXJuYWwgc3RhdGUuCgogICAgICAgIEN1cnJlbnRseSwgdGhpcyBjbG9zZXMgdGhlIFBvb2xNYW5hZ2VyIGFuZCBhbnkgYWN0aXZlIFByb3h5TWFuYWdlciwKICAgICAgICB3aGljaCBjbG9zZXMgYW55IHBvb2xlZCBjb25uZWN0aW9ucy4KICAgICAgICAiIiIKICAgICAgICBzZWxmLnBvb2xtYW5hZ2VyLmNsZWFyKCkKICAgICAgICBmb3IgcHJveHkgaW4gc2VsZi5wcm94eV9tYW5hZ2VyLnZhbHVlcygpOgogICAgICAgICAgICBwcm94eS5jbGVhcigpCgogICAgZGVmIHJlcXVlc3RfdXJsKHNlbGYsIHJlcXVlc3QsIHByb3hpZXMpOgogICAgICAgICIiIk9idGFpbiB0aGUgdXJsIHRvIHVzZSB3aGVuIG1ha2luZyB0aGUgZmluYWwgcmVxdWVzdC4KCiAgICAgICAgSWYgdGhlIG1lc3NhZ2UgaXMgYmVpbmcgc2VudCB0aHJvdWdoIGEgSFRUUCBwcm94eSwgdGhlIGZ1bGwgVVJMIGhhcyB0bwogICAgICAgIGJlIHVzZWQuIE90aGVyd2lzZSwgd2Ugc2hvdWxkIG9ubHkgdXNlIHRoZSBwYXRoIHBvcnRpb24gb2YgdGhlIFVSTC4KCiAgICAgICAgVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIHVzZXIgY29kZSwgYW5kIGlzIG9ubHkgZXhwb3NlZCBmb3IgdXNlCiAgICAgICAgd2hlbiBzdWJjbGFzc2luZyB0aGUKICAgICAgICA6Y2xhc3M6YEhUVFBBZGFwdGVyIDxyZXF1ZXN0cy5hZGFwdGVycy5IVFRQQWRhcHRlcj5gLgoKICAgICAgICA6cGFyYW0gcmVxdWVzdDogVGhlIDpjbGFzczpgUHJlcGFyZWRSZXF1ZXN0IDxQcmVwYXJlZFJlcXVlc3Q+YCBiZWluZyBzZW50LgogICAgICAgIDpwYXJhbSBwcm94aWVzOiBBIGRpY3Rpb25hcnkgb2Ygc2NoZW1lcyBvciBzY2hlbWVzIGFuZCBob3N0cyB0byBwcm94eSBVUkxzLgogICAgICAgIDpydHlwZTogc3RyCiAgICAgICAgIiIiCiAgICAgICAgcHJveHkgPSBzZWxlY3RfcHJveHkocmVxdWVzdC51cmwsIHByb3hpZXMpCiAgICAgICAgc2NoZW1lID0gdXJscGFyc2UocmVxdWVzdC51cmwpLnNjaGVtZQoKICAgICAgICBpc19wcm94aWVkX2h0dHBfcmVxdWVzdCA9IChwcm94eSBhbmQgc2NoZW1lICE9ICdodHRwcycpCiAgICAgICAgdXNpbmdfc29ja3NfcHJveHkgPSBGYWxzZQogICAgICAgIGlmIHByb3h5OgogICAgICAgICAgICBwcm94eV9zY2hlbWUgPSB1cmxwYXJzZShwcm94eSkuc2NoZW1lLmxvd2VyKCkKICAgICAgICAgICAgdXNpbmdfc29ja3NfcHJveHkgPSBwcm94eV9zY2hlbWUuc3RhcnRzd2l0aCgnc29ja3MnKQoKICAgICAgICB1cmwgPSByZXF1ZXN0LnBhdGhfdXJsCiAgICAgICAgaWYgaXNfcHJveGllZF9odHRwX3JlcXVlc3QgYW5kIG5vdCB1c2luZ19zb2Nrc19wcm94eToKICAgICAgICAgICAgdXJsID0gdXJsZGVmcmFnYXV0aChyZXF1ZXN0LnVybCkKCiAgICAgICAgcmV0dXJuIHVybAoKICAgIGRlZiBhZGRfaGVhZGVycyhzZWxmLCByZXF1ZXN0LCAqKmt3YXJncyk6CiAgICAgICAgIiIiQWRkIGFueSBoZWFkZXJzIG5lZWRlZCBieSB0aGUgY29ubmVjdGlvbi4gQXMgb2YgdjIuMCB0aGlzIGRvZXMKICAgICAgICBub3RoaW5nIGJ5IGRlZmF1bHQsIGJ1dCBpcyBsZWZ0IGZvciBvdmVycmlkaW5nIGJ5IHVzZXJzIHRoYXQgc3ViY2xhc3MKICAgICAgICB0aGUgOmNsYXNzOmBIVFRQQWRhcHRlciA8cmVxdWVzdHMuYWRhcHRlcnMuSFRUUEFkYXB0ZXI+YC4KCiAgICAgICAgVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBmcm9tIHVzZXIgY29kZSwgYW5kIGlzIG9ubHkgZXhwb3NlZCBmb3IgdXNlCiAgICAgICAgd2hlbiBzdWJjbGFzc2luZyB0aGUKICAgICAgICA6Y2xhc3M6YEhUVFBBZGFwdGVyIDxyZXF1ZXN0cy5hZGFwdGVycy5IVFRQQWRhcHRlcj5gLgoKICAgICAgICA6cGFyYW0gcmVxdWVzdDogVGhlIDpjbGFzczpgUHJlcGFyZWRSZXF1ZXN0IDxQcmVwYXJlZFJlcXVlc3Q+YCB0byBhZGQgaGVhZGVycyB0by4KICAgICAgICA6cGFyYW0ga3dhcmdzOiBUaGUga2V5d29yZCBhcmd1bWVudHMgZnJvbSB0aGUgY2FsbCB0byBzZW5kKCkuCiAgICAgICAgIiIiCiAgICAgICAgcGFzcwoKICAgIGRlZiBwcm94eV9oZWFkZXJzKHNlbGYsIHByb3h5KToKICAgICAgICAiIiJSZXR1cm5zIGEgZGljdGlvbmFyeSBvZiB0aGUgaGVhZGVycyB0byBhZGQgdG8gYW55IHJlcXVlc3Qgc2VudAogICAgICAgIHRocm91Z2ggYSBwcm94eS4gVGhpcyB3b3JrcyB3aXRoIHVybGxpYjMgbWFnaWMgdG8gZW5zdXJlIHRoYXQgdGhleSBhcmUKICAgICAgICBjb3JyZWN0bHkgc2VudCB0byB0aGUgcHJveHksIHJhdGhlciB0aGFuIGluIGEgdHVubmVsbGVkIHJlcXVlc3QgaWYKICAgICAgICBDT05ORUNUIGlzIGJlaW5nIHVzZWQuCgogICAgICAgIFRoaXMgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZnJvbSB1c2VyIGNvZGUsIGFuZCBpcyBvbmx5IGV4cG9zZWQgZm9yIHVzZQogICAgICAgIHdoZW4gc3ViY2xhc3NpbmcgdGhlCiAgICAgICAgOmNsYXNzOmBIVFRQQWRhcHRlciA8cmVxdWVzdHMuYWRhcHRlcnMuSFRUUEFkYXB0ZXI+YC4KCiAgICAgICAgOnBhcmFtIHByb3h5OiBUaGUgdXJsIG9mIHRoZSBwcm94eSBiZWluZyB1c2VkIGZvciB0aGlzIHJlcXVlc3QuCiAgICAgICAgOnJ0eXBlOiBkaWN0CiAgICAgICAgIiIiCiAgICAgICAgaGVhZGVycyA9IHt9CiAgICAgICAgdXNlcm5hbWUsIHBhc3N3b3JkID0gZ2V0X2F1dGhfZnJvbV91cmwocHJveHkpCgogICAgICAgIGlmIHVzZXJuYW1lOgogICAgICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSBfYmFzaWNfYXV0aF9zdHIodXNlcm5hbWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCkKCiAgICAgICAgcmV0dXJuIGhlYWRlcnMKCiAgICBkZWYgc2VuZChzZWxmLCByZXF1ZXN0LCBzdHJlYW09RmFsc2UsIHRpbWVvdXQ9Tm9uZSwgdmVyaWZ5PVRydWUsIGNlcnQ9Tm9uZSwgcHJveGllcz1Ob25lKToKICAgICAgICAiIiJTZW5kcyBQcmVwYXJlZFJlcXVlc3Qgb2JqZWN0LiBSZXR1cm5zIFJlc3BvbnNlIG9iamVjdC4KCiAgICAgICAgOnBhcmFtIHJlcXVlc3Q6IFRoZSA6Y2xhc3M6YFByZXBhcmVkUmVxdWVzdCA8UHJlcGFyZWRSZXF1ZXN0PmAgYmVpbmcgc2VudC4KICAgICAgICA6cGFyYW0gc3RyZWFtOiAob3B0aW9uYWwpIFdoZXRoZXIgdG8gc3RyZWFtIHRoZSByZXF1ZXN0IGNvbnRlbnQuCiAgICAgICAgOnBhcmFtIHRpbWVvdXQ6IChvcHRpb25hbCkgSG93IGxvbmcgdG8gd2FpdCBmb3IgdGhlIHNlcnZlciB0byBzZW5kCiAgICAgICAgICAgIGRhdGEgYmVmb3JlIGdpdmluZyB1cCwgYXMgYSBmbG9hdCwgb3IgYSA6cmVmOmAoY29ubmVjdCB0aW1lb3V0LAogICAgICAgICAgICByZWFkIHRpbWVvdXQpIDx0aW1lb3V0cz5gIHR1cGxlLgogICAgICAgIDp0eXBlIHRpbWVvdXQ6IGZsb2F0IG9yIHR1cGxlIG9yIHVybGxpYjMgVGltZW91dCBvYmplY3QKICAgICAgICA6cGFyYW0gdmVyaWZ5OiAob3B0aW9uYWwpIEVpdGhlciBhIGJvb2xlYW4sIGluIHdoaWNoIGNhc2UgaXQgY29udHJvbHMgd2hldGhlcgogICAgICAgICAgICB3ZSB2ZXJpZnkgdGhlIHNlcnZlcidzIFRMUyBjZXJ0aWZpY2F0ZSwgb3IgYSBzdHJpbmcsIGluIHdoaWNoIGNhc2UgaXQKICAgICAgICAgICAgbXVzdCBiZSBhIHBhdGggdG8gYSBDQSBidW5kbGUgdG8gdXNlCiAgICAgICAgOnBhcmFtIGNlcnQ6IChvcHRpb25hbCkgQW55IHVzZXItcHJvdmlkZWQgU1NMIGNlcnRpZmljYXRlIHRvIGJlIHRydXN0ZWQuCiAgICAgICAgOnBhcmFtIHByb3hpZXM6IChvcHRpb25hbCkgVGhlIHByb3hpZXMgZGljdGlvbmFyeSB0byBhcHBseSB0byB0aGUgcmVxdWVzdC4KICAgICAgICA6cnR5cGU6IHJlcXVlc3RzLlJlc3BvbnNlCiAgICAgICAgIiIiCgogICAgICAgIHRyeToKICAgICAgICAgICAgY29ubiA9IHNlbGYuZ2V0X2Nvbm5lY3Rpb24ocmVxdWVzdC51cmwsIHByb3hpZXMpCiAgICAgICAgZXhjZXB0IExvY2F0aW9uVmFsdWVFcnJvciBhcyBlOgogICAgICAgICAgICByYWlzZSBJbnZhbGlkVVJMKGUsIHJlcXVlc3Q9cmVxdWVzdCkKCiAgICAgICAgc2VsZi5jZXJ0X3ZlcmlmeShjb25uLCByZXF1ZXN0LnVybCwgdmVyaWZ5LCBjZXJ0KQogICAgICAgIHVybCA9IHNlbGYucmVxdWVzdF91cmwocmVxdWVzdCwgcHJveGllcykKICAgICAgICBzZWxmLmFkZF9oZWFkZXJzKHJlcXVlc3QsIHN0cmVhbT1zdHJlYW0sIHRpbWVvdXQ9dGltZW91dCwgdmVyaWZ5PXZlcmlmeSwgY2VydD1jZXJ0LCBwcm94aWVzPXByb3hpZXMpCgogICAgICAgIGNodW5rZWQgPSBub3QgKHJlcXVlc3QuYm9keSBpcyBOb25lIG9yICdDb250ZW50LUxlbmd0aCcgaW4gcmVxdWVzdC5oZWFkZXJzKQoKICAgICAgICBpZiBpc2luc3RhbmNlKHRpbWVvdXQsIHR1cGxlKToKICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgY29ubmVjdCwgcmVhZCA9IHRpbWVvdXQKICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBUaW1lb3V0U2F1Y2UoY29ubmVjdD1jb25uZWN0LCByZWFkPXJlYWQpCiAgICAgICAgICAgIGV4Y2VwdCBWYWx1ZUVycm9yIGFzIGU6CiAgICAgICAgICAgICAgICAjIHRoaXMgbWF5IHJhaXNlIGEgc3RyaW5nIGZvcm1hdHRpbmcgZXJyb3IuCiAgICAgICAgICAgICAgICBlcnIgPSAoIkludmFsaWQgdGltZW91dCB7fS4gUGFzcyBhIChjb25uZWN0LCByZWFkKSAiCiAgICAgICAgICAgICAgICAgICAgICAgInRpbWVvdXQgdHVwbGUsIG9yIGEgc2luZ2xlIGZsb2F0IHRvIHNldCAiCiAgICAgICAgICAgICAgICAgICAgICAgImJvdGggdGltZW91dHMgdG8gdGhlIHNhbWUgdmFsdWUiLmZvcm1hdCh0aW1lb3V0KSkKICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoZXJyKQogICAgICAgIGVsaWYgaXNpbnN0YW5jZSh0aW1lb3V0LCBUaW1lb3V0U2F1Y2UpOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgdGltZW91dCA9IFRpbWVvdXRTYXVjZShjb25uZWN0PXRpbWVvdXQsIHJlYWQ9dGltZW91dCkKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBpZiBub3QgY2h1bmtlZDoKICAgICAgICAgICAgICAgIHJlc3AgPSBjb25uLnVybG9wZW4oCiAgICAgICAgICAgICAgICAgICAgbWV0aG9kPXJlcXVlc3QubWV0aG9kLAogICAgICAgICAgICAgICAgICAgIHVybD11cmwsCiAgICAgICAgICAgICAgICAgICAgYm9keT1yZXF1ZXN0LmJvZHksCiAgICAgICAgICAgICAgICAgICAgaGVhZGVycz1yZXF1ZXN0LmhlYWRlcnMsCiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3Q9RmFsc2UsCiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0X3NhbWVfaG9zdD1GYWxzZSwKICAgICAgICAgICAgICAgICAgICBwcmVsb2FkX2NvbnRlbnQ9RmFsc2UsCiAgICAgICAgICAgICAgICAgICAgZGVjb2RlX2NvbnRlbnQ9RmFsc2UsCiAgICAgICAgICAgICAgICAgICAgcmV0cmllcz1zZWxmLm1heF9yZXRyaWVzLAogICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ9dGltZW91dAogICAgICAgICAgICAgICAgKQoKICAgICAgICAgICAgIyBTZW5kIHRoZSByZXF1ZXN0LgogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgaWYgaGFzYXR0cihjb25uLCAncHJveHlfcG9vbCcpOgogICAgICAgICAgICAgICAgICAgIGNvbm4gPSBjb25uLnByb3h5X3Bvb2wKCiAgICAgICAgICAgICAgICBsb3dfY29ubiA9IGNvbm4uX2dldF9jb25uKHRpbWVvdXQ9REVGQVVMVF9QT09MX1RJTUVPVVQpCgogICAgICAgICAgICAgICAgdHJ5OgogICAgICAgICAgICAgICAgICAgIHNraXBfaG9zdCA9ICdIb3N0JyBpbiByZXF1ZXN0LmhlYWRlcnMKICAgICAgICAgICAgICAgICAgICBsb3dfY29ubi5wdXRyZXF1ZXN0KHJlcXVlc3QubWV0aG9kLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcF9hY2NlcHRfZW5jb2Rpbmc9VHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfaG9zdD1za2lwX2hvc3QpCgogICAgICAgICAgICAgICAgICAgIGZvciBoZWFkZXIsIHZhbHVlIGluIHJlcXVlc3QuaGVhZGVycy5pdGVtcygpOgogICAgICAgICAgICAgICAgICAgICAgICBsb3dfY29ubi5wdXRoZWFkZXIoaGVhZGVyLCB2YWx1ZSkKCiAgICAgICAgICAgICAgICAgICAgbG93X2Nvbm4uZW5kaGVhZGVycygpCgogICAgICAgICAgICAgICAgICAgIGZvciBpIGluIHJlcXVlc3QuYm9keToKICAgICAgICAgICAgICAgICAgICAgICAgbG93X2Nvbm4uc2VuZChoZXgobGVuKGkpKVsyOl0uZW5jb2RlKCd1dGYtOCcpKQogICAgICAgICAgICAgICAgICAgICAgICBsb3dfY29ubi5zZW5kKGInXHJcbicpCiAgICAgICAgICAgICAgICAgICAgICAgIGxvd19jb25uLnNlbmQoaSkKICAgICAgICAgICAgICAgICAgICAgICAgbG93X2Nvbm4uc2VuZChiJ1xyXG4nKQogICAgICAgICAgICAgICAgICAgIGxvd19jb25uLnNlbmQoYicwXHJcblxyXG4nKQoKICAgICAgICAgICAgICAgICAgICAjIFJlY2VpdmUgdGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlcgogICAgICAgICAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgICAgICAgICAgIyBGb3IgUHl0aG9uIDIuNywgdXNlIGJ1ZmZlcmluZyBvZiBIVFRQIHJlc3BvbnNlcwogICAgICAgICAgICAgICAgICAgICAgICByID0gbG93X2Nvbm4uZ2V0cmVzcG9uc2UoYnVmZmVyaW5nPVRydWUpCiAgICAgICAgICAgICAgICAgICAgZXhjZXB0IFR5cGVFcnJvcjoKICAgICAgICAgICAgICAgICAgICAgICAgIyBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIFB5dGhvbiAzLjMrCiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSBsb3dfY29ubi5nZXRyZXNwb25zZSgpCgogICAgICAgICAgICAgICAgICAgIHJlc3AgPSBIVFRQUmVzcG9uc2UuZnJvbV9odHRwbGliKAogICAgICAgICAgICAgICAgICAgICAgICByLAogICAgICAgICAgICAgICAgICAgICAgICBwb29sPWNvbm4sCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb249bG93X2Nvbm4sCiAgICAgICAgICAgICAgICAgICAgICAgIHByZWxvYWRfY29udGVudD1GYWxzZSwKICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlX2NvbnRlbnQ9RmFsc2UKICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAgICAgICAgICAgIyBJZiB3ZSBoaXQgYW55IHByb2JsZW1zIGhlcmUsIGNsZWFuIHVwIHRoZSBjb25uZWN0aW9uLgogICAgICAgICAgICAgICAgICAgICMgVGhlbiwgcmVyYWlzZSBzbyB0aGF0IHdlIGNhbiBoYW5kbGUgdGhlIGFjdHVhbCBleGNlcHRpb24uCiAgICAgICAgICAgICAgICAgICAgbG93X2Nvbm4uY2xvc2UoKQogICAgICAgICAgICAgICAgICAgIHJhaXNlCgogICAgICAgIGV4Y2VwdCAoUHJvdG9jb2xFcnJvciwgc29ja2V0LmVycm9yKSBhcyBlcnI6CiAgICAgICAgICAgIHJhaXNlIENvbm5lY3Rpb25FcnJvcihlcnIsIHJlcXVlc3Q9cmVxdWVzdCkKCiAgICAgICAgZXhjZXB0IE1heFJldHJ5RXJyb3IgYXMgZToKICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShlLnJlYXNvbiwgQ29ubmVjdFRpbWVvdXRFcnJvcik6CiAgICAgICAgICAgICAgICAjIFRPRE86IFJlbW92ZSB0aGlzIGluIDMuMC4wOiBzZWUgIzI4MTEKICAgICAgICAgICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGUucmVhc29uLCBOZXdDb25uZWN0aW9uRXJyb3IpOgogICAgICAgICAgICAgICAgICAgIHJhaXNlIENvbm5lY3RUaW1lb3V0KGUsIHJlcXVlc3Q9cmVxdWVzdCkKCiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoZS5yZWFzb24sIFJlc3BvbnNlRXJyb3IpOgogICAgICAgICAgICAgICAgcmFpc2UgUmV0cnlFcnJvcihlLCByZXF1ZXN0PXJlcXVlc3QpCgogICAgICAgICAgICBpZiBpc2luc3RhbmNlKGUucmVhc29uLCBfUHJveHlFcnJvcik6CiAgICAgICAgICAgICAgICByYWlzZSBQcm94eUVycm9yKGUsIHJlcXVlc3Q9cmVxdWVzdCkKCiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoZS5yZWFzb24sIF9TU0xFcnJvcik6CiAgICAgICAgICAgICAgICAjIFRoaXMgYnJhbmNoIGlzIGZvciB1cmxsaWIzIHYxLjIyIGFuZCBsYXRlci4KICAgICAgICAgICAgICAgIHJhaXNlIFNTTEVycm9yKGUsIHJlcXVlc3Q9cmVxdWVzdCkKCiAgICAgICAgICAgIHJhaXNlIENvbm5lY3Rpb25FcnJvcihlLCByZXF1ZXN0PXJlcXVlc3QpCgogICAgICAgIGV4Y2VwdCBDbG9zZWRQb29sRXJyb3IgYXMgZToKICAgICAgICAgICAgcmFpc2UgQ29ubmVjdGlvbkVycm9yKGUsIHJlcXVlc3Q9cmVxdWVzdCkKCiAgICAgICAgZXhjZXB0IF9Qcm94eUVycm9yIGFzIGU6CiAgICAgICAgICAgIHJhaXNlIFByb3h5RXJyb3IoZSkKCiAgICAgICAgZXhjZXB0IChfU1NMRXJyb3IsIF9IVFRQRXJyb3IpIGFzIGU6CiAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoZSwgX1NTTEVycm9yKToKICAgICAgICAgICAgICAgICMgVGhpcyBicmFuY2ggaXMgZm9yIHVybGxpYjMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxLjIyCiAgICAgICAgICAgICAgICByYWlzZSBTU0xFcnJvcihlLCByZXF1ZXN0PXJlcXVlc3QpCiAgICAgICAgICAgIGVsaWYgaXNpbnN0YW5jZShlLCBSZWFkVGltZW91dEVycm9yKToKICAgICAgICAgICAgICAgIHJhaXNlIFJlYWRUaW1lb3V0KGUsIHJlcXVlc3Q9cmVxdWVzdCkKICAgICAgICAgICAgZWxpZiBpc2luc3RhbmNlKGUsIF9JbnZhbGlkSGVhZGVyKToKICAgICAgICAgICAgICAgIHJhaXNlIEludmFsaWRIZWFkZXIoZSwgcmVxdWVzdD1yZXF1ZXN0KQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgcmFpc2UKCiAgICAgICAgcmV0dXJuIHNlbGYuYnVpbGRfcmVzcG9uc2UocmVxdWVzdCwgcmVzcCkK
