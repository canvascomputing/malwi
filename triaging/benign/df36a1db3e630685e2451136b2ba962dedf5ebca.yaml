statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/urllib3/contrib/socks.py
  contents:
  - name: SOCKSConnection._new_conn
    score: 0.0
    code: |-
      def _new_conn(self):
              """
              Establish a new connection via the SOCKS proxy.
              """
              extra_kw = {}
              if self.source_address:
                  extra_kw['source_address'] = self.source_address

              if self.socket_options:
                  extra_kw['socket_options'] = self.socket_options

              try:
                  conn = socks.create_connection(
                      (self.host, self.port),
                      proxy_type=self._socks_options['socks_version'],
                      proxy_addr=self._socks_options['proxy_host'],
                      proxy_port=self._socks_options['proxy_port'],
                      proxy_username=self._socks_options['username'],
                      proxy_password=self._socks_options['password'],
                      proxy_rdns=self._socks_options['rdns'],
                      timeout=self.timeout,
                      **extra_kw
                  )

              except SocketTimeout as e:
                  raise ConnectTimeoutError(
                      self, "Connection to %s timed out. (connect timeout=%s)" %
                      (self.host, self.timeout))

              except socks.ProxyError as e:
                  # This is fragile as hell, but it seems to be the only way to raise
                  # useful errors here.
                  if e.socket_err:
                      error = e.socket_err
                      if isinstance(error, SocketTimeout):
                          raise ConnectTimeoutError(
                              self,
                              "Connection to %s timed out. (connect timeout=%s)" %
                              (self.host, self.timeout)
                          )
                      else:
                          raise NewConnectionError(
                              self,
                              "Failed to establish a new connection: %s" % error
                          )
                  else:
                      raise NewConnectionError(
                          self,
                          "Failed to establish a new connection: %s" % e
                      )

              except SocketError as e:  # Defensive: PySocks should catch all these.
                  raise NewConnectionError(
                      self, "Failed to establish a new connection: %s" % e)

              return conn
    tokens: resume build_map store_fast extra_kw load_fast self load_attr source_address pop_jump_if_false TO_NUMBER load_fast self load_attr source_address load_fast extra_kw load_const source_address store_subscr load_fast self load_attr socket_options pop_jump_if_false TO_NUMBER load_fast self load_attr socket_options load_fast extra_kw load_const socket_options store_subscr nop load_global socks load_attr STRING_LEN_S_ENT_HIGH load_fast self load_attr host load_fast self load_attr port build_tuple build_tuple load_fast self load_attr _socks_options load_const socks_version binary_subscr load_fast self load_attr _socks_options load_const proxy_host binary_subscr load_fast self load_attr _socks_options load_const proxy_port binary_subscr load_fast self load_attr _socks_options load_const username binary_subscr load_fast self load_attr _socks_options load_const password binary_subscr load_fast self load_attr _socks_options load_const rdns binary_subscr load_fast self load_attr timeout load_const build_const_key_map load_fast extra_kw dict_merge call_function_ex store_fast conn load_fast conn return_value push_exc_info load_global SocketTimeout check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global STRING_LEN_S_ENT_HIGH load_fast self load_const Connection to load_fast self load_attr host format_value INTEGER load_const STRING_LEN_S_ENT_HIGH load_fast self load_attr timeout format_value INTEGER load_const ) build_string call raise_varargs load_const store_fast e delete_fast e reraise load_global socks load_attr ProxyError check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_fast e load_attr socket_err pop_jump_if_false TO_NUMBER load_fast e load_attr socket_err store_fast error load_global isinstance load_fast error load_global SocketTimeout call pop_jump_if_false TO_NUMBER load_global STRING_LEN_S_ENT_HIGH load_fast self load_const Connection to load_fast self load_attr host format_value INTEGER load_const STRING_LEN_S_ENT_HIGH load_fast self load_attr timeout format_value INTEGER load_const ) build_string call raise_varargs load_global STRING_LEN_S_ENT_HIGH load_fast self load_const STRING_LEN_S_ENT_HIGH load_fast error binary_op % call raise_varargs load_global STRING_LEN_S_ENT_HIGH load_fast self load_const STRING_LEN_S_ENT_HIGH load_fast e binary_op % call raise_varargs load_const store_fast e delete_fast e reraise load_global SocketError check_exc_match pop_jump_if_false TO_NUMBER store_fast e load_global STRING_LEN_S_ENT_HIGH load_fast self load_const STRING_LEN_S_ENT_HIGH load_fast e binary_op % call raise_varargs load_const store_fast e delete_fast e reraise reraise copy pop_except reraise
    hash: 756a278d05939ba24ef7a02b4df3ceafa3b094b989916e4909be8e0ad0e58390
sources:
  .repo_cache/malicious_repos/pypi_malregistry/urlib3/1.21.1/urlib3-1.21.1/urlib3-1.21.1/urllib3/contrib/socks.py: IyAtKi0gY29kaW5nOiB1dGYtOCAtKi0KIiIiClRoaXMgbW9kdWxlIGNvbnRhaW5zIHByb3Zpc2lvbmFsIHN1cHBvcnQgZm9yIFNPQ0tTIHByb3hpZXMgZnJvbSB3aXRoaW4KdXJsbGliMy4gVGhpcyBtb2R1bGUgc3VwcG9ydHMgU09DS1M0IChzcGVjaWZpY2FsbHkgdGhlIFNPQ0tTNEEgdmFyaWFudCkgYW5kClNPQ0tTNS4gVG8gZW5hYmxlIGl0cyBmdW5jdGlvbmFsaXR5LCBlaXRoZXIgaW5zdGFsbCBQeVNvY2tzIG9yIGluc3RhbGwgdGhpcwptb2R1bGUgd2l0aCB0aGUgYGBzb2Nrc2BgIGV4dHJhLgoKVGhlIFNPQ0tTIGltcGxlbWVudGF0aW9uIHN1cHBvcnRzIHRoZSBmdWxsIHJhbmdlIG9mIHVybGxpYjMgZmVhdHVyZXMuIEl0IGFsc28Kc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBTT0NLUyBmZWF0dXJlczoKCi0gU09DS1M0Ci0gU09DS1M0YQotIFNPQ0tTNQotIFVzZXJuYW1lcyBhbmQgcGFzc3dvcmRzIGZvciB0aGUgU09DS1MgcHJveHkKCktub3duIExpbWl0YXRpb25zOgoKLSBDdXJyZW50bHkgUHlTb2NrcyBkb2VzIG5vdCBzdXBwb3J0IGNvbnRhY3RpbmcgcmVtb3RlIHdlYnNpdGVzIHZpYSBsaXRlcmFsCiAgSVB2NiBhZGRyZXNzZXMuIEFueSBzdWNoIGNvbm5lY3Rpb24gYXR0ZW1wdCB3aWxsIGZhaWwuIFlvdSBtdXN0IHVzZSBhIGRvbWFpbgogIG5hbWUuCi0gQ3VycmVudGx5IFB5U29ja3MgZG9lcyBub3Qgc3VwcG9ydCBJUHY2IGNvbm5lY3Rpb25zIHRvIHRoZSBTT0NLUyBwcm94eS4gQW55CiAgc3VjaCBjb25uZWN0aW9uIGF0dGVtcHQgd2lsbCBmYWlsLgoiIiIKZnJvbSBfX2Z1dHVyZV9fIGltcG9ydCBhYnNvbHV0ZV9pbXBvcnQKCnRyeToKICAgIGltcG9ydCBzb2NrcwpleGNlcHQgSW1wb3J0RXJyb3I6CiAgICBpbXBvcnQgd2FybmluZ3MKICAgIGZyb20gLi5leGNlcHRpb25zIGltcG9ydCBEZXBlbmRlbmN5V2FybmluZwoKICAgIHdhcm5pbmdzLndhcm4oKAogICAgICAgICdTT0NLUyBzdXBwb3J0IGluIHVybGxpYjMgcmVxdWlyZXMgdGhlIGluc3RhbGxhdGlvbiBvZiBvcHRpb25hbCAnCiAgICAgICAgJ2RlcGVuZGVuY2llczogc3BlY2lmaWNhbGx5LCBQeVNvY2tzLiAgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnCiAgICAgICAgJ2h0dHBzOi8vdXJsbGliMy5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3QvY29udHJpYi5odG1sI3NvY2tzLXByb3hpZXMnCiAgICAgICAgKSwKICAgICAgICBEZXBlbmRlbmN5V2FybmluZwogICAgKQogICAgcmFpc2UKCmZyb20gc29ja2V0IGltcG9ydCBlcnJvciBhcyBTb2NrZXRFcnJvciwgdGltZW91dCBhcyBTb2NrZXRUaW1lb3V0Cgpmcm9tIC4uY29ubmVjdGlvbiBpbXBvcnQgKAogICAgSFRUUENvbm5lY3Rpb24sIEhUVFBTQ29ubmVjdGlvbgopCmZyb20gLi5jb25uZWN0aW9ucG9vbCBpbXBvcnQgKAogICAgSFRUUENvbm5lY3Rpb25Qb29sLCBIVFRQU0Nvbm5lY3Rpb25Qb29sCikKZnJvbSAuLmV4Y2VwdGlvbnMgaW1wb3J0IENvbm5lY3RUaW1lb3V0RXJyb3IsIE5ld0Nvbm5lY3Rpb25FcnJvcgpmcm9tIC4ucG9vbG1hbmFnZXIgaW1wb3J0IFBvb2xNYW5hZ2VyCmZyb20gLi51dGlsLnVybCBpbXBvcnQgcGFyc2VfdXJsCgp0cnk6CiAgICBpbXBvcnQgc3NsCmV4Y2VwdCBJbXBvcnRFcnJvcjoKICAgIHNzbCA9IE5vbmUKCgpjbGFzcyBTT0NLU0Nvbm5lY3Rpb24oSFRUUENvbm5lY3Rpb24pOgogICAgIiIiCiAgICBBIHBsYWluLXRleHQgSFRUUCBjb25uZWN0aW9uIHRoYXQgY29ubmVjdHMgdmlhIGEgU09DS1MgcHJveHkuCiAgICAiIiIKICAgIGRlZiBfX2luaXRfXyhzZWxmLCAqYXJncywgKiprd2FyZ3MpOgogICAgICAgIHNlbGYuX3NvY2tzX29wdGlvbnMgPSBrd2FyZ3MucG9wKCdfc29ja3Nfb3B0aW9ucycpCiAgICAgICAgc3VwZXIoU09DS1NDb25uZWN0aW9uLCBzZWxmKS5fX2luaXRfXygqYXJncywgKiprd2FyZ3MpCgogICAgZGVmIF9uZXdfY29ubihzZWxmKToKICAgICAgICAiIiIKICAgICAgICBFc3RhYmxpc2ggYSBuZXcgY29ubmVjdGlvbiB2aWEgdGhlIFNPQ0tTIHByb3h5LgogICAgICAgICIiIgogICAgICAgIGV4dHJhX2t3ID0ge30KICAgICAgICBpZiBzZWxmLnNvdXJjZV9hZGRyZXNzOgogICAgICAgICAgICBleHRyYV9rd1snc291cmNlX2FkZHJlc3MnXSA9IHNlbGYuc291cmNlX2FkZHJlc3MKCiAgICAgICAgaWYgc2VsZi5zb2NrZXRfb3B0aW9uczoKICAgICAgICAgICAgZXh0cmFfa3dbJ3NvY2tldF9vcHRpb25zJ10gPSBzZWxmLnNvY2tldF9vcHRpb25zCgogICAgICAgIHRyeToKICAgICAgICAgICAgY29ubiA9IHNvY2tzLmNyZWF0ZV9jb25uZWN0aW9uKAogICAgICAgICAgICAgICAgKHNlbGYuaG9zdCwgc2VsZi5wb3J0KSwKICAgICAgICAgICAgICAgIHByb3h5X3R5cGU9c2VsZi5fc29ja3Nfb3B0aW9uc1snc29ja3NfdmVyc2lvbiddLAogICAgICAgICAgICAgICAgcHJveHlfYWRkcj1zZWxmLl9zb2Nrc19vcHRpb25zWydwcm94eV9ob3N0J10sCiAgICAgICAgICAgICAgICBwcm94eV9wb3J0PXNlbGYuX3NvY2tzX29wdGlvbnNbJ3Byb3h5X3BvcnQnXSwKICAgICAgICAgICAgICAgIHByb3h5X3VzZXJuYW1lPXNlbGYuX3NvY2tzX29wdGlvbnNbJ3VzZXJuYW1lJ10sCiAgICAgICAgICAgICAgICBwcm94eV9wYXNzd29yZD1zZWxmLl9zb2Nrc19vcHRpb25zWydwYXNzd29yZCddLAogICAgICAgICAgICAgICAgcHJveHlfcmRucz1zZWxmLl9zb2Nrc19vcHRpb25zWydyZG5zJ10sCiAgICAgICAgICAgICAgICB0aW1lb3V0PXNlbGYudGltZW91dCwKICAgICAgICAgICAgICAgICoqZXh0cmFfa3cKICAgICAgICAgICAgKQoKICAgICAgICBleGNlcHQgU29ja2V0VGltZW91dCBhcyBlOgogICAgICAgICAgICByYWlzZSBDb25uZWN0VGltZW91dEVycm9yKAogICAgICAgICAgICAgICAgc2VsZiwgIkNvbm5lY3Rpb24gdG8gJXMgdGltZWQgb3V0LiAoY29ubmVjdCB0aW1lb3V0PSVzKSIgJQogICAgICAgICAgICAgICAgKHNlbGYuaG9zdCwgc2VsZi50aW1lb3V0KSkKCiAgICAgICAgZXhjZXB0IHNvY2tzLlByb3h5RXJyb3IgYXMgZToKICAgICAgICAgICAgIyBUaGlzIGlzIGZyYWdpbGUgYXMgaGVsbCwgYnV0IGl0IHNlZW1zIHRvIGJlIHRoZSBvbmx5IHdheSB0byByYWlzZQogICAgICAgICAgICAjIHVzZWZ1bCBlcnJvcnMgaGVyZS4KICAgICAgICAgICAgaWYgZS5zb2NrZXRfZXJyOgogICAgICAgICAgICAgICAgZXJyb3IgPSBlLnNvY2tldF9lcnIKICAgICAgICAgICAgICAgIGlmIGlzaW5zdGFuY2UoZXJyb3IsIFNvY2tldFRpbWVvdXQpOgogICAgICAgICAgICAgICAgICAgIHJhaXNlIENvbm5lY3RUaW1lb3V0RXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYsCiAgICAgICAgICAgICAgICAgICAgICAgICJDb25uZWN0aW9uIHRvICVzIHRpbWVkIG91dC4gKGNvbm5lY3QgdGltZW91dD0lcykiICUKICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGYuaG9zdCwgc2VsZi50aW1lb3V0KQogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICAgICAgcmFpc2UgTmV3Q29ubmVjdGlvbkVycm9yKAogICAgICAgICAgICAgICAgICAgICAgICBzZWxmLAogICAgICAgICAgICAgICAgICAgICAgICAiRmFpbGVkIHRvIGVzdGFibGlzaCBhIG5ldyBjb25uZWN0aW9uOiAlcyIgJSBlcnJvcgogICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHJhaXNlIE5ld0Nvbm5lY3Rpb25FcnJvcigKICAgICAgICAgICAgICAgICAgICBzZWxmLAogICAgICAgICAgICAgICAgICAgICJGYWlsZWQgdG8gZXN0YWJsaXNoIGEgbmV3IGNvbm5lY3Rpb246ICVzIiAlIGUKICAgICAgICAgICAgICAgICkKCiAgICAgICAgZXhjZXB0IFNvY2tldEVycm9yIGFzIGU6ICAjIERlZmVuc2l2ZTogUHlTb2NrcyBzaG91bGQgY2F0Y2ggYWxsIHRoZXNlLgogICAgICAgICAgICByYWlzZSBOZXdDb25uZWN0aW9uRXJyb3IoCiAgICAgICAgICAgICAgICBzZWxmLCAiRmFpbGVkIHRvIGVzdGFibGlzaCBhIG5ldyBjb25uZWN0aW9uOiAlcyIgJSBlKQoKICAgICAgICByZXR1cm4gY29ubgoKCiMgV2UgZG9uJ3QgbmVlZCB0byBkdXBsaWNhdGUgdGhlIFZlcmlmaWVkL1VudmVyaWZpZWQgZGlzdGluY3Rpb24gZnJvbQojIHVybGxpYjMvY29ubmVjdGlvbi5weSBoZXJlIGJlY2F1c2UgdGhlIEhUVFBTQ29ubmVjdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuCiMgY29ycmVjdGx5IHNldCB0byBlaXRoZXIgdGhlIFZlcmlmaWVkIG9yIFVudmVyaWZpZWQgZm9ybSBieSB0aGF0IG1vZHVsZS4gVGhpcwojIG1lYW5zIHRoZSBTT0NLU0hUVFBTQ29ubmVjdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdGhlIGNvcnJlY3QgdHlwZS4KY2xhc3MgU09DS1NIVFRQU0Nvbm5lY3Rpb24oU09DS1NDb25uZWN0aW9uLCBIVFRQU0Nvbm5lY3Rpb24pOgogICAgcGFzcwoKCmNsYXNzIFNPQ0tTSFRUUENvbm5lY3Rpb25Qb29sKEhUVFBDb25uZWN0aW9uUG9vbCk6CiAgICBDb25uZWN0aW9uQ2xzID0gU09DS1NDb25uZWN0aW9uCgoKY2xhc3MgU09DS1NIVFRQU0Nvbm5lY3Rpb25Qb29sKEhUVFBTQ29ubmVjdGlvblBvb2wpOgogICAgQ29ubmVjdGlvbkNscyA9IFNPQ0tTSFRUUFNDb25uZWN0aW9uCgoKY2xhc3MgU09DS1NQcm94eU1hbmFnZXIoUG9vbE1hbmFnZXIpOgogICAgIiIiCiAgICBBIHZlcnNpb24gb2YgdGhlIHVybGxpYjMgUHJveHlNYW5hZ2VyIHRoYXQgcm91dGVzIGNvbm5lY3Rpb25zIHZpYSB0aGUKICAgIGRlZmluZWQgU09DS1MgcHJveHkuCiAgICAiIiIKICAgIHBvb2xfY2xhc3Nlc19ieV9zY2hlbWUgPSB7CiAgICAgICAgJ2h0dHAnOiBTT0NLU0hUVFBDb25uZWN0aW9uUG9vbCwKICAgICAgICAnaHR0cHMnOiBTT0NLU0hUVFBTQ29ubmVjdGlvblBvb2wsCiAgICB9CgogICAgZGVmIF9faW5pdF9fKHNlbGYsIHByb3h5X3VybCwgdXNlcm5hbWU9Tm9uZSwgcGFzc3dvcmQ9Tm9uZSwKICAgICAgICAgICAgICAgICBudW1fcG9vbHM9MTAsIGhlYWRlcnM9Tm9uZSwgKipjb25uZWN0aW9uX3Bvb2xfa3cpOgogICAgICAgIHBhcnNlZCA9IHBhcnNlX3VybChwcm94eV91cmwpCgogICAgICAgIGlmIHBhcnNlZC5zY2hlbWUgPT0gJ3NvY2tzNSc6CiAgICAgICAgICAgIHNvY2tzX3ZlcnNpb24gPSBzb2Nrcy5QUk9YWV9UWVBFX1NPQ0tTNQogICAgICAgICAgICByZG5zID0gRmFsc2UKICAgICAgICBlbGlmIHBhcnNlZC5zY2hlbWUgPT0gJ3NvY2tzNWgnOgogICAgICAgICAgICBzb2Nrc192ZXJzaW9uID0gc29ja3MuUFJPWFlfVFlQRV9TT0NLUzUKICAgICAgICAgICAgcmRucyA9IFRydWUKICAgICAgICBlbGlmIHBhcnNlZC5zY2hlbWUgPT0gJ3NvY2tzNCc6CiAgICAgICAgICAgIHNvY2tzX3ZlcnNpb24gPSBzb2Nrcy5QUk9YWV9UWVBFX1NPQ0tTNAogICAgICAgICAgICByZG5zID0gRmFsc2UKICAgICAgICBlbGlmIHBhcnNlZC5zY2hlbWUgPT0gJ3NvY2tzNGEnOgogICAgICAgICAgICBzb2Nrc192ZXJzaW9uID0gc29ja3MuUFJPWFlfVFlQRV9TT0NLUzQKICAgICAgICAgICAgcmRucyA9IFRydWUKICAgICAgICBlbHNlOgogICAgICAgICAgICByYWlzZSBWYWx1ZUVycm9yKAogICAgICAgICAgICAgICAgIlVuYWJsZSB0byBkZXRlcm1pbmUgU09DS1MgdmVyc2lvbiBmcm9tICVzIiAlIHByb3h5X3VybAogICAgICAgICAgICApCgogICAgICAgIHNlbGYucHJveHlfdXJsID0gcHJveHlfdXJsCgogICAgICAgIHNvY2tzX29wdGlvbnMgPSB7CiAgICAgICAgICAgICdzb2Nrc192ZXJzaW9uJzogc29ja3NfdmVyc2lvbiwKICAgICAgICAgICAgJ3Byb3h5X2hvc3QnOiBwYXJzZWQuaG9zdCwKICAgICAgICAgICAgJ3Byb3h5X3BvcnQnOiBwYXJzZWQucG9ydCwKICAgICAgICAgICAgJ3VzZXJuYW1lJzogdXNlcm5hbWUsCiAgICAgICAgICAgICdwYXNzd29yZCc6IHBhc3N3b3JkLAogICAgICAgICAgICAncmRucyc6IHJkbnMKICAgICAgICB9CiAgICAgICAgY29ubmVjdGlvbl9wb29sX2t3Wydfc29ja3Nfb3B0aW9ucyddID0gc29ja3Nfb3B0aW9ucwoKICAgICAgICBzdXBlcihTT0NLU1Byb3h5TWFuYWdlciwgc2VsZikuX19pbml0X18oCiAgICAgICAgICAgIG51bV9wb29scywgaGVhZGVycywgKipjb25uZWN0aW9uX3Bvb2xfa3cKICAgICAgICApCgogICAgICAgIHNlbGYucG9vbF9jbGFzc2VzX2J5X3NjaGVtZSA9IFNPQ0tTUHJveHlNYW5hZ2VyLnBvb2xfY2xhc3Nlc19ieV9zY2hlbWUK
