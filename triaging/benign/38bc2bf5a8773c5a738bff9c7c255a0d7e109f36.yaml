statistics:
  total_files: 1
  skipped_files: 0.0
  processed_objects: 1
  malicious_objects: 0
details:
- path: .repo_cache/malicious_repos/pypi_malregistry/discord-py-v13/1.3/discord_py_v13-1.3-py3-none-any/discord-py-v13/guild.py
  contents:
  - name: <module>
    score: 0.0
    code: |-
      # -*- coding: utf-8 -*-

      """
      The MIT License (MIT)

      Copyright (c) 2015-present Rapptz

      Permission is hereby granted, free of charge, to any person obtaining a
      copy of this software and associated documentation files (the "Software"),
      to deal in the Software without restriction, including without limitation
      the rights to use, copy, modify, merge, publish, distribute, sublicense,
      and/or sell copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following conditions:

      The above copyright notice and this permission notice shall be included in
      all copies or substantial portions of the Software.

      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
      DEALINGS IN THE SOFTWARE.
      """

      import copy
      from collections import namedtuple

      from . import utils
      from .role import Role
      from .member import Member, VoiceState
      from .emoji import Emoji
      from .errors import InvalidData
      from .permissions import PermissionOverwrite
      from .colour import Colour
      from .errors import InvalidArgument, ClientException
      from .channel import *
      from .enums import VoiceRegion, ChannelType, try_enum, VerificationLevel, ContentFilter, NotificationLevel
      from .mixins import Hashable
      from .user import User
      from .invite import Invite
      from .iterators import AuditLogIterator, MemberIterator
      from .widget import Widget
      from .asset import Asset
      from .flags import SystemChannelFlags
      from .integrations import Integration


      BanEntry = namedtuple('BanEntry', 'reason user')
      _GuildLimit = namedtuple('_GuildLimit', 'emoji bitrate filesize')


      class Guild(Hashable):
          """Represents a Discord guild.

          This is referred to as a "server" in the official Discord UI.

          .. container:: operations

              .. describe:: x == y

                  Checks if two guilds are equal.

              .. describe:: x != y

                  Checks if two guilds are not equal.

              .. describe:: hash(x)

                  Returns the guild's hash.

              .. describe:: str(x)

                  Returns the guild's name.

          Attributes
          ----------
          name: :class:`str`
              The guild name.
          emojis: Tuple[:class:`Emoji`, ...]
              All emojis that the guild owns.
          region: :class:`VoiceRegion`
              The region the guild belongs on. There is a chance that the region
              will be a :class:`str` if the value is not recognised by the enumerator.
          afk_timeout: :class:`int`
              The timeout to get sent to the AFK channel.
          afk_channel: Optional[:class:`VoiceChannel`]
              The channel that denotes the AFK channel. ``None`` if it doesn't exist.
          icon: Optional[:class:`str`]
              The guild's icon.
          id: :class:`int`
              The guild's ID.
          owner_id: :class:`int`
              The guild owner's ID. Use :attr:`Guild.owner` instead.
          unavailable: :class:`bool`
              Indicates if the guild is unavailable. If this is ``True`` then the
              reliability of other attributes outside of :attr:`Guild.id` is slim and they might
              all be ``None``. It is best to not do anything with the guild if it is unavailable.

              Check the :func:`on_guild_unavailable` and :func:`on_guild_available` events.
          max_presences: Optional[:class:`int`]
              The maximum amount of presences for the guild.
          max_members: Optional[:class:`int`]
              The maximum amount of members for the guild.

              .. note::

                  This attribute is only available via :meth:`.Client.fetch_guild`.
          max_video_channel_users: Optional[:class:`int`]
              The maximum amount of users in a video channel.

              .. versionadded:: 1.4
          banner: Optional[:class:`str`]
              The guild's banner.
          description: Optional[:class:`str`]
              The guild's description.
          mfa_level: :class:`int`
              Indicates the guild's two factor authorisation level. If this value is 0 then
              the guild does not require 2FA for their administrative members. If the value is
              1 then they do.
          verification_level: :class:`VerificationLevel`
              The guild's verification level.
          explicit_content_filter: :class:`ContentFilter`
              The guild's explicit content filter.
          default_notifications: :class:`NotificationLevel`
              The guild's notification settings.
          features: List[:class:`str`]
              A list of features that the guild has. They are currently as follows:

              - ``VIP_REGIONS``: Guild has VIP voice regions
              - ``VANITY_URL``: Guild can have a vanity invite URL (e.g. discord.gg/discord-api)
              - ``INVITE_SPLASH``: Guild's invite page can have a special splash.
              - ``VERIFIED``: Guild is a verified server.
              - ``PARTNERED``: Guild is a partnered server.
              - ``MORE_EMOJI``: Guild is allowed to have more than 50 custom emoji.
              - ``DISCOVERABLE``: Guild shows up in Server Discovery.
              - ``FEATURABLE``: Guild is able to be featured in Server Discovery.
              - ``COMMUNITY``: Guild is a community server.
              - ``COMMERCE``: Guild can sell things using store channels.
              - ``PUBLIC``: Guild is a public guild.
              - ``NEWS``: Guild can create news channels.
              - ``BANNER``: Guild can upload and use a banner (i.e. :meth:`banner_url`).
              - ``ANIMATED_ICON``: Guild can upload an animated icon.
              - ``PUBLIC_DISABLED``: Guild cannot be public.
              - ``WELCOME_SCREEN_ENABLED``: Guild has enabled the welcome screen
              - ``MEMBER_VERIFICATION_GATE_ENABLED``: Guild has Membership Screening enabled.
              - ``PREVIEW_ENABLED``: Guild can be viewed before being accepted via Membership Screening.

          splash: Optional[:class:`str`]
              The guild's invite splash.
          premium_tier: :class:`int`
              The premium tier for this guild. Corresponds to "Nitro Server" in the official UI.
              The number goes from 0 to 3 inclusive.
          premium_subscription_count: :class:`int`
              The number of "boosts" this guild currently has.
          preferred_locale: Optional[:class:`str`]
              The preferred locale for the guild. Used when filtering Server Discovery
              results to a specific language.
          discovery_splash: :class:`str`
              The guild's discovery splash.

              .. versionadded:: 1.3
          """

          __slots__ = ('afk_timeout', 'afk_channel', '_members', '_channels', 'icon',
                       'name', 'id', 'unavailable', 'banner', 'region', '_state',
                       '_roles', '_member_count', '_large',
                       'owner_id', 'mfa_level', 'emojis', 'features',
                       'verification_level', 'explicit_content_filter', 'splash',
                       '_voice_states', '_system_channel_id', 'default_notifications',
                       'description', 'max_presences', 'max_members', 'max_video_channel_users',
                       'premium_tier', 'premium_subscription_count', '_system_channel_flags',
                       'preferred_locale', 'discovery_splash', '_rules_channel_id',
                       '_public_updates_channel_id')

          _PREMIUM_GUILD_LIMITS = {
              None: _GuildLimit(emoji=50, bitrate=96e3, filesize=8388608),
              0: _GuildLimit(emoji=50, bitrate=96e3, filesize=8388608),
              1: _GuildLimit(emoji=100, bitrate=128e3, filesize=8388608),
              2: _GuildLimit(emoji=150, bitrate=256e3, filesize=52428800),
              3: _GuildLimit(emoji=250, bitrate=384e3, filesize=104857600),
          }

          def __init__(self, *, data, state):
              self._channels = {}
              self._members = {}
              self._voice_states = {}
              self._state = state
              self._from_data(data)

          def _add_channel(self, channel):
              self._channels[channel.id] = channel

          def _remove_channel(self, channel):
              self._channels.pop(channel.id, None)

          def _voice_state_for(self, user_id):
              return self._voice_states.get(user_id)

          def _add_member(self, member):
              self._members[member.id] = member

          def _remove_member(self, member):
              self._members.pop(member.id, None)

          def __str__(self):
              return self.name or ''

          def __repr__(self):
              attrs = (
                  'id', 'name', 'shard_id', 'chunked'
              )
              resolved = ['%s=%r' % (attr, getattr(self, attr)) for attr in attrs]
              resolved.append('member_count=%r' % getattr(self, '_member_count', None))
              return '<Guild %s>' % ' '.join(resolved)

          def _update_voice_state(self, data, channel_id):
              user_id = int(data['user_id'])
              channel = self.get_channel(channel_id)
              try:
                  # check if we should remove the voice state from cache
                  if channel is None:
                      after = self._voice_states.pop(user_id)
                  else:
                      after = self._voice_states[user_id]

                  before = copy.copy(after)
                  after._update(data, channel)
              except KeyError:
                  # if we're here then we're getting added into the cache
                  after = VoiceState(data=data, channel=channel)
                  before = VoiceState(data=data, channel=None)
                  self._voice_states[user_id] = after

              member = self.get_member(user_id)
              if member is None:
                  try:
                      member = Member(data=data['member'], state=self._state, guild=self)
                  except KeyError:
                      member = None

              return member, before, after

          def _add_role(self, role):
              # roles get added to the bottom (position 1, pos 0 is @everyone)
              # so since self.roles has the @everyone role, we can't increment
              # its position because it's stuck at position 0. Luckily x += False
              # is equivalent to adding 0. So we cast the position to a bool and
              # increment it.
              for r in self._roles.values():
                  r.position += (not r.is_default())

              self._roles[role.id] = role

          def _remove_role(self, role_id):
              # this raises KeyError if it fails..
              role = self._roles.pop(role_id)

              # since it didn't, we can change the positions now
              # basically the same as above except we only decrement
              # the position if we're above the role we deleted.
              for r in self._roles.values():
                  r.position -= r.position > role.position

              return role

          def _from_data(self, guild):
              # according to Stan, this is always available even if the guild is unavailable
              # I don't have this guarantee when someone updates the guild.
              member_count = guild.get('member_count', None)
              if member_count is not None:
                  self._member_count = member_count

              self.name = guild.get('name')
              self.region = try_enum(VoiceRegion, guild.get('region'))
              self.verification_level = try_enum(VerificationLevel, guild.get('verification_level'))
              self.default_notifications = try_enum(NotificationLevel, guild.get('default_message_notifications'))
              self.explicit_content_filter = try_enum(ContentFilter, guild.get('explicit_content_filter', 0))
              self.afk_timeout = guild.get('afk_timeout')
              self.icon = guild.get('icon')
              self.banner = guild.get('banner')
              self.unavailable = guild.get('unavailable', False)
              self.id = int(guild['id'])
              self._roles = {}
              state = self._state # speed up attribute access
              for r in guild.get('roles', []):
                  role = Role(guild=self, data=r, state=state)
                  self._roles[role.id] = role

              self.mfa_level = guild.get('mfa_level')
              self.emojis = tuple(map(lambda d: state.store_emoji(self, d), guild.get('emojis', [])))
              self.features = guild.get('features', [])
              self.splash = guild.get('splash')
              self._system_channel_id = utils._get_as_snowflake(guild, 'system_channel_id')
              self.description = guild.get('description')
              self.max_presences = guild.get('max_presences')
              self.max_members = guild.get('max_members')
              self.max_video_channel_users = guild.get('max_video_channel_users')
              self.premium_tier = guild.get('premium_tier', 0)
              self.premium_subscription_count = guild.get('premium_subscription_count') or 0
              self._system_channel_flags = guild.get('system_channel_flags', 0)
              self.preferred_locale = guild.get('preferred_locale')
              self.discovery_splash = guild.get('discovery_splash')
              self._rules_channel_id = utils._get_as_snowflake(guild, 'rules_channel_id')
              self._public_updates_channel_id = utils._get_as_snowflake(guild, 'public_updates_channel_id')

              cache_online_members = self._state.member_cache_flags.online
              cache_joined = self._state.member_cache_flags.joined
              self_id = self._state.self_id
              for mdata in guild.get('members', []):
                  member = Member(data=mdata, guild=self, state=state)
                  if cache_joined or (cache_online_members and member.raw_status != 'offline') or member.id == self_id:
                      self._add_member(member)

              self._sync(guild)
              self._large = None if member_count is None else self._member_count >= 250

              self.owner_id = utils._get_as_snowflake(guild, 'owner_id')
              self.afk_channel = self.get_channel(utils._get_as_snowflake(guild, 'afk_channel_id'))

              for obj in guild.get('voice_states', []):
                  self._update_voice_state(obj, int(obj['channel_id']))

          def _sync(self, data):
              try:
                  self._large = data['large']
              except KeyError:
                  pass

              empty_tuple = tuple()
              for presence in data.get('presences', []):
                  user_id = int(presence['user']['id'])
                  member = self.get_member(user_id)
                  if member is not None:
                      member._presence_update(presence, empty_tuple)

              if 'channels' in data:
                  channels = data['channels']
                  for c in channels:
                      factory, ch_type = _channel_factory(c['type'])
                      if factory:
                          self._add_channel(factory(guild=self, data=c, state=self._state))

          @property
          def channels(self):
              """List[:class:`abc.GuildChannel`]: A list of channels that belongs to this guild."""
              return list(self._channels.values())

          @property
          def large(self):
              """:class:`bool`: Indicates if the guild is a 'large' guild.

              A large guild is defined as having more than ``large_threshold`` count
              members, which for this library is set to the maximum of 250.
              """
              if self._large is None:
                  try:
                      return self._member_count >= 250
                  except AttributeError:
                      return len(self._members) >= 250
              return self._large

          @property
          def voice_channels(self):
              """List[:class:`VoiceChannel`]: A list of voice channels that belongs to this guild.

              This is sorted by the position and are in UI order from top to bottom.
              """
              r = [ch for ch in self._channels.values() if isinstance(ch, VoiceChannel)]
              r.sort(key=lambda c: (c.position, c.id))
              return r

          @property
          def stage_channels(self):
              """List[:class:`StageChannel`]: A list of voice channels that belongs to this guild.

              .. versionadded:: 1.7

              This is sorted by the position and are in UI order from top to bottom.
              """
              r = [ch for ch in self._channels.values() if isinstance(ch, StageChannel)]
              r.sort(key=lambda c: (c.position, c.id))
              return r

          @property
          def me(self):
              """:class:`Member`: Similar to :attr:`Client.user` except an instance of :class:`Member`.
              This is essentially used to get the member version of yourself.
              """
              self_id = self._state.user.id
              return self.get_member(self_id)

          @property
          def voice_client(self):
              """Optional[:class:`VoiceProtocol`]: Returns the :class:`VoiceProtocol` associated with this guild, if any."""
              return self._state._get_voice_client(self.id)

          @property
          def text_channels(self):
              """List[:class:`TextChannel`]: A list of text channels that belongs to this guild.

              This is sorted by the position and are in UI order from top to bottom.
              """
              r = [ch for ch in self._channels.values() if isinstance(ch, TextChannel)]
              r.sort(key=lambda c: (c.position, c.id))
              return r

          @property
          def categories(self):
              """List[:class:`CategoryChannel`]: A list of categories that belongs to this guild.

              This is sorted by the position and are in UI order from top to bottom.
              """
              r = [ch for ch in self._channels.values() if isinstance(ch, CategoryChannel)]
              r.sort(key=lambda c: (c.position, c.id))
              return r

          def by_category(self):
              """Returns every :class:`CategoryChannel` and their associated channels.

              These channels and categories are sorted in the official Discord UI order.

              If the channels do not have a category, then the first element of the tuple is
              ``None``.

              Returns
              --------
              List[Tuple[Optional[:class:`CategoryChannel`], List[:class:`abc.GuildChannel`]]]:
                  The categories and their associated channels.
              """
              grouped = {}
              for channel in self._channels.values():
                  if isinstance(channel, CategoryChannel):
                      grouped.setdefault(channel.id, [])
                      continue

                  try:
                      grouped[channel.category_id].append(channel)
                  except KeyError:
                      grouped[channel.category_id] = [channel]

              def key(t):
                  k, v = t
                  return ((k.position, k.id) if k else (-1, -1), v)

              _get = self._channels.get
              as_list = [(_get(k), v) for k, v in grouped.items()]
              as_list.sort(key=key)
              for _, channels in as_list:
                  channels.sort(key=lambda c: (c._sorting_bucket, c.position, c.id))
              return as_list

          def get_channel(self, channel_id):
              """Returns a channel with the given ID.

              Parameters
              -----------
              channel_id: :class:`int`
                  The ID to search for.

              Returns
              --------
              Optional[:class:`.abc.GuildChannel`]
                  The returned channel or ``None`` if not found.
              """
              return self._channels.get(channel_id)

          @property
          def system_channel(self):
              """Optional[:class:`TextChannel`]: Returns the guild's channel used for system messages.

              If no channel is set, then this returns ``None``.
              """
              channel_id = self._system_channel_id
              return channel_id and self._channels.get(channel_id)

          @property
          def system_channel_flags(self):
              """:class:`SystemChannelFlags`: Returns the guild's system channel settings."""
              return SystemChannelFlags._from_value(self._system_channel_flags)

          @property
          def rules_channel(self):
              """Optional[:class:`TextChannel`]: Return's the guild's channel used for the rules.
              The guild must be a Community guild.

              If no channel is set, then this returns ``None``.

              .. versionadded:: 1.3
              """
              channel_id = self._rules_channel_id
              return channel_id and self._channels.get(channel_id)

          @property
          def public_updates_channel(self):
              """Optional[:class:`TextChannel`]: Return's the guild's channel where admins and
              moderators of the guilds receive notices from Discord. The guild must be a
              Community guild.

              If no channel is set, then this returns ``None``.

              .. versionadded:: 1.4
              """
              channel_id = self._public_updates_channel_id
              return channel_id and self._channels.get(channel_id)

          @property
          def emoji_limit(self):
              """:class:`int`: The maximum number of emoji slots this guild has."""
              more_emoji = 200 if 'MORE_EMOJI' in self.features else 50
              return max(more_emoji, self._PREMIUM_GUILD_LIMITS[self.premium_tier].emoji)

          @property
          def bitrate_limit(self):
              """:class:`float`: The maximum bitrate for voice channels this guild can have."""
              vip_guild = self._PREMIUM_GUILD_LIMITS[1].bitrate if 'VIP_REGIONS' in self.features else 96e3
              return max(vip_guild, self._PREMIUM_GUILD_LIMITS[self.premium_tier].bitrate)

          @property
          def filesize_limit(self):
              """:class:`int`: The maximum number of bytes files can have when uploaded to this guild."""
              return self._PREMIUM_GUILD_LIMITS[self.premium_tier].filesize

          @property
          def members(self):
              """List[:class:`Member`]: A list of members that belong to this guild."""
              return list(self._members.values())

          def get_member(self, user_id):
              """Returns a member with the given ID.

              Parameters
              -----------
              user_id: :class:`int`
                  The ID to search for.

              Returns
              --------
              Optional[:class:`Member`]
                  The member or ``None`` if not found.
              """
              return self._members.get(user_id)

          @property
          def premium_subscribers(self):
              """List[:class:`Member`]: A list of members who have "boosted" this guild."""
              return [member for member in self.members if member.premium_since is not None]

          @property
          def roles(self):
              """List[:class:`Role`]: Returns a :class:`list` of the guild's roles in hierarchy order.

              The first element of this list will be the lowest role in the
              hierarchy.
              """
              return sorted(self._roles.values())

          def get_role(self, role_id):
              """Returns a role with the given ID.

              Parameters
              -----------
              role_id: :class:`int`
                  The ID to search for.

              Returns
              --------
              Optional[:class:`Role`]
                  The role or ``None`` if not found.
              """
              return self._roles.get(role_id)

          @property
          def default_role(self):
              """:class:`Role`: Gets the @everyone role that all members have by default."""
              return self.get_role(self.id)

          @property
          def premium_subscriber_role(self):
              """Optional[:class:`Role`]: Gets the premium subscriber role, AKA "boost" role, in this guild.

              .. versionadded:: 1.6
              """
              for role in self._roles.values():
                  if role.is_premium_subscriber():
                      return role
              return None

          @property
          def self_role(self):
              """Optional[:class:`Role`]: Gets the role associated with this client's user, if any.

              .. versionadded:: 1.6
              """
              self_id = self._state.self_id
              for role in self._roles.values():
                  tags = role.tags
                  if tags and tags.bot_id == self_id:
                      return role
              return None

          @property
          def owner(self):
              """Optional[:class:`Member`]: The member that owns the guild."""
              return self.get_member(self.owner_id)

          @property
          def icon_url(self):
              """:class:`Asset`: Returns the guild's icon asset."""
              return self.icon_url_as()

          def is_icon_animated(self):
              """:class:`bool`: Returns True if the guild has an animated icon."""
              return bool(self.icon and self.icon.startswith('a_'))

          def icon_url_as(self, *, format=None, static_format='webp', size=1024):
              """Returns an :class:`Asset` for the guild's icon.

              The format must be one of 'webp', 'jpeg', 'jpg', 'png' or 'gif', and
              'gif' is only valid for animated avatars. The size must be a power of 2
              between 16 and 4096.

              Parameters
              -----------
              format: Optional[:class:`str`]
                  The format to attempt to convert the icon to.
                  If the format is ``None``, then it is automatically
                  detected into either 'gif' or static_format depending on the
                  icon being animated or not.
              static_format: Optional[:class:`str`]
                  Format to attempt to convert only non-animated icons to.
              size: :class:`int`
                  The size of the image to display.

              Raises
              ------
              InvalidArgument
                  Bad image format passed to ``format`` or invalid ``size``.

              Returns
              --------
              :class:`Asset`
                  The resulting CDN asset.
              """
              return Asset._from_guild_icon(self._state, self, format=format, static_format=static_format, size=size)

          @property
          def banner_url(self):
              """:class:`Asset`: Returns the guild's banner asset."""
              return self.banner_url_as()

          def banner_url_as(self, *, format='webp', size=2048):
              """Returns an :class:`Asset` for the guild's banner.

              The format must be one of 'webp', 'jpeg', or 'png'. The
              size must be a power of 2 between 16 and 4096.

              Parameters
              -----------
              format: :class:`str`
                  The format to attempt to convert the banner to.
              size: :class:`int`
                  The size of the image to display.

              Raises
              ------
              InvalidArgument
                  Bad image format passed to ``format`` or invalid ``size``.

              Returns
              --------
              :class:`Asset`
                  The resulting CDN asset.
              """
              return Asset._from_guild_image(self._state, self.id, self.banner, 'banners', format=format, size=size)

          @property
          def splash_url(self):
              """:class:`Asset`: Returns the guild's invite splash asset."""
              return self.splash_url_as()

          def splash_url_as(self, *, format='webp', size=2048):
              """Returns an :class:`Asset` for the guild's invite splash.

              The format must be one of 'webp', 'jpeg', 'jpg', or 'png'. The
              size must be a power of 2 between 16 and 4096.

              Parameters
              -----------
              format: :class:`str`
                  The format to attempt to convert the splash to.
              size: :class:`int`
                  The size of the image to display.

              Raises
              ------
              InvalidArgument
                  Bad image format passed to ``format`` or invalid ``size``.

              Returns
              --------
              :class:`Asset`
                  The resulting CDN asset.
              """
              return Asset._from_guild_image(self._state, self.id, self.splash, 'splashes', format=format, size=size)

          @property
          def discovery_splash_url(self):
              """:class:`Asset`: Returns the guild's discovery splash asset.

              .. versionadded:: 1.3
              """
              return self.discovery_splash_url_as()

          def discovery_splash_url_as(self, *, format='webp', size=2048):
              """Returns an :class:`Asset` for the guild's discovery splash.

              The format must be one of 'webp', 'jpeg', 'jpg', or 'png'. The
              size must be a power of 2 between 16 and 4096.

              .. versionadded:: 1.3

              Parameters
              -----------
              format: :class:`str`
                  The format to attempt to convert the splash to.
              size: :class:`int`
                  The size of the image to display.

              Raises
              ------
              InvalidArgument
                  Bad image format passed to ``format`` or invalid ``size``.

              Returns
              --------
              :class:`Asset`
                  The resulting CDN asset.
              """
              return Asset._from_guild_image(self._state, self.id, self.discovery_splash, 'discovery-splashes', format=format, size=size)

          @property
          def member_count(self):
              """:class:`int`: Returns the true member count regardless of it being loaded fully or not.

              .. warning::

                  Due to a Discord limitation, in order for this attribute to remain up-to-date and
                  accurate, it requires :attr:`Intents.members` to be specified.

              """
              return self._member_count

          @property
          def chunked(self):
              """:class:`bool`: Returns a boolean indicating if the guild is "chunked".

              A chunked guild means that :attr:`member_count` is equal to the
              number of members stored in the internal :attr:`members` cache.

              If this value returns ``False``, then you should request for
              offline members.
              """
              count = getattr(self, '_member_count', None)
              if count is None:
                  return False
              return count == len(self._members)

          @property
          def shard_id(self):
              """:class:`int`: Returns the shard ID for this guild if applicable."""
              count = self._state.shard_count
              if count is None:
                  return None
              return (self.id >> 22) % count

          @property
          def created_at(self):
              """:class:`datetime.datetime`: Returns the guild's creation time in UTC."""
              return utils.snowflake_time(self.id)

          def get_member_named(self, name):
              """Returns the first member found that matches the name provided.

              The name can have an optional discriminator argument, e.g. "Jake#0001"
              or "Jake" will both do the lookup. However the former will give a more
              precise result. Note that the discriminator must have all 4 digits
              for this to work.

              If a nickname is passed, then it is looked up via the nickname. Note
              however, that a nickname + discriminator combo will not lookup the nickname
              but rather the username + discriminator combo due to nickname + discriminator
              not being unique.

              If no member is found, ``None`` is returned.

              Parameters
              -----------
              name: :class:`str`
                  The name of the member to lookup with an optional discriminator.

              Returns
              --------
              Optional[:class:`Member`]
                  The member in this guild with the associated name. If not found
                  then ``None`` is returned.
              """

              result = None
              members = self.members
              if len(name) > 5 and name[-5] == '#':
                  # The 5 length is checking to see if #0000 is in the string,
                  # as a#0000 has a length of 6, the minimum for a potential
                  # discriminator lookup.
                  potential_discriminator = name[-4:]

                  # do the actual lookup and return if found
                  # if it isn't found then we'll do a full name lookup below.
                  result = utils.get(members, name=name[:-5], discriminator=potential_discriminator)
                  if result is not None:
                      return result

              def pred(m):
                  return m.nick == name or m.name == name

              return utils.find(pred, members)

          def _create_channel(self, name, overwrites, channel_type, category=None, **options):
              if overwrites is None:
                  overwrites = {}
              elif not isinstance(overwrites, dict):
                  raise InvalidArgument('overwrites parameter expects a dict.')

              perms = []
              for target, perm in overwrites.items():
                  if not isinstance(perm, PermissionOverwrite):
                      raise InvalidArgument('Expected PermissionOverwrite received {0.__name__}'.format(type(perm)))

                  allow, deny = perm.pair()
                  payload = {
                      'allow': allow.value,
                      'deny': deny.value,
                      'id': target.id
                  }

                  if isinstance(target, Role):
                      payload['type'] = 'role'
                  else:
                      payload['type'] = 'member'

                  perms.append(payload)

              try:
                  options['rate_limit_per_user'] = options.pop('slowmode_delay')
              except KeyError:
                  pass

              try:
                  rtc_region = options.pop('rtc_region')
              except KeyError:
                  pass
              else:
                  options['rtc_region'] = None if rtc_region is None else str(rtc_region)

              parent_id = category.id if category else None
              return self._state.http.create_channel(self.id, channel_type.value, name=name, parent_id=parent_id,
                                                     permission_overwrites=perms, **options)

          async def create_text_channel(self, name, *, overwrites=None, category=None, reason=None, **options):
              """|coro|

              Creates a :class:`TextChannel` for the guild.

              Note that you need the :attr:`~Permissions.manage_channels` permission
              to create the channel.

              The ``overwrites`` parameter can be used to create a 'secret'
              channel upon creation. This parameter expects a :class:`dict` of
              overwrites with the target (either a :class:`Member` or a :class:`Role`)
              as the key and a :class:`PermissionOverwrite` as the value.

              .. note::

                  Creating a channel of a specified position will not update the position of
                  other channels to follow suit. A follow-up call to :meth:`~TextChannel.edit`
                  will be required to update the position of the channel in the channel list.

              Examples
              ----------

              Creating a basic channel:

              .. code-block:: python3

                  channel = await guild.create_text_channel('cool-channel')

              Creating a "secret" channel:

              .. code-block:: python3

                  overwrites = {
                      guild.default_role: discord.PermissionOverwrite(read_messages=False),
                      guild.me: discord.PermissionOverwrite(read_messages=True)
                  }

                  channel = await guild.create_text_channel('secret', overwrites=overwrites)

              Parameters
              -----------
              name: :class:`str`
                  The channel's name.
              overwrites
                  A :class:`dict` of target (either a role or a member) to
                  :class:`PermissionOverwrite` to apply upon creation of a channel.
                  Useful for creating secret channels.
              category: Optional[:class:`CategoryChannel`]
                  The category to place the newly created channel under.
                  The permissions will be automatically synced to category if no
                  overwrites are provided.
              position: :class:`int`
                  The position in the channel list. This is a number that starts
                  at 0. e.g. the top channel is position 0.
              topic: Optional[:class:`str`]
                  The new channel's topic.
              slowmode_delay: :class:`int`
                  Specifies the slowmode rate limit for user in this channel, in seconds.
                  The maximum value possible is `21600`.
              nsfw: :class:`bool`
                  To mark the channel as NSFW or not.
              reason: Optional[:class:`str`]
                  The reason for creating this channel. Shows up on the audit log.

              Raises
              -------
              Forbidden
                  You do not have the proper permissions to create this channel.
              HTTPException
                  Creating the channel failed.
              InvalidArgument
                  The permission overwrite information is not in proper form.

              Returns
              -------
              :class:`TextChannel`
                  The channel that was just created.
              """
              data = await self._create_channel(name, overwrites, ChannelType.text, category, reason=reason, **options)
              channel = TextChannel(state=self._state, guild=self, data=data)

              # temporarily add to the cache
              self._channels[channel.id] = channel
              return channel

          async def create_voice_channel(self, name, *, overwrites=None, category=None, reason=None, **options):
              """|coro|

              This is similar to :meth:`create_text_channel` except makes a :class:`VoiceChannel` instead, in addition
              to having the following new parameters.

              Parameters
              -----------
              bitrate: :class:`int`
                  The channel's preferred audio bitrate in bits per second.
              user_limit: :class:`int`
                  The channel's limit for number of members that can be in a voice channel.
              rtc_region: Optional[:class:`VoiceRegion`]
                  The region for the voice channel's voice communication.
                  A value of ``None`` indicates automatic voice region detection.

                  .. versionadded:: 1.7

              Raises
              ------
              Forbidden
                  You do not have the proper permissions to create this channel.
              HTTPException
                  Creating the channel failed.
              InvalidArgument
                  The permission overwrite information is not in proper form.

              Returns
              -------
              :class:`VoiceChannel`
                  The channel that was just created.
              """
              data = await self._create_channel(name, overwrites, ChannelType.voice, category, reason=reason, **options)
              channel = VoiceChannel(state=self._state, guild=self, data=data)

              # temporarily add to the cache
              self._channels[channel.id] = channel
              return channel

          async def create_stage_channel(self, name, *, topic=None, category=None, overwrites=None, reason=None, position=None):
              """|coro|

              This is similar to :meth:`create_text_channel` except makes a :class:`StageChannel` instead.

              .. note::

                  The ``slowmode_delay`` and ``nsfw`` parameters are not supported in this function.

              .. versionadded:: 1.7

              Raises
              ------
              Forbidden
                  You do not have the proper permissions to create this channel.
              HTTPException
                  Creating the channel failed.
              InvalidArgument
                  The permission overwrite information is not in proper form.

              Returns
              -------
              :class:`StageChannel`
                  The channel that was just created.
              """
              data = await self._create_channel(name, overwrites, ChannelType.stage_voice, category, reason=reason, position=position, topic=topic)
              channel = StageChannel(state=self._state, guild=self, data=data)

              # temporarily add to the cache
              self._channels[channel.id] = channel
              return channel

          async def create_category(self, name, *, overwrites=None, reason=None, position=None):
              """|coro|

              Same as :meth:`create_text_channel` except makes a :class:`CategoryChannel` instead.

              .. note::

                  The ``category`` parameter is not supported in this function since categories
                  cannot have categories.

              Raises
              ------
              Forbidden
                  You do not have the proper permissions to create this channel.
              HTTPException
                  Creating the channel failed.
              InvalidArgument
                  The permission overwrite information is not in proper form.

              Returns
              -------
              :class:`CategoryChannel`
                  The channel that was just created.
              """
              data = await self._create_channel(name, overwrites, ChannelType.category, reason=reason, position=position)
              channel = CategoryChannel(state=self._state, guild=self, data=data)

              # temporarily add to the cache
              self._channels[channel.id] = channel
              return channel

          create_category_channel = create_category

          async def leave(self):
              """|coro|

              Leaves the guild.

              .. note::

                  You cannot leave the guild that you own, you must delete it instead
                  via :meth:`delete`.

              Raises
              --------
              HTTPException
                  Leaving the guild failed.
              """
              await self._state.http.leave_guild(self.id)

          async def delete(self):
              """|coro|

              Deletes the guild. You must be the guild owner to delete the
              guild.

              Raises
              --------
              HTTPException
                  Deleting the guild failed.
              Forbidden
                  You do not have permissions to delete the guild.
              """

              await self._state.http.delete_guild(self.id)

          async def edit(self, *, reason=None, **fields):
              """|coro|

              Edits the guild.

              You must have the :attr:`~Permissions.manage_guild` permission
              to edit the guild.

              .. versionchanged:: 1.4
                  The `rules_channel` and `public_updates_channel` keyword-only parameters were added.

              Parameters
              ----------
              name: :class:`str`
                  The new name of the guild.
              description: :class:`str`
                  The new description of the guild. This is only available to guilds that
                  contain ``PUBLIC`` in :attr:`Guild.features`.
              icon: :class:`bytes`
                  A :term:`py:bytes-like object` representing the icon. Only PNG/JPEG is supported.
                  GIF is only available to guilds that contain ``ANIMATED_ICON`` in :attr:`Guild.features`.
                  Could be ``None`` to denote removal of the icon.
              banner: :class:`bytes`
                  A :term:`py:bytes-like object` representing the banner.
                  Could be ``None`` to denote removal of the banner.
              splash: :class:`bytes`
                  A :term:`py:bytes-like object` representing the invite splash.
                  Only PNG/JPEG supported. Could be ``None`` to denote removing the
                  splash. This is only available to guilds that contain ``INVITE_SPLASH``
                  in :attr:`Guild.features`.
              region: :class:`VoiceRegion`
                  The new region for the guild's voice communication.
              afk_channel: Optional[:class:`VoiceChannel`]
                  The new channel that is the AFK channel. Could be ``None`` for no AFK channel.
              afk_timeout: :class:`int`
                  The number of seconds until someone is moved to the AFK channel.
              owner: :class:`Member`
                  The new owner of the guild to transfer ownership to. Note that you must
                  be owner of the guild to do this.
              verification_level: :class:`VerificationLevel`
                  The new verification level for the guild.
              default_notifications: :class:`NotificationLevel`
                  The new default notification level for the guild.
              explicit_content_filter: :class:`ContentFilter`
                  The new explicit content filter for the guild.
              vanity_code: :class:`str`
                  The new vanity code for the guild.
              system_channel: Optional[:class:`TextChannel`]
                  The new channel that is used for the system channel. Could be ``None`` for no system channel.
              system_channel_flags: :class:`SystemChannelFlags`
                  The new system channel settings to use with the new system channel.
              preferred_locale: :class:`str`
                  The new preferred locale for the guild. Used as the primary language in the guild.
                  If set, this must be an ISO 639 code, e.g. ``en-US`` or ``ja`` or ``zh-CN``.
              rules_channel: Optional[:class:`TextChannel`]
                  The new channel that is used for rules. This is only available to
                  guilds that contain ``PUBLIC`` in :attr:`Guild.features`. Could be ``None`` for no rules
                  channel.
              public_updates_channel: Optional[:class:`TextChannel`]
                  The new channel that is used for public updates from Discord. This is only available to
                  guilds that contain ``PUBLIC`` in :attr:`Guild.features`. Could be ``None`` for no
                  public updates channel.
              reason: Optional[:class:`str`]
                  The reason for editing this guild. Shows up on the audit log.

              Raises
              -------
              Forbidden
                  You do not have permissions to edit the guild.
              HTTPException
                  Editing the guild failed.
              InvalidArgument
                  The image format passed in to ``icon`` is invalid. It must be
                  PNG or JPG. This is also raised if you are not the owner of the
                  guild and request an ownership transfer.
              """

              http = self._state.http
              try:
                  icon_bytes = fields['icon']
              except KeyError:
                  icon = self.icon
              else:
                  if icon_bytes is not None:
                      icon = utils._bytes_to_base64_data(icon_bytes)
                  else:
                      icon = None

              try:
                  banner_bytes = fields['banner']
              except KeyError:
                  banner = self.banner
              else:
                  if banner_bytes is not None:
                      banner = utils._bytes_to_base64_data(banner_bytes)
                  else:
                      banner = None

              try:
                  vanity_code = fields['vanity_code']
              except KeyError:
                  pass
              else:
                  await http.change_vanity_code(self.id, vanity_code, reason=reason)

              try:
                  splash_bytes = fields['splash']
              except KeyError:
                  splash = self.splash
              else:
                  if splash_bytes is not None:
                      splash = utils._bytes_to_base64_data(splash_bytes)
                  else:
                      splash = None

              fields['icon'] = icon
              fields['banner'] = banner
              fields['splash'] = splash

              default_message_notifications = fields.get('default_notifications', self.default_notifications)
              if not isinstance(default_message_notifications, NotificationLevel):
                  raise InvalidArgument('default_notifications field must be of type NotificationLevel')
              fields['default_message_notifications'] = default_message_notifications.value

              try:
                  afk_channel = fields.pop('afk_channel')
              except KeyError:
                  pass
              else:
                  if afk_channel is None:
                      fields['afk_channel_id'] = afk_channel
                  else:
                      fields['afk_channel_id'] = afk_channel.id

              try:
                  system_channel = fields.pop('system_channel')
              except KeyError:
                  pass
              else:
                  if system_channel is None:
                      fields['system_channel_id'] = system_channel
                  else:
                      fields['system_channel_id'] = system_channel.id

              if 'owner' in fields:
                  if self.owner_id != self._state.self_id:
                      raise InvalidArgument('To transfer ownership you must be the owner of the guild.')

                  fields['owner_id'] = fields['owner'].id

              if 'region' in fields:
                  fields['region'] = str(fields['region'])

              level = fields.get('verification_level', self.verification_level)
              if not isinstance(level, VerificationLevel):
                  raise InvalidArgument('verification_level field must be of type VerificationLevel')

              fields['verification_level'] = level.value

              explicit_content_filter = fields.get('explicit_content_filter', self.explicit_content_filter)
              if not isinstance(explicit_content_filter, ContentFilter):
                  raise InvalidArgument('explicit_content_filter field must be of type ContentFilter')

              fields['explicit_content_filter'] = explicit_content_filter.value

              system_channel_flags = fields.get('system_channel_flags', self.system_channel_flags)
              if not isinstance(system_channel_flags, SystemChannelFlags):
                  raise InvalidArgument('system_channel_flags field must be of type SystemChannelFlags')

              fields['system_channel_flags'] = system_channel_flags.value

              try:
                  rules_channel = fields.pop('rules_channel')
              except KeyError:
                  pass
              else:
                  if rules_channel is None:
                      fields['rules_channel_id'] = rules_channel
                  else:
                      fields['rules_channel_id'] = rules_channel.id

              try:
                  public_updates_channel = fields.pop('public_updates_channel')
              except KeyError:
                  pass
              else:
                  if public_updates_channel is None:
                      fields['public_updates_channel_id'] = public_updates_channel
                  else:
                      fields['public_updates_channel_id'] = public_updates_channel.id
              await http.edit_guild(self.id, reason=reason, **fields)

          async def fetch_channels(self):
              """|coro|

              Retrieves all :class:`abc.GuildChannel` that the guild has.

              .. note::

                  This method is an API call. For general usage, consider :attr:`channels` instead.

              .. versionadded:: 1.2

              Raises
              -------
              InvalidData
                  An unknown channel type was received from Discord.
              HTTPException
                  Retrieving the channels failed.

              Returns
              -------
              List[:class:`abc.GuildChannel`]
                  All channels in the guild.
              """
              data = await self._state.http.get_all_guild_channels(self.id)

              def convert(d):
                  factory, ch_type = _channel_factory(d['type'])
                  if factory is None:
                      raise InvalidData('Unknown channel type {type} for channel ID {id}.'.format_map(d))

                  channel = factory(guild=self, state=self._state, data=d)
                  return channel

              return [convert(d) for d in data]

          def fetch_members(self, *, limit=1000, after=None):
              """Retrieves an :class:`.AsyncIterator` that enables receiving the guild's members. In order to use this,
              :meth:`Intents.members` must be enabled.

              .. note::

                  This method is an API call. For general usage, consider :attr:`members` instead.

              .. versionadded:: 1.3

              All parameters are optional.

              Parameters
              ----------
              limit: Optional[:class:`int`]
                  The number of members to retrieve. Defaults to 1000.
                  Pass ``None`` to fetch all members. Note that this is potentially slow.
              after: Optional[Union[:class:`.abc.Snowflake`, :class:`datetime.datetime`]]
                  Retrieve members after this date or object.
                  If a date is provided it must be a timezone-naive datetime representing UTC time.

              Raises
              ------
              ClientException
                  The members intent is not enabled.
              HTTPException
                  Getting the members failed.

              Yields
              ------
              :class:`.Member`
                  The member with the member data parsed.

              Examples
              --------

              Usage ::

                  async for member in guild.fetch_members(limit=150):
                      print(member.name)

              Flattening into a list ::

                  members = await guild.fetch_members(limit=150).flatten()
                  # members is now a list of Member...
              """

              if not self._state._intents.members:
                  raise ClientException('Intents.members must be enabled to use this.')

              return MemberIterator(self, limit=limit, after=after)

          async def fetch_member(self, member_id):
              """|coro|

              Retrieves a :class:`Member` from a guild ID, and a member ID.

              .. note::

                  This method is an API call. If you have :attr:`Intents.members` and member cache enabled, consider :meth:`get_member` instead.

              Parameters
              -----------
              member_id: :class:`int`
                  The member's ID to fetch from.

              Raises
              -------
              Forbidden
                  You do not have access to the guild.
              HTTPException
                  Fetching the member failed.

              Returns
              --------
              :class:`Member`
                  The member from the member ID.
              """
              data = await self._state.http.get_member(self.id, member_id)
              return Member(data=data, state=self._state, guild=self)

          async def fetch_ban(self, user):
              """|coro|

              Retrieves the :class:`BanEntry` for a user.

              You must have the :attr:`~Permissions.ban_members` permission
              to get this information.

              Parameters
              -----------
              user: :class:`abc.Snowflake`
                  The user to get ban information from.

              Raises
              ------
              Forbidden
                  You do not have proper permissions to get the information.
              NotFound
                  This user is not banned.
              HTTPException
                  An error occurred while fetching the information.

              Returns
              -------
              :class:`BanEntry`
                  The :class:`BanEntry` object for the specified user.
              """
              data = await self._state.http.get_ban(user.id, self.id)
              return BanEntry(
                  user=User(state=self._state, data=data['user']),
                  reason=data['reason']
              )

          async def bans(self):
              """|coro|

              Retrieves all the users that are banned from the guild as a :class:`list` of :class:`BanEntry`.

              You must have the :attr:`~Permissions.ban_members` permission
              to get this information.

              Raises
              -------
              Forbidden
                  You do not have proper permissions to get the information.
              HTTPException
                  An error occurred while fetching the information.

              Returns
              --------
              List[:class:`BanEntry`]
                  A list of :class:`BanEntry` objects.
              """

              data = await self._state.http.get_bans(self.id)
              return [BanEntry(user=User(state=self._state, data=e['user']),
                               reason=e['reason'])
                      for e in data]

          async def prune_members(self, *, days, compute_prune_count=True, roles=None, reason=None):
              r"""|coro|

              Prunes the guild from its inactive members.

              The inactive members are denoted if they have not logged on in
              ``days`` number of days and they have no roles.

              You must have the :attr:`~Permissions.kick_members` permission
              to use this.

              To check how many members you would prune without actually pruning,
              see the :meth:`estimate_pruned_members` function.

              To prune members that have specific roles see the ``roles`` parameter.

              .. versionchanged:: 1.4
                  The ``roles`` keyword-only parameter was added.

              Parameters
              -----------
              days: :class:`int`
                  The number of days before counting as inactive.
              reason: Optional[:class:`str`]
                  The reason for doing this action. Shows up on the audit log.
              compute_prune_count: :class:`bool`
                  Whether to compute the prune count. This defaults to ``True``
                  which makes it prone to timeouts in very large guilds. In order
                  to prevent timeouts, you must set this to ``False``. If this is
                  set to ``False``\, then this function will always return ``None``.
              roles: Optional[List[:class:`abc.Snowflake`]]
                  A list of :class:`abc.Snowflake` that represent roles to include in the pruning process. If a member
                  has a role that is not specified, they'll be excluded.

              Raises
              -------
              Forbidden
                  You do not have permissions to prune members.
              HTTPException
                  An error occurred while pruning members.
              InvalidArgument
                  An integer was not passed for ``days``.

              Returns
              ---------
              Optional[:class:`int`]
                  The number of members pruned. If ``compute_prune_count`` is ``False``
                  then this returns ``None``.
              """

              if not isinstance(days, int):
                  raise InvalidArgument('Expected int for ``days``, received {0.__class__.__name__} instead.'.format(days))

              if roles:
                  roles = [str(role.id) for role in roles]

              data = await self._state.http.prune_members(self.id, days, compute_prune_count=compute_prune_count, roles=roles, reason=reason)
              return data['pruned']

          async def templates(self):
              """|coro|

              Gets the list of templates from this guild.

              Requires :attr:`~.Permissions.manage_guild` permissions.

              .. versionadded:: 1.7

              Raises
              -------
              Forbidden
                  You don't have permissions to get the templates.

              Returns
              --------
              List[:class:`Template`]
                  The templates for this guild.
              """
              from .template import Template
              data = await self._state.http.guild_templates(self.id)
              return [Template(data=d, state=self._state) for d in data]

          async def webhooks(self):
              """|coro|

              Gets the list of webhooks from this guild.

              Requires :attr:`~.Permissions.manage_webhooks` permissions.

              Raises
              -------
              Forbidden
                  You don't have permissions to get the webhooks.

              Returns
              --------
              List[:class:`Webhook`]
                  The webhooks for this guild.
              """

              from .webhook import Webhook
              data = await self._state.http.guild_webhooks(self.id)
              return [Webhook.from_state(d, state=self._state) for d in data]

          async def estimate_pruned_members(self, *, days, roles=None):
              """|coro|

              Similar to :meth:`prune_members` except instead of actually
              pruning members, it returns how many members it would prune
              from the guild had it been called.

              Parameters
              -----------
              days: :class:`int`
                  The number of days before counting as inactive.
              roles: Optional[List[:class:`abc.Snowflake`]]
                  A list of :class:`abc.Snowflake` that represent roles to include in the estimate. If a member
                  has a role that is not specified, they'll be excluded.

                  .. versionadded:: 1.7

              Raises
              -------
              Forbidden
                  You do not have permissions to prune members.
              HTTPException
                  An error occurred while fetching the prune members estimate.
              InvalidArgument
                  An integer was not passed for ``days``.

              Returns
              ---------
              :class:`int`
                  The number of members estimated to be pruned.
              """

              if not isinstance(days, int):
                  raise InvalidArgument('Expected int for ``days``, received {0.__class__.__name__} instead.'.format(days))

              if roles:
                  roles = [str(role.id) for role in roles]

              data = await self._state.http.estimate_pruned_members(self.id, days, roles)
              return data['pruned']

          async def invites(self):
              """|coro|

              Returns a list of all active instant invites from the guild.

              You must have the :attr:`~Permissions.manage_guild` permission to get
              this information.

              Raises
              -------
              Forbidden
                  You do not have proper permissions to get the information.
              HTTPException
                  An error occurred while fetching the information.

              Returns
              -------
              List[:class:`Invite`]
                  The list of invites that are currently active.
              """

              data = await self._state.http.invites_from(self.id)
              result = []
              for invite in data:
                  channel = self.get_channel(int(invite['channel']['id']))
                  invite['channel'] = channel
                  invite['guild'] = self
                  result.append(Invite(state=self._state, data=invite))

              return result

          async def create_template(self, *, name, description=None):
              """|coro|

              Creates a template for the guild.

              You must have the :attr:`~Permissions.manage_guild` permission to
              do this.

              .. versionadded:: 1.7

              Parameters
              -----------
              name: :class:`str`
                  The name of the template.
              description: Optional[:class:`str`]
                  The description of the template.
              """
              from .template import Template

              payload = {
                  'name': name
              }

              if description:
                  payload['description'] = description

              data = await self._state.http.create_template(self.id, payload)

              return Template(state=self._state, data=data)

          async def create_integration(self, *, type, id):
              """|coro|

              Attaches an integration to the guild.

              You must have the :attr:`~Permissions.manage_guild` permission to
              do this.

              .. versionadded:: 1.4

              Parameters
              -----------
              type: :class:`str`
                  The integration type (e.g. Twitch).
              id: :class:`int`
                  The integration ID.

              Raises
              -------
              Forbidden
                  You do not have permission to create the integration.
              HTTPException
                  The account could not be found.
              """
              await self._state.http.create_integration(self.id, type, id)

          async def integrations(self):
              """|coro|

              Returns a list of all integrations attached to the guild.

              You must have the :attr:`~Permissions.manage_guild` permission to
              do this.

              .. versionadded:: 1.4

              Raises
              -------
              Forbidden
                  You do not have permission to create the integration.
              HTTPException
                  Fetching the integrations failed.

              Returns
              --------
              List[:class:`Integration`]
                  The list of integrations that are attached to the guild.
              """
              data = await self._state.http.get_all_integrations(self.id)
              return [Integration(guild=self, data=d) for d in data]

          async def fetch_emojis(self):
              r"""|coro|

              Retrieves all custom :class:`Emoji`\s from the guild.

              .. note::

                  This method is an API call. For general usage, consider :attr:`emojis` instead.

              Raises
              ---------
              HTTPException
                  An error occurred fetching the emojis.

              Returns
              --------
              List[:class:`Emoji`]
                  The retrieved emojis.
              """
              data = await self._state.http.get_all_custom_emojis(self.id)
              return [Emoji(guild=self, state=self._state, data=d) for d in data]

          async def fetch_emoji(self, emoji_id):
              """|coro|

              Retrieves a custom :class:`Emoji` from the guild.

              .. note::

                  This method is an API call.
                  For general usage, consider iterating over :attr:`emojis` instead.

              Parameters
              -------------
              emoji_id: :class:`int`
                  The emoji's ID.

              Raises
              ---------
              NotFound
                  The emoji requested could not be found.
              HTTPException
                  An error occurred fetching the emoji.

              Returns
              --------
              :class:`Emoji`
                  The retrieved emoji.
              """
              data = await self._state.http.get_custom_emoji(self.id, emoji_id)
              return Emoji(guild=self, state=self._state, data=data)

          async def create_custom_emoji(self, *, name, image, roles=None, reason=None):
              r"""|coro|

              Creates a custom :class:`Emoji` for the guild.

              There is currently a limit of 50 static and animated emojis respectively per guild,
              unless the guild has the ``MORE_EMOJI`` feature which extends the limit to 200.

              You must have the :attr:`~Permissions.manage_emojis` permission to
              do this.

              Parameters
              -----------
              name: :class:`str`
                  The emoji name. Must be at least 2 characters.
              image: :class:`bytes`
                  The :term:`py:bytes-like object` representing the image data to use.
                  Only JPG, PNG and GIF images are supported.
              roles: Optional[List[:class:`Role`]]
                  A :class:`list` of :class:`Role`\s that can use this emoji. Leave empty to make it available to everyone.
              reason: Optional[:class:`str`]
                  The reason for creating this emoji. Shows up on the audit log.

              Raises
              -------
              Forbidden
                  You are not allowed to create emojis.
              HTTPException
                  An error occurred creating an emoji.

              Returns
              --------
              :class:`Emoji`
                  The created emoji.
              """

              img = utils._bytes_to_base64_data(image)
              if roles:
                  roles = [role.id for role in roles]
              data = await self._state.http.create_custom_emoji(self.id, name, img, roles=roles, reason=reason)
              return self._state.store_emoji(self, data)

          async def fetch_roles(self):
              """|coro|

              Retrieves all :class:`Role` that the guild has.

              .. note::

                  This method is an API call. For general usage, consider :attr:`roles` instead.

              .. versionadded:: 1.3

              Raises
              -------
              HTTPException
                  Retrieving the roles failed.

              Returns
              -------
              List[:class:`Role`]
                  All roles in the guild.
              """
              data = await self._state.http.get_roles(self.id)
              return [Role(guild=self, state=self._state, data=d) for d in data]

          async def create_role(self, *, reason=None, **fields):
              """|coro|

              Creates a :class:`Role` for the guild.

              All fields are optional.

              You must have the :attr:`~Permissions.manage_roles` permission to
              do this.

              .. versionchanged:: 1.6
                  Can now pass ``int`` to ``colour`` keyword-only parameter.

              Parameters
              -----------
              name: :class:`str`
                  The role name. Defaults to 'new role'.
              permissions: :class:`Permissions`
                  The permissions to have. Defaults to no permissions.
              colour: Union[:class:`Colour`, :class:`int`]
                  The colour for the role. Defaults to :meth:`Colour.default`.
                  This is aliased to ``color`` as well.
              hoist: :class:`bool`
                  Indicates if the role should be shown separately in the member list.
                  Defaults to ``False``.
              mentionable: :class:`bool`
                  Indicates if the role should be mentionable by others.
                  Defaults to ``False``.
              reason: Optional[:class:`str`]
                  The reason for creating this role. Shows up on the audit log.

              Raises
              -------
              Forbidden
                  You do not have permissions to create the role.
              HTTPException
                  Creating the role failed.
              InvalidArgument
                  An invalid keyword argument was given.

              Returns
              --------
              :class:`Role`
                  The newly created role.
              """

              try:
                  perms = fields.pop('permissions')
              except KeyError:
                  fields['permissions'] = 0
              else:
                  fields['permissions'] = perms.value

              try:
                  colour = fields.pop('colour')
              except KeyError:
                  colour = fields.get('color', Colour.default())
              finally:
                  if isinstance(colour, int):
                      colour = Colour(value=colour)
                  fields['color'] = colour.value

              valid_keys = ('name', 'permissions', 'color', 'hoist', 'mentionable')
              for key in fields:
                  if key not in valid_keys:
                      raise InvalidArgument('%r is not a valid field.' % key)

              data = await self._state.http.create_role(self.id, reason=reason, **fields)
              role = Role(guild=self, data=data, state=self._state)

              # TODO: add to cache
              return role

          async def edit_role_positions(self, positions, *, reason=None):
              """|coro|

              Bulk edits a list of :class:`Role` in the guild.

              You must have the :attr:`~Permissions.manage_roles` permission to
              do this.

              .. versionadded:: 1.4

              Example:

              .. code-block:: python3

                  positions = {
                      bots_role: 1, # penultimate role
                      tester_role: 2,
                      admin_role: 6
                  }

                  await guild.edit_role_positions(positions=positions)

              Parameters
              -----------
              positions
                  A :class:`dict` of :class:`Role` to :class:`int` to change the positions
                  of each given role.
              reason: Optional[:class:`str`]
                  The reason for editing the role positions. Shows up on the audit log.

              Raises
              -------
              Forbidden
                  You do not have permissions to move the roles.
              HTTPException
                  Moving the roles failed.
              InvalidArgument
                  An invalid keyword argument was given.

              Returns
              --------
              List[:class:`Role`]
                  A list of all the roles in the guild.
              """
              if not isinstance(positions, dict):
                  raise InvalidArgument('positions parameter expects a dict.')

              role_positions = []
              for role, position in positions.items():

                  payload = {
                      'id': role.id,
                      'position': position
                  }

                  role_positions.append(payload)

              data = await self._state.http.move_role_position(self.id, role_positions, reason=reason)
              roles = []
              for d in data:
                  role = Role(guild=self, data=d, state=self._state)
                  roles.append(role)
                  self._roles[role.id] = role

              return roles

          async def kick(self, user, *, reason=None):
              """|coro|

              Kicks a user from the guild.

              The user must meet the :class:`abc.Snowflake` abc.

              You must have the :attr:`~Permissions.kick_members` permission to
              do this.

              Parameters
              -----------
              user: :class:`abc.Snowflake`
                  The user to kick from their guild.
              reason: Optional[:class:`str`]
                  The reason the user got kicked.

              Raises
              -------
              Forbidden
                  You do not have the proper permissions to kick.
              HTTPException
                  Kicking failed.
              """
              await self._state.http.kick(user.id, self.id, reason=reason)

          async def ban(self, user, *, reason=None, delete_message_days=1):
              """|coro|

              Bans a user from the guild.

              The user must meet the :class:`abc.Snowflake` abc.

              You must have the :attr:`~Permissions.ban_members` permission to
              do this.

              Parameters
              -----------
              user: :class:`abc.Snowflake`
                  The user to ban from their guild.
              delete_message_days: :class:`int`
                  The number of days worth of messages to delete from the user
                  in the guild. The minimum is 0 and the maximum is 7.
              reason: Optional[:class:`str`]
                  The reason the user got banned.

              Raises
              -------
              Forbidden
                  You do not have the proper permissions to ban.
              HTTPException
                  Banning failed.
              """
              await self._state.http.ban(user.id, self.id, delete_message_days, reason=reason)

          async def unban(self, user, *, reason=None):
              """|coro|

              Unbans a user from the guild.

              The user must meet the :class:`abc.Snowflake` abc.

              You must have the :attr:`~Permissions.ban_members` permission to
              do this.

              Parameters
              -----------
              user: :class:`abc.Snowflake`
                  The user to unban.
              reason: Optional[:class:`str`]
                  The reason for doing this action. Shows up on the audit log.

              Raises
              -------
              Forbidden
                  You do not have the proper permissions to unban.
              HTTPException
                  Unbanning failed.
              """
              await self._state.http.unban(user.id, self.id, reason=reason)

          async def vanity_invite(self):
              """|coro|

              Returns the guild's special vanity invite.

              The guild must have ``VANITY_URL`` in :attr:`~Guild.features`.

              You must have the :attr:`~Permissions.manage_guild` permission to use
              this as well.

              Raises
              -------
              Forbidden
                  You do not have the proper permissions to get this.
              HTTPException
                  Retrieving the vanity invite failed.

              Returns
              --------
              :class:`Invite`
                  The special vanity invite.
              """

              # we start with { code: abc }
              payload = await self._state.http.get_vanity_code(self.id)

              # get the vanity URL channel since default channels aren't
              # reliable or a thing anymore
              data = await self._state.http.get_invite(payload['code'])

              payload['guild'] = self
              payload['channel'] = self.get_channel(int(data['channel']['id']))
              payload['revoked'] = False
              payload['temporary'] = False
              payload['max_uses'] = 0
              payload['max_age'] = 0
              return Invite(state=self._state, data=payload)

          @utils.deprecated()
          def ack(self):
              """|coro|

              Marks every message in this guild as read.

              The user must not be a bot user.

              .. deprecated:: 1.7

              Raises
              -------
              HTTPException
                  Acking failed.
              ClientException
                  You must not be a bot user.
              """

              state = self._state
              if state.is_bot:
                  raise ClientException('Must not be a bot account to ack messages.')
              return state.http.ack_guild(self.id)

          def audit_logs(self, *, limit=100, before=None, after=None, oldest_first=None, user=None, action=None):
              """Returns an :class:`AsyncIterator` that enables receiving the guild's audit logs.

              You must have the :attr:`~Permissions.view_audit_log` permission to use this.

              Examples
              ----------

              Getting the first 100 entries: ::

                  async for entry in guild.audit_logs(limit=100):
                      print('{0.user} did {0.action} to {0.target}'.format(entry))

              Getting entries for a specific action: ::

                  async for entry in guild.audit_logs(action=discord.AuditLogAction.ban):
                      print('{0.user} banned {0.target}'.format(entry))

              Getting entries made by a specific user: ::

                  entries = await guild.audit_logs(limit=None, user=guild.me).flatten()
                  await channel.send('I made {} moderation actions.'.format(len(entries)))

              Parameters
              -----------
              limit: Optional[:class:`int`]
                  The number of entries to retrieve. If ``None`` retrieve all entries.
              before: Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]
                  Retrieve entries before this date or entry.
                  If a date is provided it must be a timezone-naive datetime representing UTC time.
              after: Union[:class:`abc.Snowflake`, :class:`datetime.datetime`]
                  Retrieve entries after this date or entry.
                  If a date is provided it must be a timezone-naive datetime representing UTC time.
              oldest_first: :class:`bool`
                  If set to ``True``, return entries in oldest->newest order. Defaults to ``True`` if
                  ``after`` is specified, otherwise ``False``.
              user: :class:`abc.Snowflake`
                  The moderator to filter entries from.
              action: :class:`AuditLogAction`
                  The action to filter with.

              Raises
              -------
              Forbidden
                  You are not allowed to fetch audit logs
              HTTPException
                  An error occurred while fetching the audit logs.

              Yields
              --------
              :class:`AuditLogEntry`
                  The audit log entry.
              """
              if user:
                  user = user.id

              if action:
                  action = action.value

              return AuditLogIterator(self, before=before, after=after, limit=limit,
                                      oldest_first=oldest_first, user_id=user, action_type=action)

          async def widget(self):
              """|coro|

              Returns the widget of the guild.

              .. note::

                  The guild must have the widget enabled to get this information.

              Raises
              -------
              Forbidden
                  The widget for this guild is disabled.
              HTTPException
                  Retrieving the widget failed.

              Returns
              --------
              :class:`Widget`
                  The guild's widget.
              """
              data = await self._state.http.get_widget(self.id)

              return Widget(state=self._state, data=data)

          async def chunk(self, *, cache=True):
              """|coro|

              Requests all members that belong to this guild. In order to use this,
              :meth:`Intents.members` must be enabled.

              This is a websocket operation and can be slow.

              .. versionadded:: 1.5

              Parameters
              -----------
              cache: :class:`bool`
                  Whether to cache the members as well.

              Raises
              -------
              ClientException
                  The members intent is not enabled.
              """

              if not self._state._intents.members:
                  raise ClientException('Intents.members must be enabled to use this.')

              if not self._state.is_guild_evicted(self):
                  return await self._state.chunk_guild(self, cache=cache)

          async def query_members(self, query=None, *, limit=5, user_ids=None, presences=False, cache=True):
              """|coro|

              Request members that belong to this guild whose username starts with
              the query given.

              This is a websocket operation and can be slow.

              .. versionadded:: 1.3

              Parameters
              -----------
              query: Optional[:class:`str`]
                  The string that the username's start with.
              limit: :class:`int`
                  The maximum number of members to send back. This must be
                  a number between 5 and 100.
              presences: :class:`bool`
                  Whether to request for presences to be provided. This defaults
                  to ``False``.

                  .. versionadded:: 1.6

              cache: :class:`bool`
                  Whether to cache the members internally. This makes operations
                  such as :meth:`get_member` work for those that matched.
              user_ids: Optional[List[:class:`int`]]
                  List of user IDs to search for. If the user ID is not in the guild then it won't be returned.

                  .. versionadded:: 1.4


              Raises
              -------
              asyncio.TimeoutError
                  The query timed out waiting for the members.
              ValueError
                  Invalid parameters were passed to the function
              ClientException
                  The presences intent is not enabled.

              Returns
              --------
              List[:class:`Member`]
                  The list of members that have matched the query.
              """

              if presences and not self._state._intents.presences:
                  raise ClientException('Intents.presences must be enabled to use this.')

              if query is None:
                  if query == '':
                      raise ValueError('Cannot pass empty query string.')

                  if user_ids is None:
                      raise ValueError('Must pass either query or user_ids')

              if user_ids is not None and query is not None:
                  raise ValueError('Cannot pass both query and user_ids')

              if user_ids is not None and not user_ids:
                  raise ValueError('user_ids must contain at least 1 value')

              limit = min(100, limit or 5)
              return await self._state.query_members(self, query=query, limit=limit, user_ids=user_ids, presences=presences, cache=cache)

          async def change_voice_state(self, *, channel, self_mute=False, self_deaf=False):
              """|coro|

              Changes client's voice state in the guild.

              .. versionadded:: 1.4

              Parameters
              -----------
              channel: Optional[:class:`VoiceChannel`]
                  Channel the client wants to join. Use ``None`` to disconnect.
              self_mute: :class:`bool`
                  Indicates if the client should be self-muted.
              self_deaf: :class:`bool`
                  Indicates if the client should be self-deafened.
              """
              ws = self._state._get_websocket(self.id)
              channel_id = channel.id if channel else None
              await ws.voice_state(self.id, channel_id, self_mute, self_deaf)
    tokens: resume load_const STRING_FILE_PATH store_name __doc__ load_const INTEGER load_const import_name copy store_name copy load_const INTEGER load_const import_name collections import_from namedtuple store_name namedtuple pop_top load_const INTEGER load_const import_name import_from utils store_name utils pop_top load_const INTEGER load_const import_name role import_from Role store_name Role pop_top load_const INTEGER load_const import_name member import_from Member store_name Member import_from VoiceState store_name VoiceState pop_top load_const INTEGER load_const import_name emoji import_from Emoji store_name Emoji pop_top load_const INTEGER load_const import_name errors import_from InvalidData store_name InvalidData pop_top load_const INTEGER load_const import_name permissions import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name colour import_from Colour store_name Colour pop_top load_const INTEGER load_const import_name errors import_from InvalidArgument store_name InvalidArgument import_from ClientException store_name ClientException pop_top load_const INTEGER load_const import_name channel call_intrinsic_1 INTRINSIC_IMPORT_STAR pop_top load_const INTEGER load_const import_name enums import_from VoiceRegion store_name VoiceRegion import_from ChannelType store_name ChannelType import_from try_enum store_name try_enum import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH import_from ContentFilter store_name ContentFilter import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name mixins import_from Hashable store_name Hashable pop_top load_const INTEGER load_const import_name user import_from User store_name User pop_top load_const INTEGER load_const import_name invite import_from Invite store_name Invite pop_top load_const INTEGER load_const import_name iterators import_from STRING_BASE64_LEN_S_ENT_HIGH store_name STRING_BASE64_LEN_S_ENT_HIGH import_from MemberIterator store_name MemberIterator pop_top load_const INTEGER load_const import_name widget import_from Widget store_name Widget pop_top load_const INTEGER load_const import_name asset import_from Asset store_name Asset pop_top load_const INTEGER load_const import_name flags import_from STRING_LEN_S_ENT_HIGH store_name STRING_LEN_S_ENT_HIGH pop_top load_const INTEGER load_const import_name integrations import_from Integration store_name Integration pop_top push_null load_name namedtuple load_const BanEntry load_const reason user call store_name BanEntry push_null load_name namedtuple load_const _GuildLimit load_const STRING_LEN_S_ENT_HIGH call store_name _GuildLimit push_null load_build_class load_const OBJECT make_function load_const Guild load_name Hashable call store_name Guild return_const None
    hash: b1d0aaa1479d4fd3f4af5c5bb500530a3f9d17287ddce5dd5243b221b137cc81
sources:
  .repo_cache/malicious_repos/pypi_malregistry/discord-py-v13/1.3/discord_py_v13-1.3-py3-none-any/discord-py-v13/guild.py: IyAtKi0gY29kaW5nOiB1dGYtOCAtKi0KCiIiIgpUaGUgTUlUIExpY2Vuc2UgKE1JVCkKCkNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50IFJhcHB0egoKUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAiU29mdHdhcmUiKSwKdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbgp0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwKYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlClNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CgpUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgphbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KClRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCk9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLApGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUgpMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORwpGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSCkRFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KIiIiCgppbXBvcnQgY29weQpmcm9tIGNvbGxlY3Rpb25zIGltcG9ydCBuYW1lZHR1cGxlCgpmcm9tIC4gaW1wb3J0IHV0aWxzCmZyb20gLnJvbGUgaW1wb3J0IFJvbGUKZnJvbSAubWVtYmVyIGltcG9ydCBNZW1iZXIsIFZvaWNlU3RhdGUKZnJvbSAuZW1vamkgaW1wb3J0IEVtb2ppCmZyb20gLmVycm9ycyBpbXBvcnQgSW52YWxpZERhdGEKZnJvbSAucGVybWlzc2lvbnMgaW1wb3J0IFBlcm1pc3Npb25PdmVyd3JpdGUKZnJvbSAuY29sb3VyIGltcG9ydCBDb2xvdXIKZnJvbSAuZXJyb3JzIGltcG9ydCBJbnZhbGlkQXJndW1lbnQsIENsaWVudEV4Y2VwdGlvbgpmcm9tIC5jaGFubmVsIGltcG9ydCAqCmZyb20gLmVudW1zIGltcG9ydCBWb2ljZVJlZ2lvbiwgQ2hhbm5lbFR5cGUsIHRyeV9lbnVtLCBWZXJpZmljYXRpb25MZXZlbCwgQ29udGVudEZpbHRlciwgTm90aWZpY2F0aW9uTGV2ZWwKZnJvbSAubWl4aW5zIGltcG9ydCBIYXNoYWJsZQpmcm9tIC51c2VyIGltcG9ydCBVc2VyCmZyb20gLmludml0ZSBpbXBvcnQgSW52aXRlCmZyb20gLml0ZXJhdG9ycyBpbXBvcnQgQXVkaXRMb2dJdGVyYXRvciwgTWVtYmVySXRlcmF0b3IKZnJvbSAud2lkZ2V0IGltcG9ydCBXaWRnZXQKZnJvbSAuYXNzZXQgaW1wb3J0IEFzc2V0CmZyb20gLmZsYWdzIGltcG9ydCBTeXN0ZW1DaGFubmVsRmxhZ3MKZnJvbSAuaW50ZWdyYXRpb25zIGltcG9ydCBJbnRlZ3JhdGlvbgoKCkJhbkVudHJ5ID0gbmFtZWR0dXBsZSgnQmFuRW50cnknLCAncmVhc29uIHVzZXInKQpfR3VpbGRMaW1pdCA9IG5hbWVkdHVwbGUoJ19HdWlsZExpbWl0JywgJ2Vtb2ppIGJpdHJhdGUgZmlsZXNpemUnKQoKCmNsYXNzIEd1aWxkKEhhc2hhYmxlKToKICAgICIiIlJlcHJlc2VudHMgYSBEaXNjb3JkIGd1aWxkLgoKICAgIFRoaXMgaXMgcmVmZXJyZWQgdG8gYXMgYSAic2VydmVyIiBpbiB0aGUgb2ZmaWNpYWwgRGlzY29yZCBVSS4KCiAgICAuLiBjb250YWluZXI6OiBvcGVyYXRpb25zCgogICAgICAgIC4uIGRlc2NyaWJlOjogeCA9PSB5CgogICAgICAgICAgICBDaGVja3MgaWYgdHdvIGd1aWxkcyBhcmUgZXF1YWwuCgogICAgICAgIC4uIGRlc2NyaWJlOjogeCAhPSB5CgogICAgICAgICAgICBDaGVja3MgaWYgdHdvIGd1aWxkcyBhcmUgbm90IGVxdWFsLgoKICAgICAgICAuLiBkZXNjcmliZTo6IGhhc2goeCkKCiAgICAgICAgICAgIFJldHVybnMgdGhlIGd1aWxkJ3MgaGFzaC4KCiAgICAgICAgLi4gZGVzY3JpYmU6OiBzdHIoeCkKCiAgICAgICAgICAgIFJldHVybnMgdGhlIGd1aWxkJ3MgbmFtZS4KCiAgICBBdHRyaWJ1dGVzCiAgICAtLS0tLS0tLS0tCiAgICBuYW1lOiA6Y2xhc3M6YHN0cmAKICAgICAgICBUaGUgZ3VpbGQgbmFtZS4KICAgIGVtb2ppczogVHVwbGVbOmNsYXNzOmBFbW9qaWAsIC4uLl0KICAgICAgICBBbGwgZW1vamlzIHRoYXQgdGhlIGd1aWxkIG93bnMuCiAgICByZWdpb246IDpjbGFzczpgVm9pY2VSZWdpb25gCiAgICAgICAgVGhlIHJlZ2lvbiB0aGUgZ3VpbGQgYmVsb25ncyBvbi4gVGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGUgcmVnaW9uCiAgICAgICAgd2lsbCBiZSBhIDpjbGFzczpgc3RyYCBpZiB0aGUgdmFsdWUgaXMgbm90IHJlY29nbmlzZWQgYnkgdGhlIGVudW1lcmF0b3IuCiAgICBhZmtfdGltZW91dDogOmNsYXNzOmBpbnRgCiAgICAgICAgVGhlIHRpbWVvdXQgdG8gZ2V0IHNlbnQgdG8gdGhlIEFGSyBjaGFubmVsLgogICAgYWZrX2NoYW5uZWw6IE9wdGlvbmFsWzpjbGFzczpgVm9pY2VDaGFubmVsYF0KICAgICAgICBUaGUgY2hhbm5lbCB0aGF0IGRlbm90ZXMgdGhlIEFGSyBjaGFubmVsLiBgYE5vbmVgYCBpZiBpdCBkb2Vzbid0IGV4aXN0LgogICAgaWNvbjogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgIFRoZSBndWlsZCdzIGljb24uCiAgICBpZDogOmNsYXNzOmBpbnRgCiAgICAgICAgVGhlIGd1aWxkJ3MgSUQuCiAgICBvd25lcl9pZDogOmNsYXNzOmBpbnRgCiAgICAgICAgVGhlIGd1aWxkIG93bmVyJ3MgSUQuIFVzZSA6YXR0cjpgR3VpbGQub3duZXJgIGluc3RlYWQuCiAgICB1bmF2YWlsYWJsZTogOmNsYXNzOmBib29sYAogICAgICAgIEluZGljYXRlcyBpZiB0aGUgZ3VpbGQgaXMgdW5hdmFpbGFibGUuIElmIHRoaXMgaXMgYGBUcnVlYGAgdGhlbiB0aGUKICAgICAgICByZWxpYWJpbGl0eSBvZiBvdGhlciBhdHRyaWJ1dGVzIG91dHNpZGUgb2YgOmF0dHI6YEd1aWxkLmlkYCBpcyBzbGltIGFuZCB0aGV5IG1pZ2h0CiAgICAgICAgYWxsIGJlIGBgTm9uZWBgLiBJdCBpcyBiZXN0IHRvIG5vdCBkbyBhbnl0aGluZyB3aXRoIHRoZSBndWlsZCBpZiBpdCBpcyB1bmF2YWlsYWJsZS4KCiAgICAgICAgQ2hlY2sgdGhlIDpmdW5jOmBvbl9ndWlsZF91bmF2YWlsYWJsZWAgYW5kIDpmdW5jOmBvbl9ndWlsZF9hdmFpbGFibGVgIGV2ZW50cy4KICAgIG1heF9wcmVzZW5jZXM6IE9wdGlvbmFsWzpjbGFzczpgaW50YF0KICAgICAgICBUaGUgbWF4aW11bSBhbW91bnQgb2YgcHJlc2VuY2VzIGZvciB0aGUgZ3VpbGQuCiAgICBtYXhfbWVtYmVyczogT3B0aW9uYWxbOmNsYXNzOmBpbnRgXQogICAgICAgIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBtZW1iZXJzIGZvciB0aGUgZ3VpbGQuCgogICAgICAgIC4uIG5vdGU6OgoKICAgICAgICAgICAgVGhpcyBhdHRyaWJ1dGUgaXMgb25seSBhdmFpbGFibGUgdmlhIDptZXRoOmAuQ2xpZW50LmZldGNoX2d1aWxkYC4KICAgIG1heF92aWRlb19jaGFubmVsX3VzZXJzOiBPcHRpb25hbFs6Y2xhc3M6YGludGBdCiAgICAgICAgVGhlIG1heGltdW0gYW1vdW50IG9mIHVzZXJzIGluIGEgdmlkZW8gY2hhbm5lbC4KCiAgICAgICAgLi4gdmVyc2lvbmFkZGVkOjogMS40CiAgICBiYW5uZXI6IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICBUaGUgZ3VpbGQncyBiYW5uZXIuCiAgICBkZXNjcmlwdGlvbjogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgIFRoZSBndWlsZCdzIGRlc2NyaXB0aW9uLgogICAgbWZhX2xldmVsOiA6Y2xhc3M6YGludGAKICAgICAgICBJbmRpY2F0ZXMgdGhlIGd1aWxkJ3MgdHdvIGZhY3RvciBhdXRob3Jpc2F0aW9uIGxldmVsLiBJZiB0aGlzIHZhbHVlIGlzIDAgdGhlbgogICAgICAgIHRoZSBndWlsZCBkb2VzIG5vdCByZXF1aXJlIDJGQSBmb3IgdGhlaXIgYWRtaW5pc3RyYXRpdmUgbWVtYmVycy4gSWYgdGhlIHZhbHVlIGlzCiAgICAgICAgMSB0aGVuIHRoZXkgZG8uCiAgICB2ZXJpZmljYXRpb25fbGV2ZWw6IDpjbGFzczpgVmVyaWZpY2F0aW9uTGV2ZWxgCiAgICAgICAgVGhlIGd1aWxkJ3MgdmVyaWZpY2F0aW9uIGxldmVsLgogICAgZXhwbGljaXRfY29udGVudF9maWx0ZXI6IDpjbGFzczpgQ29udGVudEZpbHRlcmAKICAgICAgICBUaGUgZ3VpbGQncyBleHBsaWNpdCBjb250ZW50IGZpbHRlci4KICAgIGRlZmF1bHRfbm90aWZpY2F0aW9uczogOmNsYXNzOmBOb3RpZmljYXRpb25MZXZlbGAKICAgICAgICBUaGUgZ3VpbGQncyBub3RpZmljYXRpb24gc2V0dGluZ3MuCiAgICBmZWF0dXJlczogTGlzdFs6Y2xhc3M6YHN0cmBdCiAgICAgICAgQSBsaXN0IG9mIGZlYXR1cmVzIHRoYXQgdGhlIGd1aWxkIGhhcy4gVGhleSBhcmUgY3VycmVudGx5IGFzIGZvbGxvd3M6CgogICAgICAgIC0gYGBWSVBfUkVHSU9OU2BgOiBHdWlsZCBoYXMgVklQIHZvaWNlIHJlZ2lvbnMKICAgICAgICAtIGBgVkFOSVRZX1VSTGBgOiBHdWlsZCBjYW4gaGF2ZSBhIHZhbml0eSBpbnZpdGUgVVJMIChlLmcuIGRpc2NvcmQuZ2cvZGlzY29yZC1hcGkpCiAgICAgICAgLSBgYElOVklURV9TUExBU0hgYDogR3VpbGQncyBpbnZpdGUgcGFnZSBjYW4gaGF2ZSBhIHNwZWNpYWwgc3BsYXNoLgogICAgICAgIC0gYGBWRVJJRklFRGBgOiBHdWlsZCBpcyBhIHZlcmlmaWVkIHNlcnZlci4KICAgICAgICAtIGBgUEFSVE5FUkVEYGA6IEd1aWxkIGlzIGEgcGFydG5lcmVkIHNlcnZlci4KICAgICAgICAtIGBgTU9SRV9FTU9KSWBgOiBHdWlsZCBpcyBhbGxvd2VkIHRvIGhhdmUgbW9yZSB0aGFuIDUwIGN1c3RvbSBlbW9qaS4KICAgICAgICAtIGBgRElTQ09WRVJBQkxFYGA6IEd1aWxkIHNob3dzIHVwIGluIFNlcnZlciBEaXNjb3ZlcnkuCiAgICAgICAgLSBgYEZFQVRVUkFCTEVgYDogR3VpbGQgaXMgYWJsZSB0byBiZSBmZWF0dXJlZCBpbiBTZXJ2ZXIgRGlzY292ZXJ5LgogICAgICAgIC0gYGBDT01NVU5JVFlgYDogR3VpbGQgaXMgYSBjb21tdW5pdHkgc2VydmVyLgogICAgICAgIC0gYGBDT01NRVJDRWBgOiBHdWlsZCBjYW4gc2VsbCB0aGluZ3MgdXNpbmcgc3RvcmUgY2hhbm5lbHMuCiAgICAgICAgLSBgYFBVQkxJQ2BgOiBHdWlsZCBpcyBhIHB1YmxpYyBndWlsZC4KICAgICAgICAtIGBgTkVXU2BgOiBHdWlsZCBjYW4gY3JlYXRlIG5ld3MgY2hhbm5lbHMuCiAgICAgICAgLSBgYEJBTk5FUmBgOiBHdWlsZCBjYW4gdXBsb2FkIGFuZCB1c2UgYSBiYW5uZXIgKGkuZS4gOm1ldGg6YGJhbm5lcl91cmxgKS4KICAgICAgICAtIGBgQU5JTUFURURfSUNPTmBgOiBHdWlsZCBjYW4gdXBsb2FkIGFuIGFuaW1hdGVkIGljb24uCiAgICAgICAgLSBgYFBVQkxJQ19ESVNBQkxFRGBgOiBHdWlsZCBjYW5ub3QgYmUgcHVibGljLgogICAgICAgIC0gYGBXRUxDT01FX1NDUkVFTl9FTkFCTEVEYGA6IEd1aWxkIGhhcyBlbmFibGVkIHRoZSB3ZWxjb21lIHNjcmVlbgogICAgICAgIC0gYGBNRU1CRVJfVkVSSUZJQ0FUSU9OX0dBVEVfRU5BQkxFRGBgOiBHdWlsZCBoYXMgTWVtYmVyc2hpcCBTY3JlZW5pbmcgZW5hYmxlZC4KICAgICAgICAtIGBgUFJFVklFV19FTkFCTEVEYGA6IEd1aWxkIGNhbiBiZSB2aWV3ZWQgYmVmb3JlIGJlaW5nIGFjY2VwdGVkIHZpYSBNZW1iZXJzaGlwIFNjcmVlbmluZy4KCiAgICBzcGxhc2g6IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICBUaGUgZ3VpbGQncyBpbnZpdGUgc3BsYXNoLgogICAgcHJlbWl1bV90aWVyOiA6Y2xhc3M6YGludGAKICAgICAgICBUaGUgcHJlbWl1bSB0aWVyIGZvciB0aGlzIGd1aWxkLiBDb3JyZXNwb25kcyB0byAiTml0cm8gU2VydmVyIiBpbiB0aGUgb2ZmaWNpYWwgVUkuCiAgICAgICAgVGhlIG51bWJlciBnb2VzIGZyb20gMCB0byAzIGluY2x1c2l2ZS4KICAgIHByZW1pdW1fc3Vic2NyaXB0aW9uX2NvdW50OiA6Y2xhc3M6YGludGAKICAgICAgICBUaGUgbnVtYmVyIG9mICJib29zdHMiIHRoaXMgZ3VpbGQgY3VycmVudGx5IGhhcy4KICAgIHByZWZlcnJlZF9sb2NhbGU6IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICBUaGUgcHJlZmVycmVkIGxvY2FsZSBmb3IgdGhlIGd1aWxkLiBVc2VkIHdoZW4gZmlsdGVyaW5nIFNlcnZlciBEaXNjb3ZlcnkKICAgICAgICByZXN1bHRzIHRvIGEgc3BlY2lmaWMgbGFuZ3VhZ2UuCiAgICBkaXNjb3Zlcnlfc3BsYXNoOiA6Y2xhc3M6YHN0cmAKICAgICAgICBUaGUgZ3VpbGQncyBkaXNjb3Zlcnkgc3BsYXNoLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjMKICAgICIiIgoKICAgIF9fc2xvdHNfXyA9ICgnYWZrX3RpbWVvdXQnLCAnYWZrX2NoYW5uZWwnLCAnX21lbWJlcnMnLCAnX2NoYW5uZWxzJywgJ2ljb24nLAogICAgICAgICAgICAgICAgICduYW1lJywgJ2lkJywgJ3VuYXZhaWxhYmxlJywgJ2Jhbm5lcicsICdyZWdpb24nLCAnX3N0YXRlJywKICAgICAgICAgICAgICAgICAnX3JvbGVzJywgJ19tZW1iZXJfY291bnQnLCAnX2xhcmdlJywKICAgICAgICAgICAgICAgICAnb3duZXJfaWQnLCAnbWZhX2xldmVsJywgJ2Vtb2ppcycsICdmZWF0dXJlcycsCiAgICAgICAgICAgICAgICAgJ3ZlcmlmaWNhdGlvbl9sZXZlbCcsICdleHBsaWNpdF9jb250ZW50X2ZpbHRlcicsICdzcGxhc2gnLAogICAgICAgICAgICAgICAgICdfdm9pY2Vfc3RhdGVzJywgJ19zeXN0ZW1fY2hhbm5lbF9pZCcsICdkZWZhdWx0X25vdGlmaWNhdGlvbnMnLAogICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbicsICdtYXhfcHJlc2VuY2VzJywgJ21heF9tZW1iZXJzJywgJ21heF92aWRlb19jaGFubmVsX3VzZXJzJywKICAgICAgICAgICAgICAgICAncHJlbWl1bV90aWVyJywgJ3ByZW1pdW1fc3Vic2NyaXB0aW9uX2NvdW50JywgJ19zeXN0ZW1fY2hhbm5lbF9mbGFncycsCiAgICAgICAgICAgICAgICAgJ3ByZWZlcnJlZF9sb2NhbGUnLCAnZGlzY292ZXJ5X3NwbGFzaCcsICdfcnVsZXNfY2hhbm5lbF9pZCcsCiAgICAgICAgICAgICAgICAgJ19wdWJsaWNfdXBkYXRlc19jaGFubmVsX2lkJykKCiAgICBfUFJFTUlVTV9HVUlMRF9MSU1JVFMgPSB7CiAgICAgICAgTm9uZTogX0d1aWxkTGltaXQoZW1vamk9NTAsIGJpdHJhdGU9OTZlMywgZmlsZXNpemU9ODM4ODYwOCksCiAgICAgICAgMDogX0d1aWxkTGltaXQoZW1vamk9NTAsIGJpdHJhdGU9OTZlMywgZmlsZXNpemU9ODM4ODYwOCksCiAgICAgICAgMTogX0d1aWxkTGltaXQoZW1vamk9MTAwLCBiaXRyYXRlPTEyOGUzLCBmaWxlc2l6ZT04Mzg4NjA4KSwKICAgICAgICAyOiBfR3VpbGRMaW1pdChlbW9qaT0xNTAsIGJpdHJhdGU9MjU2ZTMsIGZpbGVzaXplPTUyNDI4ODAwKSwKICAgICAgICAzOiBfR3VpbGRMaW1pdChlbW9qaT0yNTAsIGJpdHJhdGU9Mzg0ZTMsIGZpbGVzaXplPTEwNDg1NzYwMCksCiAgICB9CgogICAgZGVmIF9faW5pdF9fKHNlbGYsICosIGRhdGEsIHN0YXRlKToKICAgICAgICBzZWxmLl9jaGFubmVscyA9IHt9CiAgICAgICAgc2VsZi5fbWVtYmVycyA9IHt9CiAgICAgICAgc2VsZi5fdm9pY2Vfc3RhdGVzID0ge30KICAgICAgICBzZWxmLl9zdGF0ZSA9IHN0YXRlCiAgICAgICAgc2VsZi5fZnJvbV9kYXRhKGRhdGEpCgogICAgZGVmIF9hZGRfY2hhbm5lbChzZWxmLCBjaGFubmVsKToKICAgICAgICBzZWxmLl9jaGFubmVsc1tjaGFubmVsLmlkXSA9IGNoYW5uZWwKCiAgICBkZWYgX3JlbW92ZV9jaGFubmVsKHNlbGYsIGNoYW5uZWwpOgogICAgICAgIHNlbGYuX2NoYW5uZWxzLnBvcChjaGFubmVsLmlkLCBOb25lKQoKICAgIGRlZiBfdm9pY2Vfc3RhdGVfZm9yKHNlbGYsIHVzZXJfaWQpOgogICAgICAgIHJldHVybiBzZWxmLl92b2ljZV9zdGF0ZXMuZ2V0KHVzZXJfaWQpCgogICAgZGVmIF9hZGRfbWVtYmVyKHNlbGYsIG1lbWJlcik6CiAgICAgICAgc2VsZi5fbWVtYmVyc1ttZW1iZXIuaWRdID0gbWVtYmVyCgogICAgZGVmIF9yZW1vdmVfbWVtYmVyKHNlbGYsIG1lbWJlcik6CiAgICAgICAgc2VsZi5fbWVtYmVycy5wb3AobWVtYmVyLmlkLCBOb25lKQoKICAgIGRlZiBfX3N0cl9fKHNlbGYpOgogICAgICAgIHJldHVybiBzZWxmLm5hbWUgb3IgJycKCiAgICBkZWYgX19yZXByX18oc2VsZik6CiAgICAgICAgYXR0cnMgPSAoCiAgICAgICAgICAgICdpZCcsICduYW1lJywgJ3NoYXJkX2lkJywgJ2NodW5rZWQnCiAgICAgICAgKQogICAgICAgIHJlc29sdmVkID0gWyclcz0lcicgJSAoYXR0ciwgZ2V0YXR0cihzZWxmLCBhdHRyKSkgZm9yIGF0dHIgaW4gYXR0cnNdCiAgICAgICAgcmVzb2x2ZWQuYXBwZW5kKCdtZW1iZXJfY291bnQ9JXInICUgZ2V0YXR0cihzZWxmLCAnX21lbWJlcl9jb3VudCcsIE5vbmUpKQogICAgICAgIHJldHVybiAnPEd1aWxkICVzPicgJSAnICcuam9pbihyZXNvbHZlZCkKCiAgICBkZWYgX3VwZGF0ZV92b2ljZV9zdGF0ZShzZWxmLCBkYXRhLCBjaGFubmVsX2lkKToKICAgICAgICB1c2VyX2lkID0gaW50KGRhdGFbJ3VzZXJfaWQnXSkKICAgICAgICBjaGFubmVsID0gc2VsZi5nZXRfY2hhbm5lbChjaGFubmVsX2lkKQogICAgICAgIHRyeToKICAgICAgICAgICAgIyBjaGVjayBpZiB3ZSBzaG91bGQgcmVtb3ZlIHRoZSB2b2ljZSBzdGF0ZSBmcm9tIGNhY2hlCiAgICAgICAgICAgIGlmIGNoYW5uZWwgaXMgTm9uZToKICAgICAgICAgICAgICAgIGFmdGVyID0gc2VsZi5fdm9pY2Vfc3RhdGVzLnBvcCh1c2VyX2lkKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgYWZ0ZXIgPSBzZWxmLl92b2ljZV9zdGF0ZXNbdXNlcl9pZF0KCiAgICAgICAgICAgIGJlZm9yZSA9IGNvcHkuY29weShhZnRlcikKICAgICAgICAgICAgYWZ0ZXIuX3VwZGF0ZShkYXRhLCBjaGFubmVsKQogICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgIyBpZiB3ZSdyZSBoZXJlIHRoZW4gd2UncmUgZ2V0dGluZyBhZGRlZCBpbnRvIHRoZSBjYWNoZQogICAgICAgICAgICBhZnRlciA9IFZvaWNlU3RhdGUoZGF0YT1kYXRhLCBjaGFubmVsPWNoYW5uZWwpCiAgICAgICAgICAgIGJlZm9yZSA9IFZvaWNlU3RhdGUoZGF0YT1kYXRhLCBjaGFubmVsPU5vbmUpCiAgICAgICAgICAgIHNlbGYuX3ZvaWNlX3N0YXRlc1t1c2VyX2lkXSA9IGFmdGVyCgogICAgICAgIG1lbWJlciA9IHNlbGYuZ2V0X21lbWJlcih1c2VyX2lkKQogICAgICAgIGlmIG1lbWJlciBpcyBOb25lOgogICAgICAgICAgICB0cnk6CiAgICAgICAgICAgICAgICBtZW1iZXIgPSBNZW1iZXIoZGF0YT1kYXRhWydtZW1iZXInXSwgc3RhdGU9c2VsZi5fc3RhdGUsIGd1aWxkPXNlbGYpCiAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgICAgIG1lbWJlciA9IE5vbmUKCiAgICAgICAgcmV0dXJuIG1lbWJlciwgYmVmb3JlLCBhZnRlcgoKICAgIGRlZiBfYWRkX3JvbGUoc2VsZiwgcm9sZSk6CiAgICAgICAgIyByb2xlcyBnZXQgYWRkZWQgdG8gdGhlIGJvdHRvbSAocG9zaXRpb24gMSwgcG9zIDAgaXMgQGV2ZXJ5b25lKQogICAgICAgICMgc28gc2luY2Ugc2VsZi5yb2xlcyBoYXMgdGhlIEBldmVyeW9uZSByb2xlLCB3ZSBjYW4ndCBpbmNyZW1lbnQKICAgICAgICAjIGl0cyBwb3NpdGlvbiBiZWNhdXNlIGl0J3Mgc3R1Y2sgYXQgcG9zaXRpb24gMC4gTHVja2lseSB4ICs9IEZhbHNlCiAgICAgICAgIyBpcyBlcXVpdmFsZW50IHRvIGFkZGluZyAwLiBTbyB3ZSBjYXN0IHRoZSBwb3NpdGlvbiB0byBhIGJvb2wgYW5kCiAgICAgICAgIyBpbmNyZW1lbnQgaXQuCiAgICAgICAgZm9yIHIgaW4gc2VsZi5fcm9sZXMudmFsdWVzKCk6CiAgICAgICAgICAgIHIucG9zaXRpb24gKz0gKG5vdCByLmlzX2RlZmF1bHQoKSkKCiAgICAgICAgc2VsZi5fcm9sZXNbcm9sZS5pZF0gPSByb2xlCgogICAgZGVmIF9yZW1vdmVfcm9sZShzZWxmLCByb2xlX2lkKToKICAgICAgICAjIHRoaXMgcmFpc2VzIEtleUVycm9yIGlmIGl0IGZhaWxzLi4KICAgICAgICByb2xlID0gc2VsZi5fcm9sZXMucG9wKHJvbGVfaWQpCgogICAgICAgICMgc2luY2UgaXQgZGlkbid0LCB3ZSBjYW4gY2hhbmdlIHRoZSBwb3NpdGlvbnMgbm93CiAgICAgICAgIyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgYWJvdmUgZXhjZXB0IHdlIG9ubHkgZGVjcmVtZW50CiAgICAgICAgIyB0aGUgcG9zaXRpb24gaWYgd2UncmUgYWJvdmUgdGhlIHJvbGUgd2UgZGVsZXRlZC4KICAgICAgICBmb3IgciBpbiBzZWxmLl9yb2xlcy52YWx1ZXMoKToKICAgICAgICAgICAgci5wb3NpdGlvbiAtPSByLnBvc2l0aW9uID4gcm9sZS5wb3NpdGlvbgoKICAgICAgICByZXR1cm4gcm9sZQoKICAgIGRlZiBfZnJvbV9kYXRhKHNlbGYsIGd1aWxkKToKICAgICAgICAjIGFjY29yZGluZyB0byBTdGFuLCB0aGlzIGlzIGFsd2F5cyBhdmFpbGFibGUgZXZlbiBpZiB0aGUgZ3VpbGQgaXMgdW5hdmFpbGFibGUKICAgICAgICAjIEkgZG9uJ3QgaGF2ZSB0aGlzIGd1YXJhbnRlZSB3aGVuIHNvbWVvbmUgdXBkYXRlcyB0aGUgZ3VpbGQuCiAgICAgICAgbWVtYmVyX2NvdW50ID0gZ3VpbGQuZ2V0KCdtZW1iZXJfY291bnQnLCBOb25lKQogICAgICAgIGlmIG1lbWJlcl9jb3VudCBpcyBub3QgTm9uZToKICAgICAgICAgICAgc2VsZi5fbWVtYmVyX2NvdW50ID0gbWVtYmVyX2NvdW50CgogICAgICAgIHNlbGYubmFtZSA9IGd1aWxkLmdldCgnbmFtZScpCiAgICAgICAgc2VsZi5yZWdpb24gPSB0cnlfZW51bShWb2ljZVJlZ2lvbiwgZ3VpbGQuZ2V0KCdyZWdpb24nKSkKICAgICAgICBzZWxmLnZlcmlmaWNhdGlvbl9sZXZlbCA9IHRyeV9lbnVtKFZlcmlmaWNhdGlvbkxldmVsLCBndWlsZC5nZXQoJ3ZlcmlmaWNhdGlvbl9sZXZlbCcpKQogICAgICAgIHNlbGYuZGVmYXVsdF9ub3RpZmljYXRpb25zID0gdHJ5X2VudW0oTm90aWZpY2F0aW9uTGV2ZWwsIGd1aWxkLmdldCgnZGVmYXVsdF9tZXNzYWdlX25vdGlmaWNhdGlvbnMnKSkKICAgICAgICBzZWxmLmV4cGxpY2l0X2NvbnRlbnRfZmlsdGVyID0gdHJ5X2VudW0oQ29udGVudEZpbHRlciwgZ3VpbGQuZ2V0KCdleHBsaWNpdF9jb250ZW50X2ZpbHRlcicsIDApKQogICAgICAgIHNlbGYuYWZrX3RpbWVvdXQgPSBndWlsZC5nZXQoJ2Fma190aW1lb3V0JykKICAgICAgICBzZWxmLmljb24gPSBndWlsZC5nZXQoJ2ljb24nKQogICAgICAgIHNlbGYuYmFubmVyID0gZ3VpbGQuZ2V0KCdiYW5uZXInKQogICAgICAgIHNlbGYudW5hdmFpbGFibGUgPSBndWlsZC5nZXQoJ3VuYXZhaWxhYmxlJywgRmFsc2UpCiAgICAgICAgc2VsZi5pZCA9IGludChndWlsZFsnaWQnXSkKICAgICAgICBzZWxmLl9yb2xlcyA9IHt9CiAgICAgICAgc3RhdGUgPSBzZWxmLl9zdGF0ZSAjIHNwZWVkIHVwIGF0dHJpYnV0ZSBhY2Nlc3MKICAgICAgICBmb3IgciBpbiBndWlsZC5nZXQoJ3JvbGVzJywgW10pOgogICAgICAgICAgICByb2xlID0gUm9sZShndWlsZD1zZWxmLCBkYXRhPXIsIHN0YXRlPXN0YXRlKQogICAgICAgICAgICBzZWxmLl9yb2xlc1tyb2xlLmlkXSA9IHJvbGUKCiAgICAgICAgc2VsZi5tZmFfbGV2ZWwgPSBndWlsZC5nZXQoJ21mYV9sZXZlbCcpCiAgICAgICAgc2VsZi5lbW9qaXMgPSB0dXBsZShtYXAobGFtYmRhIGQ6IHN0YXRlLnN0b3JlX2Vtb2ppKHNlbGYsIGQpLCBndWlsZC5nZXQoJ2Vtb2ppcycsIFtdKSkpCiAgICAgICAgc2VsZi5mZWF0dXJlcyA9IGd1aWxkLmdldCgnZmVhdHVyZXMnLCBbXSkKICAgICAgICBzZWxmLnNwbGFzaCA9IGd1aWxkLmdldCgnc3BsYXNoJykKICAgICAgICBzZWxmLl9zeXN0ZW1fY2hhbm5lbF9pZCA9IHV0aWxzLl9nZXRfYXNfc25vd2ZsYWtlKGd1aWxkLCAnc3lzdGVtX2NoYW5uZWxfaWQnKQogICAgICAgIHNlbGYuZGVzY3JpcHRpb24gPSBndWlsZC5nZXQoJ2Rlc2NyaXB0aW9uJykKICAgICAgICBzZWxmLm1heF9wcmVzZW5jZXMgPSBndWlsZC5nZXQoJ21heF9wcmVzZW5jZXMnKQogICAgICAgIHNlbGYubWF4X21lbWJlcnMgPSBndWlsZC5nZXQoJ21heF9tZW1iZXJzJykKICAgICAgICBzZWxmLm1heF92aWRlb19jaGFubmVsX3VzZXJzID0gZ3VpbGQuZ2V0KCdtYXhfdmlkZW9fY2hhbm5lbF91c2VycycpCiAgICAgICAgc2VsZi5wcmVtaXVtX3RpZXIgPSBndWlsZC5nZXQoJ3ByZW1pdW1fdGllcicsIDApCiAgICAgICAgc2VsZi5wcmVtaXVtX3N1YnNjcmlwdGlvbl9jb3VudCA9IGd1aWxkLmdldCgncHJlbWl1bV9zdWJzY3JpcHRpb25fY291bnQnKSBvciAwCiAgICAgICAgc2VsZi5fc3lzdGVtX2NoYW5uZWxfZmxhZ3MgPSBndWlsZC5nZXQoJ3N5c3RlbV9jaGFubmVsX2ZsYWdzJywgMCkKICAgICAgICBzZWxmLnByZWZlcnJlZF9sb2NhbGUgPSBndWlsZC5nZXQoJ3ByZWZlcnJlZF9sb2NhbGUnKQogICAgICAgIHNlbGYuZGlzY292ZXJ5X3NwbGFzaCA9IGd1aWxkLmdldCgnZGlzY292ZXJ5X3NwbGFzaCcpCiAgICAgICAgc2VsZi5fcnVsZXNfY2hhbm5lbF9pZCA9IHV0aWxzLl9nZXRfYXNfc25vd2ZsYWtlKGd1aWxkLCAncnVsZXNfY2hhbm5lbF9pZCcpCiAgICAgICAgc2VsZi5fcHVibGljX3VwZGF0ZXNfY2hhbm5lbF9pZCA9IHV0aWxzLl9nZXRfYXNfc25vd2ZsYWtlKGd1aWxkLCAncHVibGljX3VwZGF0ZXNfY2hhbm5lbF9pZCcpCgogICAgICAgIGNhY2hlX29ubGluZV9tZW1iZXJzID0gc2VsZi5fc3RhdGUubWVtYmVyX2NhY2hlX2ZsYWdzLm9ubGluZQogICAgICAgIGNhY2hlX2pvaW5lZCA9IHNlbGYuX3N0YXRlLm1lbWJlcl9jYWNoZV9mbGFncy5qb2luZWQKICAgICAgICBzZWxmX2lkID0gc2VsZi5fc3RhdGUuc2VsZl9pZAogICAgICAgIGZvciBtZGF0YSBpbiBndWlsZC5nZXQoJ21lbWJlcnMnLCBbXSk6CiAgICAgICAgICAgIG1lbWJlciA9IE1lbWJlcihkYXRhPW1kYXRhLCBndWlsZD1zZWxmLCBzdGF0ZT1zdGF0ZSkKICAgICAgICAgICAgaWYgY2FjaGVfam9pbmVkIG9yIChjYWNoZV9vbmxpbmVfbWVtYmVycyBhbmQgbWVtYmVyLnJhd19zdGF0dXMgIT0gJ29mZmxpbmUnKSBvciBtZW1iZXIuaWQgPT0gc2VsZl9pZDoKICAgICAgICAgICAgICAgIHNlbGYuX2FkZF9tZW1iZXIobWVtYmVyKQoKICAgICAgICBzZWxmLl9zeW5jKGd1aWxkKQogICAgICAgIHNlbGYuX2xhcmdlID0gTm9uZSBpZiBtZW1iZXJfY291bnQgaXMgTm9uZSBlbHNlIHNlbGYuX21lbWJlcl9jb3VudCA+PSAyNTAKCiAgICAgICAgc2VsZi5vd25lcl9pZCA9IHV0aWxzLl9nZXRfYXNfc25vd2ZsYWtlKGd1aWxkLCAnb3duZXJfaWQnKQogICAgICAgIHNlbGYuYWZrX2NoYW5uZWwgPSBzZWxmLmdldF9jaGFubmVsKHV0aWxzLl9nZXRfYXNfc25vd2ZsYWtlKGd1aWxkLCAnYWZrX2NoYW5uZWxfaWQnKSkKCiAgICAgICAgZm9yIG9iaiBpbiBndWlsZC5nZXQoJ3ZvaWNlX3N0YXRlcycsIFtdKToKICAgICAgICAgICAgc2VsZi5fdXBkYXRlX3ZvaWNlX3N0YXRlKG9iaiwgaW50KG9ialsnY2hhbm5lbF9pZCddKSkKCiAgICBkZWYgX3N5bmMoc2VsZiwgZGF0YSk6CiAgICAgICAgdHJ5OgogICAgICAgICAgICBzZWxmLl9sYXJnZSA9IGRhdGFbJ2xhcmdlJ10KICAgICAgICBleGNlcHQgS2V5RXJyb3I6CiAgICAgICAgICAgIHBhc3MKCiAgICAgICAgZW1wdHlfdHVwbGUgPSB0dXBsZSgpCiAgICAgICAgZm9yIHByZXNlbmNlIGluIGRhdGEuZ2V0KCdwcmVzZW5jZXMnLCBbXSk6CiAgICAgICAgICAgIHVzZXJfaWQgPSBpbnQocHJlc2VuY2VbJ3VzZXInXVsnaWQnXSkKICAgICAgICAgICAgbWVtYmVyID0gc2VsZi5nZXRfbWVtYmVyKHVzZXJfaWQpCiAgICAgICAgICAgIGlmIG1lbWJlciBpcyBub3QgTm9uZToKICAgICAgICAgICAgICAgIG1lbWJlci5fcHJlc2VuY2VfdXBkYXRlKHByZXNlbmNlLCBlbXB0eV90dXBsZSkKCiAgICAgICAgaWYgJ2NoYW5uZWxzJyBpbiBkYXRhOgogICAgICAgICAgICBjaGFubmVscyA9IGRhdGFbJ2NoYW5uZWxzJ10KICAgICAgICAgICAgZm9yIGMgaW4gY2hhbm5lbHM6CiAgICAgICAgICAgICAgICBmYWN0b3J5LCBjaF90eXBlID0gX2NoYW5uZWxfZmFjdG9yeShjWyd0eXBlJ10pCiAgICAgICAgICAgICAgICBpZiBmYWN0b3J5OgogICAgICAgICAgICAgICAgICAgIHNlbGYuX2FkZF9jaGFubmVsKGZhY3RvcnkoZ3VpbGQ9c2VsZiwgZGF0YT1jLCBzdGF0ZT1zZWxmLl9zdGF0ZSkpCgogICAgQHByb3BlcnR5CiAgICBkZWYgY2hhbm5lbHMoc2VsZik6CiAgICAgICAgIiIiTGlzdFs6Y2xhc3M6YGFiYy5HdWlsZENoYW5uZWxgXTogQSBsaXN0IG9mIGNoYW5uZWxzIHRoYXQgYmVsb25ncyB0byB0aGlzIGd1aWxkLiIiIgogICAgICAgIHJldHVybiBsaXN0KHNlbGYuX2NoYW5uZWxzLnZhbHVlcygpKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGxhcmdlKHNlbGYpOgogICAgICAgICIiIjpjbGFzczpgYm9vbGA6IEluZGljYXRlcyBpZiB0aGUgZ3VpbGQgaXMgYSAnbGFyZ2UnIGd1aWxkLgoKICAgICAgICBBIGxhcmdlIGd1aWxkIGlzIGRlZmluZWQgYXMgaGF2aW5nIG1vcmUgdGhhbiBgYGxhcmdlX3RocmVzaG9sZGBgIGNvdW50CiAgICAgICAgbWVtYmVycywgd2hpY2ggZm9yIHRoaXMgbGlicmFyeSBpcyBzZXQgdG8gdGhlIG1heGltdW0gb2YgMjUwLgogICAgICAgICIiIgogICAgICAgIGlmIHNlbGYuX2xhcmdlIGlzIE5vbmU6CiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9tZW1iZXJfY291bnQgPj0gMjUwCiAgICAgICAgICAgIGV4Y2VwdCBBdHRyaWJ1dGVFcnJvcjoKICAgICAgICAgICAgICAgIHJldHVybiBsZW4oc2VsZi5fbWVtYmVycykgPj0gMjUwCiAgICAgICAgcmV0dXJuIHNlbGYuX2xhcmdlCgogICAgQHByb3BlcnR5CiAgICBkZWYgdm9pY2VfY2hhbm5lbHMoc2VsZik6CiAgICAgICAgIiIiTGlzdFs6Y2xhc3M6YFZvaWNlQ2hhbm5lbGBdOiBBIGxpc3Qgb2Ygdm9pY2UgY2hhbm5lbHMgdGhhdCBiZWxvbmdzIHRvIHRoaXMgZ3VpbGQuCgogICAgICAgIFRoaXMgaXMgc29ydGVkIGJ5IHRoZSBwb3NpdGlvbiBhbmQgYXJlIGluIFVJIG9yZGVyIGZyb20gdG9wIHRvIGJvdHRvbS4KICAgICAgICAiIiIKICAgICAgICByID0gW2NoIGZvciBjaCBpbiBzZWxmLl9jaGFubmVscy52YWx1ZXMoKSBpZiBpc2luc3RhbmNlKGNoLCBWb2ljZUNoYW5uZWwpXQogICAgICAgIHIuc29ydChrZXk9bGFtYmRhIGM6IChjLnBvc2l0aW9uLCBjLmlkKSkKICAgICAgICByZXR1cm4gcgoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHN0YWdlX2NoYW5uZWxzKHNlbGYpOgogICAgICAgICIiIkxpc3RbOmNsYXNzOmBTdGFnZUNoYW5uZWxgXTogQSBsaXN0IG9mIHZvaWNlIGNoYW5uZWxzIHRoYXQgYmVsb25ncyB0byB0aGlzIGd1aWxkLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjcKCiAgICAgICAgVGhpcyBpcyBzb3J0ZWQgYnkgdGhlIHBvc2l0aW9uIGFuZCBhcmUgaW4gVUkgb3JkZXIgZnJvbSB0b3AgdG8gYm90dG9tLgogICAgICAgICIiIgogICAgICAgIHIgPSBbY2ggZm9yIGNoIGluIHNlbGYuX2NoYW5uZWxzLnZhbHVlcygpIGlmIGlzaW5zdGFuY2UoY2gsIFN0YWdlQ2hhbm5lbCldCiAgICAgICAgci5zb3J0KGtleT1sYW1iZGEgYzogKGMucG9zaXRpb24sIGMuaWQpKQogICAgICAgIHJldHVybiByCgogICAgQHByb3BlcnR5CiAgICBkZWYgbWUoc2VsZik6CiAgICAgICAgIiIiOmNsYXNzOmBNZW1iZXJgOiBTaW1pbGFyIHRvIDphdHRyOmBDbGllbnQudXNlcmAgZXhjZXB0IGFuIGluc3RhbmNlIG9mIDpjbGFzczpgTWVtYmVyYC4KICAgICAgICBUaGlzIGlzIGVzc2VudGlhbGx5IHVzZWQgdG8gZ2V0IHRoZSBtZW1iZXIgdmVyc2lvbiBvZiB5b3Vyc2VsZi4KICAgICAgICAiIiIKICAgICAgICBzZWxmX2lkID0gc2VsZi5fc3RhdGUudXNlci5pZAogICAgICAgIHJldHVybiBzZWxmLmdldF9tZW1iZXIoc2VsZl9pZCkKCiAgICBAcHJvcGVydHkKICAgIGRlZiB2b2ljZV9jbGllbnQoc2VsZik6CiAgICAgICAgIiIiT3B0aW9uYWxbOmNsYXNzOmBWb2ljZVByb3RvY29sYF06IFJldHVybnMgdGhlIDpjbGFzczpgVm9pY2VQcm90b2NvbGAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZ3VpbGQsIGlmIGFueS4iIiIKICAgICAgICByZXR1cm4gc2VsZi5fc3RhdGUuX2dldF92b2ljZV9jbGllbnQoc2VsZi5pZCkKCiAgICBAcHJvcGVydHkKICAgIGRlZiB0ZXh0X2NoYW5uZWxzKHNlbGYpOgogICAgICAgICIiIkxpc3RbOmNsYXNzOmBUZXh0Q2hhbm5lbGBdOiBBIGxpc3Qgb2YgdGV4dCBjaGFubmVscyB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBndWlsZC4KCiAgICAgICAgVGhpcyBpcyBzb3J0ZWQgYnkgdGhlIHBvc2l0aW9uIGFuZCBhcmUgaW4gVUkgb3JkZXIgZnJvbSB0b3AgdG8gYm90dG9tLgogICAgICAgICIiIgogICAgICAgIHIgPSBbY2ggZm9yIGNoIGluIHNlbGYuX2NoYW5uZWxzLnZhbHVlcygpIGlmIGlzaW5zdGFuY2UoY2gsIFRleHRDaGFubmVsKV0KICAgICAgICByLnNvcnQoa2V5PWxhbWJkYSBjOiAoYy5wb3NpdGlvbiwgYy5pZCkpCiAgICAgICAgcmV0dXJuIHIKCiAgICBAcHJvcGVydHkKICAgIGRlZiBjYXRlZ29yaWVzKHNlbGYpOgogICAgICAgICIiIkxpc3RbOmNsYXNzOmBDYXRlZ29yeUNoYW5uZWxgXTogQSBsaXN0IG9mIGNhdGVnb3JpZXMgdGhhdCBiZWxvbmdzIHRvIHRoaXMgZ3VpbGQuCgogICAgICAgIFRoaXMgaXMgc29ydGVkIGJ5IHRoZSBwb3NpdGlvbiBhbmQgYXJlIGluIFVJIG9yZGVyIGZyb20gdG9wIHRvIGJvdHRvbS4KICAgICAgICAiIiIKICAgICAgICByID0gW2NoIGZvciBjaCBpbiBzZWxmLl9jaGFubmVscy52YWx1ZXMoKSBpZiBpc2luc3RhbmNlKGNoLCBDYXRlZ29yeUNoYW5uZWwpXQogICAgICAgIHIuc29ydChrZXk9bGFtYmRhIGM6IChjLnBvc2l0aW9uLCBjLmlkKSkKICAgICAgICByZXR1cm4gcgoKICAgIGRlZiBieV9jYXRlZ29yeShzZWxmKToKICAgICAgICAiIiJSZXR1cm5zIGV2ZXJ5IDpjbGFzczpgQ2F0ZWdvcnlDaGFubmVsYCBhbmQgdGhlaXIgYXNzb2NpYXRlZCBjaGFubmVscy4KCiAgICAgICAgVGhlc2UgY2hhbm5lbHMgYW5kIGNhdGVnb3JpZXMgYXJlIHNvcnRlZCBpbiB0aGUgb2ZmaWNpYWwgRGlzY29yZCBVSSBvcmRlci4KCiAgICAgICAgSWYgdGhlIGNoYW5uZWxzIGRvIG5vdCBoYXZlIGEgY2F0ZWdvcnksIHRoZW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIHR1cGxlIGlzCiAgICAgICAgYGBOb25lYGAuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLQogICAgICAgIExpc3RbVHVwbGVbT3B0aW9uYWxbOmNsYXNzOmBDYXRlZ29yeUNoYW5uZWxgXSwgTGlzdFs6Y2xhc3M6YGFiYy5HdWlsZENoYW5uZWxgXV1dOgogICAgICAgICAgICBUaGUgY2F0ZWdvcmllcyBhbmQgdGhlaXIgYXNzb2NpYXRlZCBjaGFubmVscy4KICAgICAgICAiIiIKICAgICAgICBncm91cGVkID0ge30KICAgICAgICBmb3IgY2hhbm5lbCBpbiBzZWxmLl9jaGFubmVscy52YWx1ZXMoKToKICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShjaGFubmVsLCBDYXRlZ29yeUNoYW5uZWwpOgogICAgICAgICAgICAgICAgZ3JvdXBlZC5zZXRkZWZhdWx0KGNoYW5uZWwuaWQsIFtdKQogICAgICAgICAgICAgICAgY29udGludWUKCiAgICAgICAgICAgIHRyeToKICAgICAgICAgICAgICAgIGdyb3VwZWRbY2hhbm5lbC5jYXRlZ29yeV9pZF0uYXBwZW5kKGNoYW5uZWwpCiAgICAgICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgICAgIGdyb3VwZWRbY2hhbm5lbC5jYXRlZ29yeV9pZF0gPSBbY2hhbm5lbF0KCiAgICAgICAgZGVmIGtleSh0KToKICAgICAgICAgICAgaywgdiA9IHQKICAgICAgICAgICAgcmV0dXJuICgoay5wb3NpdGlvbiwgay5pZCkgaWYgayBlbHNlICgtMSwgLTEpLCB2KQoKICAgICAgICBfZ2V0ID0gc2VsZi5fY2hhbm5lbHMuZ2V0CiAgICAgICAgYXNfbGlzdCA9IFsoX2dldChrKSwgdikgZm9yIGssIHYgaW4gZ3JvdXBlZC5pdGVtcygpXQogICAgICAgIGFzX2xpc3Quc29ydChrZXk9a2V5KQogICAgICAgIGZvciBfLCBjaGFubmVscyBpbiBhc19saXN0OgogICAgICAgICAgICBjaGFubmVscy5zb3J0KGtleT1sYW1iZGEgYzogKGMuX3NvcnRpbmdfYnVja2V0LCBjLnBvc2l0aW9uLCBjLmlkKSkKICAgICAgICByZXR1cm4gYXNfbGlzdAoKICAgIGRlZiBnZXRfY2hhbm5lbChzZWxmLCBjaGFubmVsX2lkKToKICAgICAgICAiIiJSZXR1cm5zIGEgY2hhbm5lbCB3aXRoIHRoZSBnaXZlbiBJRC4KCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgY2hhbm5lbF9pZDogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBJRCB0byBzZWFyY2ggZm9yLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICBPcHRpb25hbFs6Y2xhc3M6YC5hYmMuR3VpbGRDaGFubmVsYF0KICAgICAgICAgICAgVGhlIHJldHVybmVkIGNoYW5uZWwgb3IgYGBOb25lYGAgaWYgbm90IGZvdW5kLgogICAgICAgICIiIgogICAgICAgIHJldHVybiBzZWxmLl9jaGFubmVscy5nZXQoY2hhbm5lbF9pZCkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBzeXN0ZW1fY2hhbm5lbChzZWxmKToKICAgICAgICAiIiJPcHRpb25hbFs6Y2xhc3M6YFRleHRDaGFubmVsYF06IFJldHVybnMgdGhlIGd1aWxkJ3MgY2hhbm5lbCB1c2VkIGZvciBzeXN0ZW0gbWVzc2FnZXMuCgogICAgICAgIElmIG5vIGNoYW5uZWwgaXMgc2V0LCB0aGVuIHRoaXMgcmV0dXJucyBgYE5vbmVgYC4KICAgICAgICAiIiIKICAgICAgICBjaGFubmVsX2lkID0gc2VsZi5fc3lzdGVtX2NoYW5uZWxfaWQKICAgICAgICByZXR1cm4gY2hhbm5lbF9pZCBhbmQgc2VsZi5fY2hhbm5lbHMuZ2V0KGNoYW5uZWxfaWQpCgogICAgQHByb3BlcnR5CiAgICBkZWYgc3lzdGVtX2NoYW5uZWxfZmxhZ3Moc2VsZik6CiAgICAgICAgIiIiOmNsYXNzOmBTeXN0ZW1DaGFubmVsRmxhZ3NgOiBSZXR1cm5zIHRoZSBndWlsZCdzIHN5c3RlbSBjaGFubmVsIHNldHRpbmdzLiIiIgogICAgICAgIHJldHVybiBTeXN0ZW1DaGFubmVsRmxhZ3MuX2Zyb21fdmFsdWUoc2VsZi5fc3lzdGVtX2NoYW5uZWxfZmxhZ3MpCgogICAgQHByb3BlcnR5CiAgICBkZWYgcnVsZXNfY2hhbm5lbChzZWxmKToKICAgICAgICAiIiJPcHRpb25hbFs6Y2xhc3M6YFRleHRDaGFubmVsYF06IFJldHVybidzIHRoZSBndWlsZCdzIGNoYW5uZWwgdXNlZCBmb3IgdGhlIHJ1bGVzLgogICAgICAgIFRoZSBndWlsZCBtdXN0IGJlIGEgQ29tbXVuaXR5IGd1aWxkLgoKICAgICAgICBJZiBubyBjaGFubmVsIGlzIHNldCwgdGhlbiB0aGlzIHJldHVybnMgYGBOb25lYGAuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuMwogICAgICAgICIiIgogICAgICAgIGNoYW5uZWxfaWQgPSBzZWxmLl9ydWxlc19jaGFubmVsX2lkCiAgICAgICAgcmV0dXJuIGNoYW5uZWxfaWQgYW5kIHNlbGYuX2NoYW5uZWxzLmdldChjaGFubmVsX2lkKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHB1YmxpY191cGRhdGVzX2NoYW5uZWwoc2VsZik6CiAgICAgICAgIiIiT3B0aW9uYWxbOmNsYXNzOmBUZXh0Q2hhbm5lbGBdOiBSZXR1cm4ncyB0aGUgZ3VpbGQncyBjaGFubmVsIHdoZXJlIGFkbWlucyBhbmQKICAgICAgICBtb2RlcmF0b3JzIG9mIHRoZSBndWlsZHMgcmVjZWl2ZSBub3RpY2VzIGZyb20gRGlzY29yZC4gVGhlIGd1aWxkIG11c3QgYmUgYQogICAgICAgIENvbW11bml0eSBndWlsZC4KCiAgICAgICAgSWYgbm8gY2hhbm5lbCBpcyBzZXQsIHRoZW4gdGhpcyByZXR1cm5zIGBgTm9uZWBgLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjQKICAgICAgICAiIiIKICAgICAgICBjaGFubmVsX2lkID0gc2VsZi5fcHVibGljX3VwZGF0ZXNfY2hhbm5lbF9pZAogICAgICAgIHJldHVybiBjaGFubmVsX2lkIGFuZCBzZWxmLl9jaGFubmVscy5nZXQoY2hhbm5lbF9pZCkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBlbW9qaV9saW1pdChzZWxmKToKICAgICAgICAiIiI6Y2xhc3M6YGludGA6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbW9qaSBzbG90cyB0aGlzIGd1aWxkIGhhcy4iIiIKICAgICAgICBtb3JlX2Vtb2ppID0gMjAwIGlmICdNT1JFX0VNT0pJJyBpbiBzZWxmLmZlYXR1cmVzIGVsc2UgNTAKICAgICAgICByZXR1cm4gbWF4KG1vcmVfZW1vamksIHNlbGYuX1BSRU1JVU1fR1VJTERfTElNSVRTW3NlbGYucHJlbWl1bV90aWVyXS5lbW9qaSkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBiaXRyYXRlX2xpbWl0KHNlbGYpOgogICAgICAgICIiIjpjbGFzczpgZmxvYXRgOiBUaGUgbWF4aW11bSBiaXRyYXRlIGZvciB2b2ljZSBjaGFubmVscyB0aGlzIGd1aWxkIGNhbiBoYXZlLiIiIgogICAgICAgIHZpcF9ndWlsZCA9IHNlbGYuX1BSRU1JVU1fR1VJTERfTElNSVRTWzFdLmJpdHJhdGUgaWYgJ1ZJUF9SRUdJT05TJyBpbiBzZWxmLmZlYXR1cmVzIGVsc2UgOTZlMwogICAgICAgIHJldHVybiBtYXgodmlwX2d1aWxkLCBzZWxmLl9QUkVNSVVNX0dVSUxEX0xJTUlUU1tzZWxmLnByZW1pdW1fdGllcl0uYml0cmF0ZSkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBmaWxlc2l6ZV9saW1pdChzZWxmKToKICAgICAgICAiIiI6Y2xhc3M6YGludGA6IFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlcyBmaWxlcyBjYW4gaGF2ZSB3aGVuIHVwbG9hZGVkIHRvIHRoaXMgZ3VpbGQuIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuX1BSRU1JVU1fR1VJTERfTElNSVRTW3NlbGYucHJlbWl1bV90aWVyXS5maWxlc2l6ZQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIG1lbWJlcnMoc2VsZik6CiAgICAgICAgIiIiTGlzdFs6Y2xhc3M6YE1lbWJlcmBdOiBBIGxpc3Qgb2YgbWVtYmVycyB0aGF0IGJlbG9uZyB0byB0aGlzIGd1aWxkLiIiIgogICAgICAgIHJldHVybiBsaXN0KHNlbGYuX21lbWJlcnMudmFsdWVzKCkpCgogICAgZGVmIGdldF9tZW1iZXIoc2VsZiwgdXNlcl9pZCk6CiAgICAgICAgIiIiUmV0dXJucyBhIG1lbWJlciB3aXRoIHRoZSBnaXZlbiBJRC4KCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgdXNlcl9pZDogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBJRCB0byBzZWFyY2ggZm9yLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICBPcHRpb25hbFs6Y2xhc3M6YE1lbWJlcmBdCiAgICAgICAgICAgIFRoZSBtZW1iZXIgb3IgYGBOb25lYGAgaWYgbm90IGZvdW5kLgogICAgICAgICIiIgogICAgICAgIHJldHVybiBzZWxmLl9tZW1iZXJzLmdldCh1c2VyX2lkKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHByZW1pdW1fc3Vic2NyaWJlcnMoc2VsZik6CiAgICAgICAgIiIiTGlzdFs6Y2xhc3M6YE1lbWJlcmBdOiBBIGxpc3Qgb2YgbWVtYmVycyB3aG8gaGF2ZSAiYm9vc3RlZCIgdGhpcyBndWlsZC4iIiIKICAgICAgICByZXR1cm4gW21lbWJlciBmb3IgbWVtYmVyIGluIHNlbGYubWVtYmVycyBpZiBtZW1iZXIucHJlbWl1bV9zaW5jZSBpcyBub3QgTm9uZV0KCiAgICBAcHJvcGVydHkKICAgIGRlZiByb2xlcyhzZWxmKToKICAgICAgICAiIiJMaXN0WzpjbGFzczpgUm9sZWBdOiBSZXR1cm5zIGEgOmNsYXNzOmBsaXN0YCBvZiB0aGUgZ3VpbGQncyByb2xlcyBpbiBoaWVyYXJjaHkgb3JkZXIuCgogICAgICAgIFRoZSBmaXJzdCBlbGVtZW50IG9mIHRoaXMgbGlzdCB3aWxsIGJlIHRoZSBsb3dlc3Qgcm9sZSBpbiB0aGUKICAgICAgICBoaWVyYXJjaHkuCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIHNvcnRlZChzZWxmLl9yb2xlcy52YWx1ZXMoKSkKCiAgICBkZWYgZ2V0X3JvbGUoc2VsZiwgcm9sZV9pZCk6CiAgICAgICAgIiIiUmV0dXJucyBhIHJvbGUgd2l0aCB0aGUgZ2l2ZW4gSUQuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIHJvbGVfaWQ6IDpjbGFzczpgaW50YAogICAgICAgICAgICBUaGUgSUQgdG8gc2VhcmNoIGZvci4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgT3B0aW9uYWxbOmNsYXNzOmBSb2xlYF0KICAgICAgICAgICAgVGhlIHJvbGUgb3IgYGBOb25lYGAgaWYgbm90IGZvdW5kLgogICAgICAgICIiIgogICAgICAgIHJldHVybiBzZWxmLl9yb2xlcy5nZXQocm9sZV9pZCkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBkZWZhdWx0X3JvbGUoc2VsZik6CiAgICAgICAgIiIiOmNsYXNzOmBSb2xlYDogR2V0cyB0aGUgQGV2ZXJ5b25lIHJvbGUgdGhhdCBhbGwgbWVtYmVycyBoYXZlIGJ5IGRlZmF1bHQuIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0X3JvbGUoc2VsZi5pZCkKCiAgICBAcHJvcGVydHkKICAgIGRlZiBwcmVtaXVtX3N1YnNjcmliZXJfcm9sZShzZWxmKToKICAgICAgICAiIiJPcHRpb25hbFs6Y2xhc3M6YFJvbGVgXTogR2V0cyB0aGUgcHJlbWl1bSBzdWJzY3JpYmVyIHJvbGUsIEFLQSAiYm9vc3QiIHJvbGUsIGluIHRoaXMgZ3VpbGQuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuNgogICAgICAgICIiIgogICAgICAgIGZvciByb2xlIGluIHNlbGYuX3JvbGVzLnZhbHVlcygpOgogICAgICAgICAgICBpZiByb2xlLmlzX3ByZW1pdW1fc3Vic2NyaWJlcigpOgogICAgICAgICAgICAgICAgcmV0dXJuIHJvbGUKICAgICAgICByZXR1cm4gTm9uZQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHNlbGZfcm9sZShzZWxmKToKICAgICAgICAiIiJPcHRpb25hbFs6Y2xhc3M6YFJvbGVgXTogR2V0cyB0aGUgcm9sZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjbGllbnQncyB1c2VyLCBpZiBhbnkuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuNgogICAgICAgICIiIgogICAgICAgIHNlbGZfaWQgPSBzZWxmLl9zdGF0ZS5zZWxmX2lkCiAgICAgICAgZm9yIHJvbGUgaW4gc2VsZi5fcm9sZXMudmFsdWVzKCk6CiAgICAgICAgICAgIHRhZ3MgPSByb2xlLnRhZ3MKICAgICAgICAgICAgaWYgdGFncyBhbmQgdGFncy5ib3RfaWQgPT0gc2VsZl9pZDoKICAgICAgICAgICAgICAgIHJldHVybiByb2xlCiAgICAgICAgcmV0dXJuIE5vbmUKCiAgICBAcHJvcGVydHkKICAgIGRlZiBvd25lcihzZWxmKToKICAgICAgICAiIiJPcHRpb25hbFs6Y2xhc3M6YE1lbWJlcmBdOiBUaGUgbWVtYmVyIHRoYXQgb3ducyB0aGUgZ3VpbGQuIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0X21lbWJlcihzZWxmLm93bmVyX2lkKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGljb25fdXJsKHNlbGYpOgogICAgICAgICIiIjpjbGFzczpgQXNzZXRgOiBSZXR1cm5zIHRoZSBndWlsZCdzIGljb24gYXNzZXQuIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuaWNvbl91cmxfYXMoKQoKICAgIGRlZiBpc19pY29uX2FuaW1hdGVkKHNlbGYpOgogICAgICAgICIiIjpjbGFzczpgYm9vbGA6IFJldHVybnMgVHJ1ZSBpZiB0aGUgZ3VpbGQgaGFzIGFuIGFuaW1hdGVkIGljb24uIiIiCiAgICAgICAgcmV0dXJuIGJvb2woc2VsZi5pY29uIGFuZCBzZWxmLmljb24uc3RhcnRzd2l0aCgnYV8nKSkKCiAgICBkZWYgaWNvbl91cmxfYXMoc2VsZiwgKiwgZm9ybWF0PU5vbmUsIHN0YXRpY19mb3JtYXQ9J3dlYnAnLCBzaXplPTEwMjQpOgogICAgICAgICIiIlJldHVybnMgYW4gOmNsYXNzOmBBc3NldGAgZm9yIHRoZSBndWlsZCdzIGljb24uCgogICAgICAgIFRoZSBmb3JtYXQgbXVzdCBiZSBvbmUgb2YgJ3dlYnAnLCAnanBlZycsICdqcGcnLCAncG5nJyBvciAnZ2lmJywgYW5kCiAgICAgICAgJ2dpZicgaXMgb25seSB2YWxpZCBmb3IgYW5pbWF0ZWQgYXZhdGFycy4gVGhlIHNpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDIKICAgICAgICBiZXR3ZWVuIDE2IGFuZCA0MDk2LgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBmb3JtYXQ6IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIGZvcm1hdCB0byBhdHRlbXB0IHRvIGNvbnZlcnQgdGhlIGljb24gdG8uCiAgICAgICAgICAgIElmIHRoZSBmb3JtYXQgaXMgYGBOb25lYGAsIHRoZW4gaXQgaXMgYXV0b21hdGljYWxseQogICAgICAgICAgICBkZXRlY3RlZCBpbnRvIGVpdGhlciAnZ2lmJyBvciBzdGF0aWNfZm9ybWF0IGRlcGVuZGluZyBvbiB0aGUKICAgICAgICAgICAgaWNvbiBiZWluZyBhbmltYXRlZCBvciBub3QuCiAgICAgICAgc3RhdGljX2Zvcm1hdDogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgICAgICBGb3JtYXQgdG8gYXR0ZW1wdCB0byBjb252ZXJ0IG9ubHkgbm9uLWFuaW1hdGVkIGljb25zIHRvLgogICAgICAgIHNpemU6IDpjbGFzczpgaW50YAogICAgICAgICAgICBUaGUgc2l6ZSBvZiB0aGUgaW1hZ2UgdG8gZGlzcGxheS4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tCiAgICAgICAgSW52YWxpZEFyZ3VtZW50CiAgICAgICAgICAgIEJhZCBpbWFnZSBmb3JtYXQgcGFzc2VkIHRvIGBgZm9ybWF0YGAgb3IgaW52YWxpZCBgYHNpemVgYC4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgOmNsYXNzOmBBc3NldGAKICAgICAgICAgICAgVGhlIHJlc3VsdGluZyBDRE4gYXNzZXQuCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIEFzc2V0Ll9mcm9tX2d1aWxkX2ljb24oc2VsZi5fc3RhdGUsIHNlbGYsIGZvcm1hdD1mb3JtYXQsIHN0YXRpY19mb3JtYXQ9c3RhdGljX2Zvcm1hdCwgc2l6ZT1zaXplKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGJhbm5lcl91cmwoc2VsZik6CiAgICAgICAgIiIiOmNsYXNzOmBBc3NldGA6IFJldHVybnMgdGhlIGd1aWxkJ3MgYmFubmVyIGFzc2V0LiIiIgogICAgICAgIHJldHVybiBzZWxmLmJhbm5lcl91cmxfYXMoKQoKICAgIGRlZiBiYW5uZXJfdXJsX2FzKHNlbGYsICosIGZvcm1hdD0nd2VicCcsIHNpemU9MjA0OCk6CiAgICAgICAgIiIiUmV0dXJucyBhbiA6Y2xhc3M6YEFzc2V0YCBmb3IgdGhlIGd1aWxkJ3MgYmFubmVyLgoKICAgICAgICBUaGUgZm9ybWF0IG11c3QgYmUgb25lIG9mICd3ZWJwJywgJ2pwZWcnLCBvciAncG5nJy4gVGhlCiAgICAgICAgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMiBiZXR3ZWVuIDE2IGFuZCA0MDk2LgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBmb3JtYXQ6IDpjbGFzczpgc3RyYAogICAgICAgICAgICBUaGUgZm9ybWF0IHRvIGF0dGVtcHQgdG8gY29udmVydCB0aGUgYmFubmVyIHRvLgogICAgICAgIHNpemU6IDpjbGFzczpgaW50YAogICAgICAgICAgICBUaGUgc2l6ZSBvZiB0aGUgaW1hZ2UgdG8gZGlzcGxheS4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tCiAgICAgICAgSW52YWxpZEFyZ3VtZW50CiAgICAgICAgICAgIEJhZCBpbWFnZSBmb3JtYXQgcGFzc2VkIHRvIGBgZm9ybWF0YGAgb3IgaW52YWxpZCBgYHNpemVgYC4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgOmNsYXNzOmBBc3NldGAKICAgICAgICAgICAgVGhlIHJlc3VsdGluZyBDRE4gYXNzZXQuCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIEFzc2V0Ll9mcm9tX2d1aWxkX2ltYWdlKHNlbGYuX3N0YXRlLCBzZWxmLmlkLCBzZWxmLmJhbm5lciwgJ2Jhbm5lcnMnLCBmb3JtYXQ9Zm9ybWF0LCBzaXplPXNpemUpCgogICAgQHByb3BlcnR5CiAgICBkZWYgc3BsYXNoX3VybChzZWxmKToKICAgICAgICAiIiI6Y2xhc3M6YEFzc2V0YDogUmV0dXJucyB0aGUgZ3VpbGQncyBpbnZpdGUgc3BsYXNoIGFzc2V0LiIiIgogICAgICAgIHJldHVybiBzZWxmLnNwbGFzaF91cmxfYXMoKQoKICAgIGRlZiBzcGxhc2hfdXJsX2FzKHNlbGYsICosIGZvcm1hdD0nd2VicCcsIHNpemU9MjA0OCk6CiAgICAgICAgIiIiUmV0dXJucyBhbiA6Y2xhc3M6YEFzc2V0YCBmb3IgdGhlIGd1aWxkJ3MgaW52aXRlIHNwbGFzaC4KCiAgICAgICAgVGhlIGZvcm1hdCBtdXN0IGJlIG9uZSBvZiAnd2VicCcsICdqcGVnJywgJ2pwZycsIG9yICdwbmcnLiBUaGUKICAgICAgICBzaXplIG11c3QgYmUgYSBwb3dlciBvZiAyIGJldHdlZW4gMTYgYW5kIDQwOTYuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIGZvcm1hdDogOmNsYXNzOmBzdHJgCiAgICAgICAgICAgIFRoZSBmb3JtYXQgdG8gYXR0ZW1wdCB0byBjb252ZXJ0IHRoZSBzcGxhc2ggdG8uCiAgICAgICAgc2l6ZTogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBzaXplIG9mIHRoZSBpbWFnZSB0byBkaXNwbGF5LgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0KICAgICAgICBJbnZhbGlkQXJndW1lbnQKICAgICAgICAgICAgQmFkIGltYWdlIGZvcm1hdCBwYXNzZWQgdG8gYGBmb3JtYXRgYCBvciBpbnZhbGlkIGBgc2l6ZWBgLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICA6Y2xhc3M6YEFzc2V0YAogICAgICAgICAgICBUaGUgcmVzdWx0aW5nIENETiBhc3NldC4KICAgICAgICAiIiIKICAgICAgICByZXR1cm4gQXNzZXQuX2Zyb21fZ3VpbGRfaW1hZ2Uoc2VsZi5fc3RhdGUsIHNlbGYuaWQsIHNlbGYuc3BsYXNoLCAnc3BsYXNoZXMnLCBmb3JtYXQ9Zm9ybWF0LCBzaXplPXNpemUpCgogICAgQHByb3BlcnR5CiAgICBkZWYgZGlzY292ZXJ5X3NwbGFzaF91cmwoc2VsZik6CiAgICAgICAgIiIiOmNsYXNzOmBBc3NldGA6IFJldHVybnMgdGhlIGd1aWxkJ3MgZGlzY292ZXJ5IHNwbGFzaCBhc3NldC4KCiAgICAgICAgLi4gdmVyc2lvbmFkZGVkOjogMS4zCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuZGlzY292ZXJ5X3NwbGFzaF91cmxfYXMoKQoKICAgIGRlZiBkaXNjb3Zlcnlfc3BsYXNoX3VybF9hcyhzZWxmLCAqLCBmb3JtYXQ9J3dlYnAnLCBzaXplPTIwNDgpOgogICAgICAgICIiIlJldHVybnMgYW4gOmNsYXNzOmBBc3NldGAgZm9yIHRoZSBndWlsZCdzIGRpc2NvdmVyeSBzcGxhc2guCgogICAgICAgIFRoZSBmb3JtYXQgbXVzdCBiZSBvbmUgb2YgJ3dlYnAnLCAnanBlZycsICdqcGcnLCBvciAncG5nJy4gVGhlCiAgICAgICAgc2l6ZSBtdXN0IGJlIGEgcG93ZXIgb2YgMiBiZXR3ZWVuIDE2IGFuZCA0MDk2LgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjMKCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgZm9ybWF0OiA6Y2xhc3M6YHN0cmAKICAgICAgICAgICAgVGhlIGZvcm1hdCB0byBhdHRlbXB0IHRvIGNvbnZlcnQgdGhlIHNwbGFzaCB0by4KICAgICAgICBzaXplOiA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIHNpemUgb2YgdGhlIGltYWdlIHRvIGRpc3BsYXkuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLQogICAgICAgIEludmFsaWRBcmd1bWVudAogICAgICAgICAgICBCYWQgaW1hZ2UgZm9ybWF0IHBhc3NlZCB0byBgYGZvcm1hdGBgIG9yIGludmFsaWQgYGBzaXplYGAuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLQogICAgICAgIDpjbGFzczpgQXNzZXRgCiAgICAgICAgICAgIFRoZSByZXN1bHRpbmcgQ0ROIGFzc2V0LgogICAgICAgICIiIgogICAgICAgIHJldHVybiBBc3NldC5fZnJvbV9ndWlsZF9pbWFnZShzZWxmLl9zdGF0ZSwgc2VsZi5pZCwgc2VsZi5kaXNjb3Zlcnlfc3BsYXNoLCAnZGlzY292ZXJ5LXNwbGFzaGVzJywgZm9ybWF0PWZvcm1hdCwgc2l6ZT1zaXplKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIG1lbWJlcl9jb3VudChzZWxmKToKICAgICAgICAiIiI6Y2xhc3M6YGludGA6IFJldHVybnMgdGhlIHRydWUgbWVtYmVyIGNvdW50IHJlZ2FyZGxlc3Mgb2YgaXQgYmVpbmcgbG9hZGVkIGZ1bGx5IG9yIG5vdC4KCiAgICAgICAgLi4gd2FybmluZzo6CgogICAgICAgICAgICBEdWUgdG8gYSBEaXNjb3JkIGxpbWl0YXRpb24sIGluIG9yZGVyIGZvciB0aGlzIGF0dHJpYnV0ZSB0byByZW1haW4gdXAtdG8tZGF0ZSBhbmQKICAgICAgICAgICAgYWNjdXJhdGUsIGl0IHJlcXVpcmVzIDphdHRyOmBJbnRlbnRzLm1lbWJlcnNgIHRvIGJlIHNwZWNpZmllZC4KCiAgICAgICAgIiIiCiAgICAgICAgcmV0dXJuIHNlbGYuX21lbWJlcl9jb3VudAoKICAgIEBwcm9wZXJ0eQogICAgZGVmIGNodW5rZWQoc2VsZik6CiAgICAgICAgIiIiOmNsYXNzOmBib29sYDogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgZ3VpbGQgaXMgImNodW5rZWQiLgoKICAgICAgICBBIGNodW5rZWQgZ3VpbGQgbWVhbnMgdGhhdCA6YXR0cjpgbWVtYmVyX2NvdW50YCBpcyBlcXVhbCB0byB0aGUKICAgICAgICBudW1iZXIgb2YgbWVtYmVycyBzdG9yZWQgaW4gdGhlIGludGVybmFsIDphdHRyOmBtZW1iZXJzYCBjYWNoZS4KCiAgICAgICAgSWYgdGhpcyB2YWx1ZSByZXR1cm5zIGBgRmFsc2VgYCwgdGhlbiB5b3Ugc2hvdWxkIHJlcXVlc3QgZm9yCiAgICAgICAgb2ZmbGluZSBtZW1iZXJzLgogICAgICAgICIiIgogICAgICAgIGNvdW50ID0gZ2V0YXR0cihzZWxmLCAnX21lbWJlcl9jb3VudCcsIE5vbmUpCiAgICAgICAgaWYgY291bnQgaXMgTm9uZToKICAgICAgICAgICAgcmV0dXJuIEZhbHNlCiAgICAgICAgcmV0dXJuIGNvdW50ID09IGxlbihzZWxmLl9tZW1iZXJzKQoKICAgIEBwcm9wZXJ0eQogICAgZGVmIHNoYXJkX2lkKHNlbGYpOgogICAgICAgICIiIjpjbGFzczpgaW50YDogUmV0dXJucyB0aGUgc2hhcmQgSUQgZm9yIHRoaXMgZ3VpbGQgaWYgYXBwbGljYWJsZS4iIiIKICAgICAgICBjb3VudCA9IHNlbGYuX3N0YXRlLnNoYXJkX2NvdW50CiAgICAgICAgaWYgY291bnQgaXMgTm9uZToKICAgICAgICAgICAgcmV0dXJuIE5vbmUKICAgICAgICByZXR1cm4gKHNlbGYuaWQgPj4gMjIpICUgY291bnQKCiAgICBAcHJvcGVydHkKICAgIGRlZiBjcmVhdGVkX2F0KHNlbGYpOgogICAgICAgICIiIjpjbGFzczpgZGF0ZXRpbWUuZGF0ZXRpbWVgOiBSZXR1cm5zIHRoZSBndWlsZCdzIGNyZWF0aW9uIHRpbWUgaW4gVVRDLiIiIgogICAgICAgIHJldHVybiB1dGlscy5zbm93Zmxha2VfdGltZShzZWxmLmlkKQoKICAgIGRlZiBnZXRfbWVtYmVyX25hbWVkKHNlbGYsIG5hbWUpOgogICAgICAgICIiIlJldHVybnMgdGhlIGZpcnN0IG1lbWJlciBmb3VuZCB0aGF0IG1hdGNoZXMgdGhlIG5hbWUgcHJvdmlkZWQuCgogICAgICAgIFRoZSBuYW1lIGNhbiBoYXZlIGFuIG9wdGlvbmFsIGRpc2NyaW1pbmF0b3IgYXJndW1lbnQsIGUuZy4gIkpha2UjMDAwMSIKICAgICAgICBvciAiSmFrZSIgd2lsbCBib3RoIGRvIHRoZSBsb29rdXAuIEhvd2V2ZXIgdGhlIGZvcm1lciB3aWxsIGdpdmUgYSBtb3JlCiAgICAgICAgcHJlY2lzZSByZXN1bHQuIE5vdGUgdGhhdCB0aGUgZGlzY3JpbWluYXRvciBtdXN0IGhhdmUgYWxsIDQgZGlnaXRzCiAgICAgICAgZm9yIHRoaXMgdG8gd29yay4KCiAgICAgICAgSWYgYSBuaWNrbmFtZSBpcyBwYXNzZWQsIHRoZW4gaXQgaXMgbG9va2VkIHVwIHZpYSB0aGUgbmlja25hbWUuIE5vdGUKICAgICAgICBob3dldmVyLCB0aGF0IGEgbmlja25hbWUgKyBkaXNjcmltaW5hdG9yIGNvbWJvIHdpbGwgbm90IGxvb2t1cCB0aGUgbmlja25hbWUKICAgICAgICBidXQgcmF0aGVyIHRoZSB1c2VybmFtZSArIGRpc2NyaW1pbmF0b3IgY29tYm8gZHVlIHRvIG5pY2tuYW1lICsgZGlzY3JpbWluYXRvcgogICAgICAgIG5vdCBiZWluZyB1bmlxdWUuCgogICAgICAgIElmIG5vIG1lbWJlciBpcyBmb3VuZCwgYGBOb25lYGAgaXMgcmV0dXJuZWQuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIG5hbWU6IDpjbGFzczpgc3RyYAogICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgbWVtYmVyIHRvIGxvb2t1cCB3aXRoIGFuIG9wdGlvbmFsIGRpc2NyaW1pbmF0b3IuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLQogICAgICAgIE9wdGlvbmFsWzpjbGFzczpgTWVtYmVyYF0KICAgICAgICAgICAgVGhlIG1lbWJlciBpbiB0aGlzIGd1aWxkIHdpdGggdGhlIGFzc29jaWF0ZWQgbmFtZS4gSWYgbm90IGZvdW5kCiAgICAgICAgICAgIHRoZW4gYGBOb25lYGAgaXMgcmV0dXJuZWQuCiAgICAgICAgIiIiCgogICAgICAgIHJlc3VsdCA9IE5vbmUKICAgICAgICBtZW1iZXJzID0gc2VsZi5tZW1iZXJzCiAgICAgICAgaWYgbGVuKG5hbWUpID4gNSBhbmQgbmFtZVstNV0gPT0gJyMnOgogICAgICAgICAgICAjIFRoZSA1IGxlbmd0aCBpcyBjaGVja2luZyB0byBzZWUgaWYgIzAwMDAgaXMgaW4gdGhlIHN0cmluZywKICAgICAgICAgICAgIyBhcyBhIzAwMDAgaGFzIGEgbGVuZ3RoIG9mIDYsIHRoZSBtaW5pbXVtIGZvciBhIHBvdGVudGlhbAogICAgICAgICAgICAjIGRpc2NyaW1pbmF0b3IgbG9va3VwLgogICAgICAgICAgICBwb3RlbnRpYWxfZGlzY3JpbWluYXRvciA9IG5hbWVbLTQ6XQoKICAgICAgICAgICAgIyBkbyB0aGUgYWN0dWFsIGxvb2t1cCBhbmQgcmV0dXJuIGlmIGZvdW5kCiAgICAgICAgICAgICMgaWYgaXQgaXNuJ3QgZm91bmQgdGhlbiB3ZSdsbCBkbyBhIGZ1bGwgbmFtZSBsb29rdXAgYmVsb3cuCiAgICAgICAgICAgIHJlc3VsdCA9IHV0aWxzLmdldChtZW1iZXJzLCBuYW1lPW5hbWVbOi01XSwgZGlzY3JpbWluYXRvcj1wb3RlbnRpYWxfZGlzY3JpbWluYXRvcikKICAgICAgICAgICAgaWYgcmVzdWx0IGlzIG5vdCBOb25lOgogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdAoKICAgICAgICBkZWYgcHJlZChtKToKICAgICAgICAgICAgcmV0dXJuIG0ubmljayA9PSBuYW1lIG9yIG0ubmFtZSA9PSBuYW1lCgogICAgICAgIHJldHVybiB1dGlscy5maW5kKHByZWQsIG1lbWJlcnMpCgogICAgZGVmIF9jcmVhdGVfY2hhbm5lbChzZWxmLCBuYW1lLCBvdmVyd3JpdGVzLCBjaGFubmVsX3R5cGUsIGNhdGVnb3J5PU5vbmUsICoqb3B0aW9ucyk6CiAgICAgICAgaWYgb3ZlcndyaXRlcyBpcyBOb25lOgogICAgICAgICAgICBvdmVyd3JpdGVzID0ge30KICAgICAgICBlbGlmIG5vdCBpc2luc3RhbmNlKG92ZXJ3cml0ZXMsIGRpY3QpOgogICAgICAgICAgICByYWlzZSBJbnZhbGlkQXJndW1lbnQoJ292ZXJ3cml0ZXMgcGFyYW1ldGVyIGV4cGVjdHMgYSBkaWN0LicpCgogICAgICAgIHBlcm1zID0gW10KICAgICAgICBmb3IgdGFyZ2V0LCBwZXJtIGluIG92ZXJ3cml0ZXMuaXRlbXMoKToKICAgICAgICAgICAgaWYgbm90IGlzaW5zdGFuY2UocGVybSwgUGVybWlzc2lvbk92ZXJ3cml0ZSk6CiAgICAgICAgICAgICAgICByYWlzZSBJbnZhbGlkQXJndW1lbnQoJ0V4cGVjdGVkIFBlcm1pc3Npb25PdmVyd3JpdGUgcmVjZWl2ZWQgezAuX19uYW1lX199Jy5mb3JtYXQodHlwZShwZXJtKSkpCgogICAgICAgICAgICBhbGxvdywgZGVueSA9IHBlcm0ucGFpcigpCiAgICAgICAgICAgIHBheWxvYWQgPSB7CiAgICAgICAgICAgICAgICAnYWxsb3cnOiBhbGxvdy52YWx1ZSwKICAgICAgICAgICAgICAgICdkZW55JzogZGVueS52YWx1ZSwKICAgICAgICAgICAgICAgICdpZCc6IHRhcmdldC5pZAogICAgICAgICAgICB9CgogICAgICAgICAgICBpZiBpc2luc3RhbmNlKHRhcmdldCwgUm9sZSk6CiAgICAgICAgICAgICAgICBwYXlsb2FkWyd0eXBlJ10gPSAncm9sZScKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIHBheWxvYWRbJ3R5cGUnXSA9ICdtZW1iZXInCgogICAgICAgICAgICBwZXJtcy5hcHBlbmQocGF5bG9hZCkKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBvcHRpb25zWydyYXRlX2xpbWl0X3Blcl91c2VyJ10gPSBvcHRpb25zLnBvcCgnc2xvd21vZGVfZGVsYXknKQogICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgcGFzcwoKICAgICAgICB0cnk6CiAgICAgICAgICAgIHJ0Y19yZWdpb24gPSBvcHRpb25zLnBvcCgncnRjX3JlZ2lvbicpCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgb3B0aW9uc1sncnRjX3JlZ2lvbiddID0gTm9uZSBpZiBydGNfcmVnaW9uIGlzIE5vbmUgZWxzZSBzdHIocnRjX3JlZ2lvbikKCiAgICAgICAgcGFyZW50X2lkID0gY2F0ZWdvcnkuaWQgaWYgY2F0ZWdvcnkgZWxzZSBOb25lCiAgICAgICAgcmV0dXJuIHNlbGYuX3N0YXRlLmh0dHAuY3JlYXRlX2NoYW5uZWwoc2VsZi5pZCwgY2hhbm5lbF90eXBlLnZhbHVlLCBuYW1lPW5hbWUsIHBhcmVudF9pZD1wYXJlbnRfaWQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbl9vdmVyd3JpdGVzPXBlcm1zLCAqKm9wdGlvbnMpCgogICAgYXN5bmMgZGVmIGNyZWF0ZV90ZXh0X2NoYW5uZWwoc2VsZiwgbmFtZSwgKiwgb3ZlcndyaXRlcz1Ob25lLCBjYXRlZ29yeT1Ob25lLCByZWFzb249Tm9uZSwgKipvcHRpb25zKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgQ3JlYXRlcyBhIDpjbGFzczpgVGV4dENoYW5uZWxgIGZvciB0aGUgZ3VpbGQuCgogICAgICAgIE5vdGUgdGhhdCB5b3UgbmVlZCB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5tYW5hZ2VfY2hhbm5lbHNgIHBlcm1pc3Npb24KICAgICAgICB0byBjcmVhdGUgdGhlIGNoYW5uZWwuCgogICAgICAgIFRoZSBgYG92ZXJ3cml0ZXNgYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgJ3NlY3JldCcKICAgICAgICBjaGFubmVsIHVwb24gY3JlYXRpb24uIFRoaXMgcGFyYW1ldGVyIGV4cGVjdHMgYSA6Y2xhc3M6YGRpY3RgIG9mCiAgICAgICAgb3ZlcndyaXRlcyB3aXRoIHRoZSB0YXJnZXQgKGVpdGhlciBhIDpjbGFzczpgTWVtYmVyYCBvciBhIDpjbGFzczpgUm9sZWApCiAgICAgICAgYXMgdGhlIGtleSBhbmQgYSA6Y2xhc3M6YFBlcm1pc3Npb25PdmVyd3JpdGVgIGFzIHRoZSB2YWx1ZS4KCiAgICAgICAgLi4gbm90ZTo6CgogICAgICAgICAgICBDcmVhdGluZyBhIGNoYW5uZWwgb2YgYSBzcGVjaWZpZWQgcG9zaXRpb24gd2lsbCBub3QgdXBkYXRlIHRoZSBwb3NpdGlvbiBvZgogICAgICAgICAgICBvdGhlciBjaGFubmVscyB0byBmb2xsb3cgc3VpdC4gQSBmb2xsb3ctdXAgY2FsbCB0byA6bWV0aDpgflRleHRDaGFubmVsLmVkaXRgCiAgICAgICAgICAgIHdpbGwgYmUgcmVxdWlyZWQgdG8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2hhbm5lbCBpbiB0aGUgY2hhbm5lbCBsaXN0LgoKICAgICAgICBFeGFtcGxlcwogICAgICAgIC0tLS0tLS0tLS0KCiAgICAgICAgQ3JlYXRpbmcgYSBiYXNpYyBjaGFubmVsOgoKICAgICAgICAuLiBjb2RlLWJsb2NrOjogcHl0aG9uMwoKICAgICAgICAgICAgY2hhbm5lbCA9IGF3YWl0IGd1aWxkLmNyZWF0ZV90ZXh0X2NoYW5uZWwoJ2Nvb2wtY2hhbm5lbCcpCgogICAgICAgIENyZWF0aW5nIGEgInNlY3JldCIgY2hhbm5lbDoKCiAgICAgICAgLi4gY29kZS1ibG9jazo6IHB5dGhvbjMKCiAgICAgICAgICAgIG92ZXJ3cml0ZXMgPSB7CiAgICAgICAgICAgICAgICBndWlsZC5kZWZhdWx0X3JvbGU6IGRpc2NvcmQuUGVybWlzc2lvbk92ZXJ3cml0ZShyZWFkX21lc3NhZ2VzPUZhbHNlKSwKICAgICAgICAgICAgICAgIGd1aWxkLm1lOiBkaXNjb3JkLlBlcm1pc3Npb25PdmVyd3JpdGUocmVhZF9tZXNzYWdlcz1UcnVlKQogICAgICAgICAgICB9CgogICAgICAgICAgICBjaGFubmVsID0gYXdhaXQgZ3VpbGQuY3JlYXRlX3RleHRfY2hhbm5lbCgnc2VjcmV0Jywgb3ZlcndyaXRlcz1vdmVyd3JpdGVzKQoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBuYW1lOiA6Y2xhc3M6YHN0cmAKICAgICAgICAgICAgVGhlIGNoYW5uZWwncyBuYW1lLgogICAgICAgIG92ZXJ3cml0ZXMKICAgICAgICAgICAgQSA6Y2xhc3M6YGRpY3RgIG9mIHRhcmdldCAoZWl0aGVyIGEgcm9sZSBvciBhIG1lbWJlcikgdG8KICAgICAgICAgICAgOmNsYXNzOmBQZXJtaXNzaW9uT3ZlcndyaXRlYCB0byBhcHBseSB1cG9uIGNyZWF0aW9uIG9mIGEgY2hhbm5lbC4KICAgICAgICAgICAgVXNlZnVsIGZvciBjcmVhdGluZyBzZWNyZXQgY2hhbm5lbHMuCiAgICAgICAgY2F0ZWdvcnk6IE9wdGlvbmFsWzpjbGFzczpgQ2F0ZWdvcnlDaGFubmVsYF0KICAgICAgICAgICAgVGhlIGNhdGVnb3J5IHRvIHBsYWNlIHRoZSBuZXdseSBjcmVhdGVkIGNoYW5uZWwgdW5kZXIuCiAgICAgICAgICAgIFRoZSBwZXJtaXNzaW9ucyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc3luY2VkIHRvIGNhdGVnb3J5IGlmIG5vCiAgICAgICAgICAgIG92ZXJ3cml0ZXMgYXJlIHByb3ZpZGVkLgogICAgICAgIHBvc2l0aW9uOiA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIHBvc2l0aW9uIGluIHRoZSBjaGFubmVsIGxpc3QuIFRoaXMgaXMgYSBudW1iZXIgdGhhdCBzdGFydHMKICAgICAgICAgICAgYXQgMC4gZS5nLiB0aGUgdG9wIGNoYW5uZWwgaXMgcG9zaXRpb24gMC4KICAgICAgICB0b3BpYzogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgICAgICBUaGUgbmV3IGNoYW5uZWwncyB0b3BpYy4KICAgICAgICBzbG93bW9kZV9kZWxheTogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFNwZWNpZmllcyB0aGUgc2xvd21vZGUgcmF0ZSBsaW1pdCBmb3IgdXNlciBpbiB0aGlzIGNoYW5uZWwsIGluIHNlY29uZHMuCiAgICAgICAgICAgIFRoZSBtYXhpbXVtIHZhbHVlIHBvc3NpYmxlIGlzIGAyMTYwMGAuCiAgICAgICAgbnNmdzogOmNsYXNzOmBib29sYAogICAgICAgICAgICBUbyBtYXJrIHRoZSBjaGFubmVsIGFzIE5TRlcgb3Igbm90LgogICAgICAgIHJlYXNvbjogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgICAgICBUaGUgcmVhc29uIGZvciBjcmVhdGluZyB0aGlzIGNoYW5uZWwuIFNob3dzIHVwIG9uIHRoZSBhdWRpdCBsb2cuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHRoZSBwcm9wZXIgcGVybWlzc2lvbnMgdG8gY3JlYXRlIHRoaXMgY2hhbm5lbC4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIENyZWF0aW5nIHRoZSBjaGFubmVsIGZhaWxlZC4KICAgICAgICBJbnZhbGlkQXJndW1lbnQKICAgICAgICAgICAgVGhlIHBlcm1pc3Npb24gb3ZlcndyaXRlIGluZm9ybWF0aW9uIGlzIG5vdCBpbiBwcm9wZXIgZm9ybS4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0KICAgICAgICA6Y2xhc3M6YFRleHRDaGFubmVsYAogICAgICAgICAgICBUaGUgY2hhbm5lbCB0aGF0IHdhcyBqdXN0IGNyZWF0ZWQuCiAgICAgICAgIiIiCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX2NyZWF0ZV9jaGFubmVsKG5hbWUsIG92ZXJ3cml0ZXMsIENoYW5uZWxUeXBlLnRleHQsIGNhdGVnb3J5LCByZWFzb249cmVhc29uLCAqKm9wdGlvbnMpCiAgICAgICAgY2hhbm5lbCA9IFRleHRDaGFubmVsKHN0YXRlPXNlbGYuX3N0YXRlLCBndWlsZD1zZWxmLCBkYXRhPWRhdGEpCgogICAgICAgICMgdGVtcG9yYXJpbHkgYWRkIHRvIHRoZSBjYWNoZQogICAgICAgIHNlbGYuX2NoYW5uZWxzW2NoYW5uZWwuaWRdID0gY2hhbm5lbAogICAgICAgIHJldHVybiBjaGFubmVsCgogICAgYXN5bmMgZGVmIGNyZWF0ZV92b2ljZV9jaGFubmVsKHNlbGYsIG5hbWUsICosIG92ZXJ3cml0ZXM9Tm9uZSwgY2F0ZWdvcnk9Tm9uZSwgcmVhc29uPU5vbmUsICoqb3B0aW9ucyk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFRoaXMgaXMgc2ltaWxhciB0byA6bWV0aDpgY3JlYXRlX3RleHRfY2hhbm5lbGAgZXhjZXB0IG1ha2VzIGEgOmNsYXNzOmBWb2ljZUNoYW5uZWxgIGluc3RlYWQsIGluIGFkZGl0aW9uCiAgICAgICAgdG8gaGF2aW5nIHRoZSBmb2xsb3dpbmcgbmV3IHBhcmFtZXRlcnMuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIGJpdHJhdGU6IDpjbGFzczpgaW50YAogICAgICAgICAgICBUaGUgY2hhbm5lbCdzIHByZWZlcnJlZCBhdWRpbyBiaXRyYXRlIGluIGJpdHMgcGVyIHNlY29uZC4KICAgICAgICB1c2VyX2xpbWl0OiA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIGNoYW5uZWwncyBsaW1pdCBmb3IgbnVtYmVyIG9mIG1lbWJlcnMgdGhhdCBjYW4gYmUgaW4gYSB2b2ljZSBjaGFubmVsLgogICAgICAgIHJ0Y19yZWdpb246IE9wdGlvbmFsWzpjbGFzczpgVm9pY2VSZWdpb25gXQogICAgICAgICAgICBUaGUgcmVnaW9uIGZvciB0aGUgdm9pY2UgY2hhbm5lbCdzIHZvaWNlIGNvbW11bmljYXRpb24uCiAgICAgICAgICAgIEEgdmFsdWUgb2YgYGBOb25lYGAgaW5kaWNhdGVzIGF1dG9tYXRpYyB2b2ljZSByZWdpb24gZGV0ZWN0aW9uLgoKICAgICAgICAgICAgLi4gdmVyc2lvbmFkZGVkOjogMS43CgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgZG8gbm90IGhhdmUgdGhlIHByb3BlciBwZXJtaXNzaW9ucyB0byBjcmVhdGUgdGhpcyBjaGFubmVsLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgQ3JlYXRpbmcgdGhlIGNoYW5uZWwgZmFpbGVkLgogICAgICAgIEludmFsaWRBcmd1bWVudAogICAgICAgICAgICBUaGUgcGVybWlzc2lvbiBvdmVyd3JpdGUgaW5mb3JtYXRpb24gaXMgbm90IGluIHByb3BlciBmb3JtLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLQogICAgICAgIDpjbGFzczpgVm9pY2VDaGFubmVsYAogICAgICAgICAgICBUaGUgY2hhbm5lbCB0aGF0IHdhcyBqdXN0IGNyZWF0ZWQuCiAgICAgICAgIiIiCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX2NyZWF0ZV9jaGFubmVsKG5hbWUsIG92ZXJ3cml0ZXMsIENoYW5uZWxUeXBlLnZvaWNlLCBjYXRlZ29yeSwgcmVhc29uPXJlYXNvbiwgKipvcHRpb25zKQogICAgICAgIGNoYW5uZWwgPSBWb2ljZUNoYW5uZWwoc3RhdGU9c2VsZi5fc3RhdGUsIGd1aWxkPXNlbGYsIGRhdGE9ZGF0YSkKCiAgICAgICAgIyB0ZW1wb3JhcmlseSBhZGQgdG8gdGhlIGNhY2hlCiAgICAgICAgc2VsZi5fY2hhbm5lbHNbY2hhbm5lbC5pZF0gPSBjaGFubmVsCiAgICAgICAgcmV0dXJuIGNoYW5uZWwKCiAgICBhc3luYyBkZWYgY3JlYXRlX3N0YWdlX2NoYW5uZWwoc2VsZiwgbmFtZSwgKiwgdG9waWM9Tm9uZSwgY2F0ZWdvcnk9Tm9uZSwgb3ZlcndyaXRlcz1Ob25lLCByZWFzb249Tm9uZSwgcG9zaXRpb249Tm9uZSk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFRoaXMgaXMgc2ltaWxhciB0byA6bWV0aDpgY3JlYXRlX3RleHRfY2hhbm5lbGAgZXhjZXB0IG1ha2VzIGEgOmNsYXNzOmBTdGFnZUNoYW5uZWxgIGluc3RlYWQuCgogICAgICAgIC4uIG5vdGU6OgoKICAgICAgICAgICAgVGhlIGBgc2xvd21vZGVfZGVsYXlgYCBhbmQgYGBuc2Z3YGAgcGFyYW1ldGVycyBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGZ1bmN0aW9uLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjcKCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSB0aGUgcHJvcGVyIHBlcm1pc3Npb25zIHRvIGNyZWF0ZSB0aGlzIGNoYW5uZWwuCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBDcmVhdGluZyB0aGUgY2hhbm5lbCBmYWlsZWQuCiAgICAgICAgSW52YWxpZEFyZ3VtZW50CiAgICAgICAgICAgIFRoZSBwZXJtaXNzaW9uIG92ZXJ3cml0ZSBpbmZvcm1hdGlvbiBpcyBub3QgaW4gcHJvcGVyIGZvcm0uCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tCiAgICAgICAgOmNsYXNzOmBTdGFnZUNoYW5uZWxgCiAgICAgICAgICAgIFRoZSBjaGFubmVsIHRoYXQgd2FzIGp1c3QgY3JlYXRlZC4KICAgICAgICAiIiIKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fY3JlYXRlX2NoYW5uZWwobmFtZSwgb3ZlcndyaXRlcywgQ2hhbm5lbFR5cGUuc3RhZ2Vfdm9pY2UsIGNhdGVnb3J5LCByZWFzb249cmVhc29uLCBwb3NpdGlvbj1wb3NpdGlvbiwgdG9waWM9dG9waWMpCiAgICAgICAgY2hhbm5lbCA9IFN0YWdlQ2hhbm5lbChzdGF0ZT1zZWxmLl9zdGF0ZSwgZ3VpbGQ9c2VsZiwgZGF0YT1kYXRhKQoKICAgICAgICAjIHRlbXBvcmFyaWx5IGFkZCB0byB0aGUgY2FjaGUKICAgICAgICBzZWxmLl9jaGFubmVsc1tjaGFubmVsLmlkXSA9IGNoYW5uZWwKICAgICAgICByZXR1cm4gY2hhbm5lbAoKICAgIGFzeW5jIGRlZiBjcmVhdGVfY2F0ZWdvcnkoc2VsZiwgbmFtZSwgKiwgb3ZlcndyaXRlcz1Ob25lLCByZWFzb249Tm9uZSwgcG9zaXRpb249Tm9uZSk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFNhbWUgYXMgOm1ldGg6YGNyZWF0ZV90ZXh0X2NoYW5uZWxgIGV4Y2VwdCBtYWtlcyBhIDpjbGFzczpgQ2F0ZWdvcnlDaGFubmVsYCBpbnN0ZWFkLgoKICAgICAgICAuLiBub3RlOjoKCiAgICAgICAgICAgIFRoZSBgYGNhdGVnb3J5YGAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBmdW5jdGlvbiBzaW5jZSBjYXRlZ29yaWVzCiAgICAgICAgICAgIGNhbm5vdCBoYXZlIGNhdGVnb3JpZXMuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgZG8gbm90IGhhdmUgdGhlIHByb3BlciBwZXJtaXNzaW9ucyB0byBjcmVhdGUgdGhpcyBjaGFubmVsLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgQ3JlYXRpbmcgdGhlIGNoYW5uZWwgZmFpbGVkLgogICAgICAgIEludmFsaWRBcmd1bWVudAogICAgICAgICAgICBUaGUgcGVybWlzc2lvbiBvdmVyd3JpdGUgaW5mb3JtYXRpb24gaXMgbm90IGluIHByb3BlciBmb3JtLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLQogICAgICAgIDpjbGFzczpgQ2F0ZWdvcnlDaGFubmVsYAogICAgICAgICAgICBUaGUgY2hhbm5lbCB0aGF0IHdhcyBqdXN0IGNyZWF0ZWQuCiAgICAgICAgIiIiCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX2NyZWF0ZV9jaGFubmVsKG5hbWUsIG92ZXJ3cml0ZXMsIENoYW5uZWxUeXBlLmNhdGVnb3J5LCByZWFzb249cmVhc29uLCBwb3NpdGlvbj1wb3NpdGlvbikKICAgICAgICBjaGFubmVsID0gQ2F0ZWdvcnlDaGFubmVsKHN0YXRlPXNlbGYuX3N0YXRlLCBndWlsZD1zZWxmLCBkYXRhPWRhdGEpCgogICAgICAgICMgdGVtcG9yYXJpbHkgYWRkIHRvIHRoZSBjYWNoZQogICAgICAgIHNlbGYuX2NoYW5uZWxzW2NoYW5uZWwuaWRdID0gY2hhbm5lbAogICAgICAgIHJldHVybiBjaGFubmVsCgogICAgY3JlYXRlX2NhdGVnb3J5X2NoYW5uZWwgPSBjcmVhdGVfY2F0ZWdvcnkKCiAgICBhc3luYyBkZWYgbGVhdmUoc2VsZik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIExlYXZlcyB0aGUgZ3VpbGQuCgogICAgICAgIC4uIG5vdGU6OgoKICAgICAgICAgICAgWW91IGNhbm5vdCBsZWF2ZSB0aGUgZ3VpbGQgdGhhdCB5b3Ugb3duLCB5b3UgbXVzdCBkZWxldGUgaXQgaW5zdGVhZAogICAgICAgICAgICB2aWEgOm1ldGg6YGRlbGV0ZWAuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBMZWF2aW5nIHRoZSBndWlsZCBmYWlsZWQuCiAgICAgICAgIiIiCiAgICAgICAgYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5sZWF2ZV9ndWlsZChzZWxmLmlkKQoKICAgIGFzeW5jIGRlZiBkZWxldGUoc2VsZik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIERlbGV0ZXMgdGhlIGd1aWxkLiBZb3UgbXVzdCBiZSB0aGUgZ3VpbGQgb3duZXIgdG8gZGVsZXRlIHRoZQogICAgICAgIGd1aWxkLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tLQogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgRGVsZXRpbmcgdGhlIGd1aWxkIGZhaWxlZC4KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb25zIHRvIGRlbGV0ZSB0aGUgZ3VpbGQuCiAgICAgICAgIiIiCgogICAgICAgIGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuZGVsZXRlX2d1aWxkKHNlbGYuaWQpCgogICAgYXN5bmMgZGVmIGVkaXQoc2VsZiwgKiwgcmVhc29uPU5vbmUsICoqZmllbGRzKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgRWRpdHMgdGhlIGd1aWxkLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLm1hbmFnZV9ndWlsZGAgcGVybWlzc2lvbgogICAgICAgIHRvIGVkaXQgdGhlIGd1aWxkLgoKICAgICAgICAuLiB2ZXJzaW9uY2hhbmdlZDo6IDEuNAogICAgICAgICAgICBUaGUgYHJ1bGVzX2NoYW5uZWxgIGFuZCBgcHVibGljX3VwZGF0ZXNfY2hhbm5lbGAga2V5d29yZC1vbmx5IHBhcmFtZXRlcnMgd2VyZSBhZGRlZC4KCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0KICAgICAgICBuYW1lOiA6Y2xhc3M6YHN0cmAKICAgICAgICAgICAgVGhlIG5ldyBuYW1lIG9mIHRoZSBndWlsZC4KICAgICAgICBkZXNjcmlwdGlvbjogOmNsYXNzOmBzdHJgCiAgICAgICAgICAgIFRoZSBuZXcgZGVzY3JpcHRpb24gb2YgdGhlIGd1aWxkLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHRvIGd1aWxkcyB0aGF0CiAgICAgICAgICAgIGNvbnRhaW4gYGBQVUJMSUNgYCBpbiA6YXR0cjpgR3VpbGQuZmVhdHVyZXNgLgogICAgICAgIGljb246IDpjbGFzczpgYnl0ZXNgCiAgICAgICAgICAgIEEgOnRlcm06YHB5OmJ5dGVzLWxpa2Ugb2JqZWN0YCByZXByZXNlbnRpbmcgdGhlIGljb24uIE9ubHkgUE5HL0pQRUcgaXMgc3VwcG9ydGVkLgogICAgICAgICAgICBHSUYgaXMgb25seSBhdmFpbGFibGUgdG8gZ3VpbGRzIHRoYXQgY29udGFpbiBgYEFOSU1BVEVEX0lDT05gYCBpbiA6YXR0cjpgR3VpbGQuZmVhdHVyZXNgLgogICAgICAgICAgICBDb3VsZCBiZSBgYE5vbmVgYCB0byBkZW5vdGUgcmVtb3ZhbCBvZiB0aGUgaWNvbi4KICAgICAgICBiYW5uZXI6IDpjbGFzczpgYnl0ZXNgCiAgICAgICAgICAgIEEgOnRlcm06YHB5OmJ5dGVzLWxpa2Ugb2JqZWN0YCByZXByZXNlbnRpbmcgdGhlIGJhbm5lci4KICAgICAgICAgICAgQ291bGQgYmUgYGBOb25lYGAgdG8gZGVub3RlIHJlbW92YWwgb2YgdGhlIGJhbm5lci4KICAgICAgICBzcGxhc2g6IDpjbGFzczpgYnl0ZXNgCiAgICAgICAgICAgIEEgOnRlcm06YHB5OmJ5dGVzLWxpa2Ugb2JqZWN0YCByZXByZXNlbnRpbmcgdGhlIGludml0ZSBzcGxhc2guCiAgICAgICAgICAgIE9ubHkgUE5HL0pQRUcgc3VwcG9ydGVkLiBDb3VsZCBiZSBgYE5vbmVgYCB0byBkZW5vdGUgcmVtb3ZpbmcgdGhlCiAgICAgICAgICAgIHNwbGFzaC4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB0byBndWlsZHMgdGhhdCBjb250YWluIGBgSU5WSVRFX1NQTEFTSGBgCiAgICAgICAgICAgIGluIDphdHRyOmBHdWlsZC5mZWF0dXJlc2AuCiAgICAgICAgcmVnaW9uOiA6Y2xhc3M6YFZvaWNlUmVnaW9uYAogICAgICAgICAgICBUaGUgbmV3IHJlZ2lvbiBmb3IgdGhlIGd1aWxkJ3Mgdm9pY2UgY29tbXVuaWNhdGlvbi4KICAgICAgICBhZmtfY2hhbm5lbDogT3B0aW9uYWxbOmNsYXNzOmBWb2ljZUNoYW5uZWxgXQogICAgICAgICAgICBUaGUgbmV3IGNoYW5uZWwgdGhhdCBpcyB0aGUgQUZLIGNoYW5uZWwuIENvdWxkIGJlIGBgTm9uZWBgIGZvciBubyBBRksgY2hhbm5lbC4KICAgICAgICBhZmtfdGltZW91dDogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCBzb21lb25lIGlzIG1vdmVkIHRvIHRoZSBBRksgY2hhbm5lbC4KICAgICAgICBvd25lcjogOmNsYXNzOmBNZW1iZXJgCiAgICAgICAgICAgIFRoZSBuZXcgb3duZXIgb2YgdGhlIGd1aWxkIHRvIHRyYW5zZmVyIG93bmVyc2hpcCB0by4gTm90ZSB0aGF0IHlvdSBtdXN0CiAgICAgICAgICAgIGJlIG93bmVyIG9mIHRoZSBndWlsZCB0byBkbyB0aGlzLgogICAgICAgIHZlcmlmaWNhdGlvbl9sZXZlbDogOmNsYXNzOmBWZXJpZmljYXRpb25MZXZlbGAKICAgICAgICAgICAgVGhlIG5ldyB2ZXJpZmljYXRpb24gbGV2ZWwgZm9yIHRoZSBndWlsZC4KICAgICAgICBkZWZhdWx0X25vdGlmaWNhdGlvbnM6IDpjbGFzczpgTm90aWZpY2F0aW9uTGV2ZWxgCiAgICAgICAgICAgIFRoZSBuZXcgZGVmYXVsdCBub3RpZmljYXRpb24gbGV2ZWwgZm9yIHRoZSBndWlsZC4KICAgICAgICBleHBsaWNpdF9jb250ZW50X2ZpbHRlcjogOmNsYXNzOmBDb250ZW50RmlsdGVyYAogICAgICAgICAgICBUaGUgbmV3IGV4cGxpY2l0IGNvbnRlbnQgZmlsdGVyIGZvciB0aGUgZ3VpbGQuCiAgICAgICAgdmFuaXR5X2NvZGU6IDpjbGFzczpgc3RyYAogICAgICAgICAgICBUaGUgbmV3IHZhbml0eSBjb2RlIGZvciB0aGUgZ3VpbGQuCiAgICAgICAgc3lzdGVtX2NoYW5uZWw6IE9wdGlvbmFsWzpjbGFzczpgVGV4dENoYW5uZWxgXQogICAgICAgICAgICBUaGUgbmV3IGNoYW5uZWwgdGhhdCBpcyB1c2VkIGZvciB0aGUgc3lzdGVtIGNoYW5uZWwuIENvdWxkIGJlIGBgTm9uZWBgIGZvciBubyBzeXN0ZW0gY2hhbm5lbC4KICAgICAgICBzeXN0ZW1fY2hhbm5lbF9mbGFnczogOmNsYXNzOmBTeXN0ZW1DaGFubmVsRmxhZ3NgCiAgICAgICAgICAgIFRoZSBuZXcgc3lzdGVtIGNoYW5uZWwgc2V0dGluZ3MgdG8gdXNlIHdpdGggdGhlIG5ldyBzeXN0ZW0gY2hhbm5lbC4KICAgICAgICBwcmVmZXJyZWRfbG9jYWxlOiA6Y2xhc3M6YHN0cmAKICAgICAgICAgICAgVGhlIG5ldyBwcmVmZXJyZWQgbG9jYWxlIGZvciB0aGUgZ3VpbGQuIFVzZWQgYXMgdGhlIHByaW1hcnkgbGFuZ3VhZ2UgaW4gdGhlIGd1aWxkLgogICAgICAgICAgICBJZiBzZXQsIHRoaXMgbXVzdCBiZSBhbiBJU08gNjM5IGNvZGUsIGUuZy4gYGBlbi1VU2BgIG9yIGBgamFgYCBvciBgYHpoLUNOYGAuCiAgICAgICAgcnVsZXNfY2hhbm5lbDogT3B0aW9uYWxbOmNsYXNzOmBUZXh0Q2hhbm5lbGBdCiAgICAgICAgICAgIFRoZSBuZXcgY2hhbm5lbCB0aGF0IGlzIHVzZWQgZm9yIHJ1bGVzLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHRvCiAgICAgICAgICAgIGd1aWxkcyB0aGF0IGNvbnRhaW4gYGBQVUJMSUNgYCBpbiA6YXR0cjpgR3VpbGQuZmVhdHVyZXNgLiBDb3VsZCBiZSBgYE5vbmVgYCBmb3Igbm8gcnVsZXMKICAgICAgICAgICAgY2hhbm5lbC4KICAgICAgICBwdWJsaWNfdXBkYXRlc19jaGFubmVsOiBPcHRpb25hbFs6Y2xhc3M6YFRleHRDaGFubmVsYF0KICAgICAgICAgICAgVGhlIG5ldyBjaGFubmVsIHRoYXQgaXMgdXNlZCBmb3IgcHVibGljIHVwZGF0ZXMgZnJvbSBEaXNjb3JkLiBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIHRvCiAgICAgICAgICAgIGd1aWxkcyB0aGF0IGNvbnRhaW4gYGBQVUJMSUNgYCBpbiA6YXR0cjpgR3VpbGQuZmVhdHVyZXNgLiBDb3VsZCBiZSBgYE5vbmVgYCBmb3Igbm8KICAgICAgICAgICAgcHVibGljIHVwZGF0ZXMgY2hhbm5lbC4KICAgICAgICByZWFzb246IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIHJlYXNvbiBmb3IgZWRpdGluZyB0aGlzIGd1aWxkLiBTaG93cyB1cCBvbiB0aGUgYXVkaXQgbG9nLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9ucyB0byBlZGl0IHRoZSBndWlsZC4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEVkaXRpbmcgdGhlIGd1aWxkIGZhaWxlZC4KICAgICAgICBJbnZhbGlkQXJndW1lbnQKICAgICAgICAgICAgVGhlIGltYWdlIGZvcm1hdCBwYXNzZWQgaW4gdG8gYGBpY29uYGAgaXMgaW52YWxpZC4gSXQgbXVzdCBiZQogICAgICAgICAgICBQTkcgb3IgSlBHLiBUaGlzIGlzIGFsc28gcmFpc2VkIGlmIHlvdSBhcmUgbm90IHRoZSBvd25lciBvZiB0aGUKICAgICAgICAgICAgZ3VpbGQgYW5kIHJlcXVlc3QgYW4gb3duZXJzaGlwIHRyYW5zZmVyLgogICAgICAgICIiIgoKICAgICAgICBodHRwID0gc2VsZi5fc3RhdGUuaHR0cAogICAgICAgIHRyeToKICAgICAgICAgICAgaWNvbl9ieXRlcyA9IGZpZWxkc1snaWNvbiddCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBpY29uID0gc2VsZi5pY29uCiAgICAgICAgZWxzZToKICAgICAgICAgICAgaWYgaWNvbl9ieXRlcyBpcyBub3QgTm9uZToKICAgICAgICAgICAgICAgIGljb24gPSB1dGlscy5fYnl0ZXNfdG9fYmFzZTY0X2RhdGEoaWNvbl9ieXRlcykKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGljb24gPSBOb25lCgogICAgICAgIHRyeToKICAgICAgICAgICAgYmFubmVyX2J5dGVzID0gZmllbGRzWydiYW5uZXInXQogICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgYmFubmVyID0gc2VsZi5iYW5uZXIKICAgICAgICBlbHNlOgogICAgICAgICAgICBpZiBiYW5uZXJfYnl0ZXMgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICBiYW5uZXIgPSB1dGlscy5fYnl0ZXNfdG9fYmFzZTY0X2RhdGEoYmFubmVyX2J5dGVzKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgYmFubmVyID0gTm9uZQoKICAgICAgICB0cnk6CiAgICAgICAgICAgIHZhbml0eV9jb2RlID0gZmllbGRzWyd2YW5pdHlfY29kZSddCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgYXdhaXQgaHR0cC5jaGFuZ2VfdmFuaXR5X2NvZGUoc2VsZi5pZCwgdmFuaXR5X2NvZGUsIHJlYXNvbj1yZWFzb24pCgogICAgICAgIHRyeToKICAgICAgICAgICAgc3BsYXNoX2J5dGVzID0gZmllbGRzWydzcGxhc2gnXQogICAgICAgIGV4Y2VwdCBLZXlFcnJvcjoKICAgICAgICAgICAgc3BsYXNoID0gc2VsZi5zcGxhc2gKICAgICAgICBlbHNlOgogICAgICAgICAgICBpZiBzcGxhc2hfYnl0ZXMgaXMgbm90IE5vbmU6CiAgICAgICAgICAgICAgICBzcGxhc2ggPSB1dGlscy5fYnl0ZXNfdG9fYmFzZTY0X2RhdGEoc3BsYXNoX2J5dGVzKQogICAgICAgICAgICBlbHNlOgogICAgICAgICAgICAgICAgc3BsYXNoID0gTm9uZQoKICAgICAgICBmaWVsZHNbJ2ljb24nXSA9IGljb24KICAgICAgICBmaWVsZHNbJ2Jhbm5lciddID0gYmFubmVyCiAgICAgICAgZmllbGRzWydzcGxhc2gnXSA9IHNwbGFzaAoKICAgICAgICBkZWZhdWx0X21lc3NhZ2Vfbm90aWZpY2F0aW9ucyA9IGZpZWxkcy5nZXQoJ2RlZmF1bHRfbm90aWZpY2F0aW9ucycsIHNlbGYuZGVmYXVsdF9ub3RpZmljYXRpb25zKQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRlZmF1bHRfbWVzc2FnZV9ub3RpZmljYXRpb25zLCBOb3RpZmljYXRpb25MZXZlbCk6CiAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgnZGVmYXVsdF9ub3RpZmljYXRpb25zIGZpZWxkIG11c3QgYmUgb2YgdHlwZSBOb3RpZmljYXRpb25MZXZlbCcpCiAgICAgICAgZmllbGRzWydkZWZhdWx0X21lc3NhZ2Vfbm90aWZpY2F0aW9ucyddID0gZGVmYXVsdF9tZXNzYWdlX25vdGlmaWNhdGlvbnMudmFsdWUKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBhZmtfY2hhbm5lbCA9IGZpZWxkcy5wb3AoJ2Fma19jaGFubmVsJykKICAgICAgICBleGNlcHQgS2V5RXJyb3I6CiAgICAgICAgICAgIHBhc3MKICAgICAgICBlbHNlOgogICAgICAgICAgICBpZiBhZmtfY2hhbm5lbCBpcyBOb25lOgogICAgICAgICAgICAgICAgZmllbGRzWydhZmtfY2hhbm5lbF9pZCddID0gYWZrX2NoYW5uZWwKICAgICAgICAgICAgZWxzZToKICAgICAgICAgICAgICAgIGZpZWxkc1snYWZrX2NoYW5uZWxfaWQnXSA9IGFma19jaGFubmVsLmlkCgogICAgICAgIHRyeToKICAgICAgICAgICAgc3lzdGVtX2NoYW5uZWwgPSBmaWVsZHMucG9wKCdzeXN0ZW1fY2hhbm5lbCcpCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgaWYgc3lzdGVtX2NoYW5uZWwgaXMgTm9uZToKICAgICAgICAgICAgICAgIGZpZWxkc1snc3lzdGVtX2NoYW5uZWxfaWQnXSA9IHN5c3RlbV9jaGFubmVsCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBmaWVsZHNbJ3N5c3RlbV9jaGFubmVsX2lkJ10gPSBzeXN0ZW1fY2hhbm5lbC5pZAoKICAgICAgICBpZiAnb3duZXInIGluIGZpZWxkczoKICAgICAgICAgICAgaWYgc2VsZi5vd25lcl9pZCAhPSBzZWxmLl9zdGF0ZS5zZWxmX2lkOgogICAgICAgICAgICAgICAgcmFpc2UgSW52YWxpZEFyZ3VtZW50KCdUbyB0cmFuc2ZlciBvd25lcnNoaXAgeW91IG11c3QgYmUgdGhlIG93bmVyIG9mIHRoZSBndWlsZC4nKQoKICAgICAgICAgICAgZmllbGRzWydvd25lcl9pZCddID0gZmllbGRzWydvd25lciddLmlkCgogICAgICAgIGlmICdyZWdpb24nIGluIGZpZWxkczoKICAgICAgICAgICAgZmllbGRzWydyZWdpb24nXSA9IHN0cihmaWVsZHNbJ3JlZ2lvbiddKQoKICAgICAgICBsZXZlbCA9IGZpZWxkcy5nZXQoJ3ZlcmlmaWNhdGlvbl9sZXZlbCcsIHNlbGYudmVyaWZpY2F0aW9uX2xldmVsKQogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGxldmVsLCBWZXJpZmljYXRpb25MZXZlbCk6CiAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgndmVyaWZpY2F0aW9uX2xldmVsIGZpZWxkIG11c3QgYmUgb2YgdHlwZSBWZXJpZmljYXRpb25MZXZlbCcpCgogICAgICAgIGZpZWxkc1sndmVyaWZpY2F0aW9uX2xldmVsJ10gPSBsZXZlbC52YWx1ZQoKICAgICAgICBleHBsaWNpdF9jb250ZW50X2ZpbHRlciA9IGZpZWxkcy5nZXQoJ2V4cGxpY2l0X2NvbnRlbnRfZmlsdGVyJywgc2VsZi5leHBsaWNpdF9jb250ZW50X2ZpbHRlcikKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShleHBsaWNpdF9jb250ZW50X2ZpbHRlciwgQ29udGVudEZpbHRlcik6CiAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgnZXhwbGljaXRfY29udGVudF9maWx0ZXIgZmllbGQgbXVzdCBiZSBvZiB0eXBlIENvbnRlbnRGaWx0ZXInKQoKICAgICAgICBmaWVsZHNbJ2V4cGxpY2l0X2NvbnRlbnRfZmlsdGVyJ10gPSBleHBsaWNpdF9jb250ZW50X2ZpbHRlci52YWx1ZQoKICAgICAgICBzeXN0ZW1fY2hhbm5lbF9mbGFncyA9IGZpZWxkcy5nZXQoJ3N5c3RlbV9jaGFubmVsX2ZsYWdzJywgc2VsZi5zeXN0ZW1fY2hhbm5lbF9mbGFncykKICAgICAgICBpZiBub3QgaXNpbnN0YW5jZShzeXN0ZW1fY2hhbm5lbF9mbGFncywgU3lzdGVtQ2hhbm5lbEZsYWdzKToKICAgICAgICAgICAgcmFpc2UgSW52YWxpZEFyZ3VtZW50KCdzeXN0ZW1fY2hhbm5lbF9mbGFncyBmaWVsZCBtdXN0IGJlIG9mIHR5cGUgU3lzdGVtQ2hhbm5lbEZsYWdzJykKCiAgICAgICAgZmllbGRzWydzeXN0ZW1fY2hhbm5lbF9mbGFncyddID0gc3lzdGVtX2NoYW5uZWxfZmxhZ3MudmFsdWUKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBydWxlc19jaGFubmVsID0gZmllbGRzLnBvcCgncnVsZXNfY2hhbm5lbCcpCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgaWYgcnVsZXNfY2hhbm5lbCBpcyBOb25lOgogICAgICAgICAgICAgICAgZmllbGRzWydydWxlc19jaGFubmVsX2lkJ10gPSBydWxlc19jaGFubmVsCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBmaWVsZHNbJ3J1bGVzX2NoYW5uZWxfaWQnXSA9IHJ1bGVzX2NoYW5uZWwuaWQKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBwdWJsaWNfdXBkYXRlc19jaGFubmVsID0gZmllbGRzLnBvcCgncHVibGljX3VwZGF0ZXNfY2hhbm5lbCcpCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBwYXNzCiAgICAgICAgZWxzZToKICAgICAgICAgICAgaWYgcHVibGljX3VwZGF0ZXNfY2hhbm5lbCBpcyBOb25lOgogICAgICAgICAgICAgICAgZmllbGRzWydwdWJsaWNfdXBkYXRlc19jaGFubmVsX2lkJ10gPSBwdWJsaWNfdXBkYXRlc19jaGFubmVsCiAgICAgICAgICAgIGVsc2U6CiAgICAgICAgICAgICAgICBmaWVsZHNbJ3B1YmxpY191cGRhdGVzX2NoYW5uZWxfaWQnXSA9IHB1YmxpY191cGRhdGVzX2NoYW5uZWwuaWQKICAgICAgICBhd2FpdCBodHRwLmVkaXRfZ3VpbGQoc2VsZi5pZCwgcmVhc29uPXJlYXNvbiwgKipmaWVsZHMpCgogICAgYXN5bmMgZGVmIGZldGNoX2NoYW5uZWxzKHNlbGYpOgogICAgICAgICIiInxjb3JvfAoKICAgICAgICBSZXRyaWV2ZXMgYWxsIDpjbGFzczpgYWJjLkd1aWxkQ2hhbm5lbGAgdGhhdCB0aGUgZ3VpbGQgaGFzLgoKICAgICAgICAuLiBub3RlOjoKCiAgICAgICAgICAgIFRoaXMgbWV0aG9kIGlzIGFuIEFQSSBjYWxsLiBGb3IgZ2VuZXJhbCB1c2FnZSwgY29uc2lkZXIgOmF0dHI6YGNoYW5uZWxzYCBpbnN0ZWFkLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjIKCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEludmFsaWREYXRhCiAgICAgICAgICAgIEFuIHVua25vd24gY2hhbm5lbCB0eXBlIHdhcyByZWNlaXZlZCBmcm9tIERpc2NvcmQuCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBSZXRyaWV2aW5nIHRoZSBjaGFubmVscyBmYWlsZWQuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tCiAgICAgICAgTGlzdFs6Y2xhc3M6YGFiYy5HdWlsZENoYW5uZWxgXQogICAgICAgICAgICBBbGwgY2hhbm5lbHMgaW4gdGhlIGd1aWxkLgogICAgICAgICIiIgogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmdldF9hbGxfZ3VpbGRfY2hhbm5lbHMoc2VsZi5pZCkKCiAgICAgICAgZGVmIGNvbnZlcnQoZCk6CiAgICAgICAgICAgIGZhY3RvcnksIGNoX3R5cGUgPSBfY2hhbm5lbF9mYWN0b3J5KGRbJ3R5cGUnXSkKICAgICAgICAgICAgaWYgZmFjdG9yeSBpcyBOb25lOgogICAgICAgICAgICAgICAgcmFpc2UgSW52YWxpZERhdGEoJ1Vua25vd24gY2hhbm5lbCB0eXBlIHt0eXBlfSBmb3IgY2hhbm5lbCBJRCB7aWR9LicuZm9ybWF0X21hcChkKSkKCiAgICAgICAgICAgIGNoYW5uZWwgPSBmYWN0b3J5KGd1aWxkPXNlbGYsIHN0YXRlPXNlbGYuX3N0YXRlLCBkYXRhPWQpCiAgICAgICAgICAgIHJldHVybiBjaGFubmVsCgogICAgICAgIHJldHVybiBbY29udmVydChkKSBmb3IgZCBpbiBkYXRhXQoKICAgIGRlZiBmZXRjaF9tZW1iZXJzKHNlbGYsICosIGxpbWl0PTEwMDAsIGFmdGVyPU5vbmUpOgogICAgICAgICIiIlJldHJpZXZlcyBhbiA6Y2xhc3M6YC5Bc3luY0l0ZXJhdG9yYCB0aGF0IGVuYWJsZXMgcmVjZWl2aW5nIHRoZSBndWlsZCdzIG1lbWJlcnMuIEluIG9yZGVyIHRvIHVzZSB0aGlzLAogICAgICAgIDptZXRoOmBJbnRlbnRzLm1lbWJlcnNgIG11c3QgYmUgZW5hYmxlZC4KCiAgICAgICAgLi4gbm90ZTo6CgogICAgICAgICAgICBUaGlzIG1ldGhvZCBpcyBhbiBBUEkgY2FsbC4gRm9yIGdlbmVyYWwgdXNhZ2UsIGNvbnNpZGVyIDphdHRyOmBtZW1iZXJzYCBpbnN0ZWFkLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjMKCiAgICAgICAgQWxsIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLQogICAgICAgIGxpbWl0OiBPcHRpb25hbFs6Y2xhc3M6YGludGBdCiAgICAgICAgICAgIFRoZSBudW1iZXIgb2YgbWVtYmVycyB0byByZXRyaWV2ZS4gRGVmYXVsdHMgdG8gMTAwMC4KICAgICAgICAgICAgUGFzcyBgYE5vbmVgYCB0byBmZXRjaCBhbGwgbWVtYmVycy4gTm90ZSB0aGF0IHRoaXMgaXMgcG90ZW50aWFsbHkgc2xvdy4KICAgICAgICBhZnRlcjogT3B0aW9uYWxbVW5pb25bOmNsYXNzOmAuYWJjLlNub3dmbGFrZWAsIDpjbGFzczpgZGF0ZXRpbWUuZGF0ZXRpbWVgXV0KICAgICAgICAgICAgUmV0cmlldmUgbWVtYmVycyBhZnRlciB0aGlzIGRhdGUgb3Igb2JqZWN0LgogICAgICAgICAgICBJZiBhIGRhdGUgaXMgcHJvdmlkZWQgaXQgbXVzdCBiZSBhIHRpbWV6b25lLW5haXZlIGRhdGV0aW1lIHJlcHJlc2VudGluZyBVVEMgdGltZS4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tCiAgICAgICAgQ2xpZW50RXhjZXB0aW9uCiAgICAgICAgICAgIFRoZSBtZW1iZXJzIGludGVudCBpcyBub3QgZW5hYmxlZC4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEdldHRpbmcgdGhlIG1lbWJlcnMgZmFpbGVkLgoKICAgICAgICBZaWVsZHMKICAgICAgICAtLS0tLS0KICAgICAgICA6Y2xhc3M6YC5NZW1iZXJgCiAgICAgICAgICAgIFRoZSBtZW1iZXIgd2l0aCB0aGUgbWVtYmVyIGRhdGEgcGFyc2VkLgoKICAgICAgICBFeGFtcGxlcwogICAgICAgIC0tLS0tLS0tCgogICAgICAgIFVzYWdlIDo6CgogICAgICAgICAgICBhc3luYyBmb3IgbWVtYmVyIGluIGd1aWxkLmZldGNoX21lbWJlcnMobGltaXQ9MTUwKToKICAgICAgICAgICAgICAgIHByaW50KG1lbWJlci5uYW1lKQoKICAgICAgICBGbGF0dGVuaW5nIGludG8gYSBsaXN0IDo6CgogICAgICAgICAgICBtZW1iZXJzID0gYXdhaXQgZ3VpbGQuZmV0Y2hfbWVtYmVycyhsaW1pdD0xNTApLmZsYXR0ZW4oKQogICAgICAgICAgICAjIG1lbWJlcnMgaXMgbm93IGEgbGlzdCBvZiBNZW1iZXIuLi4KICAgICAgICAiIiIKCiAgICAgICAgaWYgbm90IHNlbGYuX3N0YXRlLl9pbnRlbnRzLm1lbWJlcnM6CiAgICAgICAgICAgIHJhaXNlIENsaWVudEV4Y2VwdGlvbignSW50ZW50cy5tZW1iZXJzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdGhpcy4nKQoKICAgICAgICByZXR1cm4gTWVtYmVySXRlcmF0b3Ioc2VsZiwgbGltaXQ9bGltaXQsIGFmdGVyPWFmdGVyKQoKICAgIGFzeW5jIGRlZiBmZXRjaF9tZW1iZXIoc2VsZiwgbWVtYmVyX2lkKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgUmV0cmlldmVzIGEgOmNsYXNzOmBNZW1iZXJgIGZyb20gYSBndWlsZCBJRCwgYW5kIGEgbWVtYmVyIElELgoKICAgICAgICAuLiBub3RlOjoKCiAgICAgICAgICAgIFRoaXMgbWV0aG9kIGlzIGFuIEFQSSBjYWxsLiBJZiB5b3UgaGF2ZSA6YXR0cjpgSW50ZW50cy5tZW1iZXJzYCBhbmQgbWVtYmVyIGNhY2hlIGVuYWJsZWQsIGNvbnNpZGVyIDptZXRoOmBnZXRfbWVtYmVyYCBpbnN0ZWFkLgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBtZW1iZXJfaWQ6IDpjbGFzczpgaW50YAogICAgICAgICAgICBUaGUgbWVtYmVyJ3MgSUQgdG8gZmV0Y2ggZnJvbS4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgZG8gbm90IGhhdmUgYWNjZXNzIHRvIHRoZSBndWlsZC4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEZldGNoaW5nIHRoZSBtZW1iZXIgZmFpbGVkLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICA6Y2xhc3M6YE1lbWJlcmAKICAgICAgICAgICAgVGhlIG1lbWJlciBmcm9tIHRoZSBtZW1iZXIgSUQuCiAgICAgICAgIiIiCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuZ2V0X21lbWJlcihzZWxmLmlkLCBtZW1iZXJfaWQpCiAgICAgICAgcmV0dXJuIE1lbWJlcihkYXRhPWRhdGEsIHN0YXRlPXNlbGYuX3N0YXRlLCBndWlsZD1zZWxmKQoKICAgIGFzeW5jIGRlZiBmZXRjaF9iYW4oc2VsZiwgdXNlcik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFJldHJpZXZlcyB0aGUgOmNsYXNzOmBCYW5FbnRyeWAgZm9yIGEgdXNlci4KCiAgICAgICAgWW91IG11c3QgaGF2ZSB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5iYW5fbWVtYmVyc2AgcGVybWlzc2lvbgogICAgICAgIHRvIGdldCB0aGlzIGluZm9ybWF0aW9uLgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICB1c2VyOiA6Y2xhc3M6YGFiYy5Tbm93Zmxha2VgCiAgICAgICAgICAgIFRoZSB1c2VyIHRvIGdldCBiYW4gaW5mb3JtYXRpb24gZnJvbS4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSBwcm9wZXIgcGVybWlzc2lvbnMgdG8gZ2V0IHRoZSBpbmZvcm1hdGlvbi4KICAgICAgICBOb3RGb3VuZAogICAgICAgICAgICBUaGlzIHVzZXIgaXMgbm90IGJhbm5lZC4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSBpbmZvcm1hdGlvbi4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0KICAgICAgICA6Y2xhc3M6YEJhbkVudHJ5YAogICAgICAgICAgICBUaGUgOmNsYXNzOmBCYW5FbnRyeWAgb2JqZWN0IGZvciB0aGUgc3BlY2lmaWVkIHVzZXIuCiAgICAgICAgIiIiCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuZ2V0X2Jhbih1c2VyLmlkLCBzZWxmLmlkKQogICAgICAgIHJldHVybiBCYW5FbnRyeSgKICAgICAgICAgICAgdXNlcj1Vc2VyKHN0YXRlPXNlbGYuX3N0YXRlLCBkYXRhPWRhdGFbJ3VzZXInXSksCiAgICAgICAgICAgIHJlYXNvbj1kYXRhWydyZWFzb24nXQogICAgICAgICkKCiAgICBhc3luYyBkZWYgYmFucyhzZWxmKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgUmV0cmlldmVzIGFsbCB0aGUgdXNlcnMgdGhhdCBhcmUgYmFubmVkIGZyb20gdGhlIGd1aWxkIGFzIGEgOmNsYXNzOmBsaXN0YCBvZiA6Y2xhc3M6YEJhbkVudHJ5YC4KCiAgICAgICAgWW91IG11c3QgaGF2ZSB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5iYW5fbWVtYmVyc2AgcGVybWlzc2lvbgogICAgICAgIHRvIGdldCB0aGlzIGluZm9ybWF0aW9uLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSBwcm9wZXIgcGVybWlzc2lvbnMgdG8gZ2V0IHRoZSBpbmZvcm1hdGlvbi4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSBpbmZvcm1hdGlvbi4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgTGlzdFs6Y2xhc3M6YEJhbkVudHJ5YF0KICAgICAgICAgICAgQSBsaXN0IG9mIDpjbGFzczpgQmFuRW50cnlgIG9iamVjdHMuCiAgICAgICAgIiIiCgogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmdldF9iYW5zKHNlbGYuaWQpCiAgICAgICAgcmV0dXJuIFtCYW5FbnRyeSh1c2VyPVVzZXIoc3RhdGU9c2VsZi5fc3RhdGUsIGRhdGE9ZVsndXNlciddKSwKICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbj1lWydyZWFzb24nXSkKICAgICAgICAgICAgICAgIGZvciBlIGluIGRhdGFdCgogICAgYXN5bmMgZGVmIHBydW5lX21lbWJlcnMoc2VsZiwgKiwgZGF5cywgY29tcHV0ZV9wcnVuZV9jb3VudD1UcnVlLCByb2xlcz1Ob25lLCByZWFzb249Tm9uZSk6CiAgICAgICAgciIiInxjb3JvfAoKICAgICAgICBQcnVuZXMgdGhlIGd1aWxkIGZyb20gaXRzIGluYWN0aXZlIG1lbWJlcnMuCgogICAgICAgIFRoZSBpbmFjdGl2ZSBtZW1iZXJzIGFyZSBkZW5vdGVkIGlmIHRoZXkgaGF2ZSBub3QgbG9nZ2VkIG9uIGluCiAgICAgICAgYGBkYXlzYGAgbnVtYmVyIG9mIGRheXMgYW5kIHRoZXkgaGF2ZSBubyByb2xlcy4KCiAgICAgICAgWW91IG11c3QgaGF2ZSB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5raWNrX21lbWJlcnNgIHBlcm1pc3Npb24KICAgICAgICB0byB1c2UgdGhpcy4KCiAgICAgICAgVG8gY2hlY2sgaG93IG1hbnkgbWVtYmVycyB5b3Ugd291bGQgcHJ1bmUgd2l0aG91dCBhY3R1YWxseSBwcnVuaW5nLAogICAgICAgIHNlZSB0aGUgOm1ldGg6YGVzdGltYXRlX3BydW5lZF9tZW1iZXJzYCBmdW5jdGlvbi4KCiAgICAgICAgVG8gcHJ1bmUgbWVtYmVycyB0aGF0IGhhdmUgc3BlY2lmaWMgcm9sZXMgc2VlIHRoZSBgYHJvbGVzYGAgcGFyYW1ldGVyLgoKICAgICAgICAuLiB2ZXJzaW9uY2hhbmdlZDo6IDEuNAogICAgICAgICAgICBUaGUgYGByb2xlc2BgIGtleXdvcmQtb25seSBwYXJhbWV0ZXIgd2FzIGFkZGVkLgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBkYXlzOiA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIG51bWJlciBvZiBkYXlzIGJlZm9yZSBjb3VudGluZyBhcyBpbmFjdGl2ZS4KICAgICAgICByZWFzb246IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIHJlYXNvbiBmb3IgZG9pbmcgdGhpcyBhY3Rpb24uIFNob3dzIHVwIG9uIHRoZSBhdWRpdCBsb2cuCiAgICAgICAgY29tcHV0ZV9wcnVuZV9jb3VudDogOmNsYXNzOmBib29sYAogICAgICAgICAgICBXaGV0aGVyIHRvIGNvbXB1dGUgdGhlIHBydW5lIGNvdW50LiBUaGlzIGRlZmF1bHRzIHRvIGBgVHJ1ZWBgCiAgICAgICAgICAgIHdoaWNoIG1ha2VzIGl0IHByb25lIHRvIHRpbWVvdXRzIGluIHZlcnkgbGFyZ2UgZ3VpbGRzLiBJbiBvcmRlcgogICAgICAgICAgICB0byBwcmV2ZW50IHRpbWVvdXRzLCB5b3UgbXVzdCBzZXQgdGhpcyB0byBgYEZhbHNlYGAuIElmIHRoaXMgaXMKICAgICAgICAgICAgc2V0IHRvIGBgRmFsc2VgYFwsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gYGBOb25lYGAuCiAgICAgICAgcm9sZXM6IE9wdGlvbmFsW0xpc3RbOmNsYXNzOmBhYmMuU25vd2ZsYWtlYF1dCiAgICAgICAgICAgIEEgbGlzdCBvZiA6Y2xhc3M6YGFiYy5Tbm93Zmxha2VgIHRoYXQgcmVwcmVzZW50IHJvbGVzIHRvIGluY2x1ZGUgaW4gdGhlIHBydW5pbmcgcHJvY2Vzcy4gSWYgYSBtZW1iZXIKICAgICAgICAgICAgaGFzIGEgcm9sZSB0aGF0IGlzIG5vdCBzcGVjaWZpZWQsIHRoZXknbGwgYmUgZXhjbHVkZWQuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb25zIHRvIHBydW5lIG1lbWJlcnMuCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBwcnVuaW5nIG1lbWJlcnMuCiAgICAgICAgSW52YWxpZEFyZ3VtZW50CiAgICAgICAgICAgIEFuIGludGVnZXIgd2FzIG5vdCBwYXNzZWQgZm9yIGBgZGF5c2BgLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0tCiAgICAgICAgT3B0aW9uYWxbOmNsYXNzOmBpbnRgXQogICAgICAgICAgICBUaGUgbnVtYmVyIG9mIG1lbWJlcnMgcHJ1bmVkLiBJZiBgYGNvbXB1dGVfcHJ1bmVfY291bnRgYCBpcyBgYEZhbHNlYGAKICAgICAgICAgICAgdGhlbiB0aGlzIHJldHVybnMgYGBOb25lYGAuCiAgICAgICAgIiIiCgogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRheXMsIGludCk6CiAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgnRXhwZWN0ZWQgaW50IGZvciBgYGRheXNgYCwgcmVjZWl2ZWQgezAuX19jbGFzc19fLl9fbmFtZV9ffSBpbnN0ZWFkLicuZm9ybWF0KGRheXMpKQoKICAgICAgICBpZiByb2xlczoKICAgICAgICAgICAgcm9sZXMgPSBbc3RyKHJvbGUuaWQpIGZvciByb2xlIGluIHJvbGVzXQoKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5wcnVuZV9tZW1iZXJzKHNlbGYuaWQsIGRheXMsIGNvbXB1dGVfcHJ1bmVfY291bnQ9Y29tcHV0ZV9wcnVuZV9jb3VudCwgcm9sZXM9cm9sZXMsIHJlYXNvbj1yZWFzb24pCiAgICAgICAgcmV0dXJuIGRhdGFbJ3BydW5lZCddCgogICAgYXN5bmMgZGVmIHRlbXBsYXRlcyhzZWxmKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgR2V0cyB0aGUgbGlzdCBvZiB0ZW1wbGF0ZXMgZnJvbSB0aGlzIGd1aWxkLgoKICAgICAgICBSZXF1aXJlcyA6YXR0cjpgfi5QZXJtaXNzaW9ucy5tYW5hZ2VfZ3VpbGRgIHBlcm1pc3Npb25zLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjcKCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9ucyB0byBnZXQgdGhlIHRlbXBsYXRlcy4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgTGlzdFs6Y2xhc3M6YFRlbXBsYXRlYF0KICAgICAgICAgICAgVGhlIHRlbXBsYXRlcyBmb3IgdGhpcyBndWlsZC4KICAgICAgICAiIiIKICAgICAgICBmcm9tIC50ZW1wbGF0ZSBpbXBvcnQgVGVtcGxhdGUKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5ndWlsZF90ZW1wbGF0ZXMoc2VsZi5pZCkKICAgICAgICByZXR1cm4gW1RlbXBsYXRlKGRhdGE9ZCwgc3RhdGU9c2VsZi5fc3RhdGUpIGZvciBkIGluIGRhdGFdCgogICAgYXN5bmMgZGVmIHdlYmhvb2tzKHNlbGYpOgogICAgICAgICIiInxjb3JvfAoKICAgICAgICBHZXRzIHRoZSBsaXN0IG9mIHdlYmhvb2tzIGZyb20gdGhpcyBndWlsZC4KCiAgICAgICAgUmVxdWlyZXMgOmF0dHI6YH4uUGVybWlzc2lvbnMubWFuYWdlX3dlYmhvb2tzYCBwZXJtaXNzaW9ucy4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgZG9uJ3QgaGF2ZSBwZXJtaXNzaW9ucyB0byBnZXQgdGhlIHdlYmhvb2tzLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICBMaXN0WzpjbGFzczpgV2ViaG9va2BdCiAgICAgICAgICAgIFRoZSB3ZWJob29rcyBmb3IgdGhpcyBndWlsZC4KICAgICAgICAiIiIKCiAgICAgICAgZnJvbSAud2ViaG9vayBpbXBvcnQgV2ViaG9vawogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmd1aWxkX3dlYmhvb2tzKHNlbGYuaWQpCiAgICAgICAgcmV0dXJuIFtXZWJob29rLmZyb21fc3RhdGUoZCwgc3RhdGU9c2VsZi5fc3RhdGUpIGZvciBkIGluIGRhdGFdCgogICAgYXN5bmMgZGVmIGVzdGltYXRlX3BydW5lZF9tZW1iZXJzKHNlbGYsICosIGRheXMsIHJvbGVzPU5vbmUpOgogICAgICAgICIiInxjb3JvfAoKICAgICAgICBTaW1pbGFyIHRvIDptZXRoOmBwcnVuZV9tZW1iZXJzYCBleGNlcHQgaW5zdGVhZCBvZiBhY3R1YWxseQogICAgICAgIHBydW5pbmcgbWVtYmVycywgaXQgcmV0dXJucyBob3cgbWFueSBtZW1iZXJzIGl0IHdvdWxkIHBydW5lCiAgICAgICAgZnJvbSB0aGUgZ3VpbGQgaGFkIGl0IGJlZW4gY2FsbGVkLgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBkYXlzOiA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIG51bWJlciBvZiBkYXlzIGJlZm9yZSBjb3VudGluZyBhcyBpbmFjdGl2ZS4KICAgICAgICByb2xlczogT3B0aW9uYWxbTGlzdFs6Y2xhc3M6YGFiYy5Tbm93Zmxha2VgXV0KICAgICAgICAgICAgQSBsaXN0IG9mIDpjbGFzczpgYWJjLlNub3dmbGFrZWAgdGhhdCByZXByZXNlbnQgcm9sZXMgdG8gaW5jbHVkZSBpbiB0aGUgZXN0aW1hdGUuIElmIGEgbWVtYmVyCiAgICAgICAgICAgIGhhcyBhIHJvbGUgdGhhdCBpcyBub3Qgc3BlY2lmaWVkLCB0aGV5J2xsIGJlIGV4Y2x1ZGVkLgoKICAgICAgICAgICAgLi4gdmVyc2lvbmFkZGVkOjogMS43CgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb25zIHRvIHBydW5lIG1lbWJlcnMuCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyB0aGUgcHJ1bmUgbWVtYmVycyBlc3RpbWF0ZS4KICAgICAgICBJbnZhbGlkQXJndW1lbnQKICAgICAgICAgICAgQW4gaW50ZWdlciB3YXMgbm90IHBhc3NlZCBmb3IgYGBkYXlzYGAuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLS0KICAgICAgICA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIG51bWJlciBvZiBtZW1iZXJzIGVzdGltYXRlZCB0byBiZSBwcnVuZWQuCiAgICAgICAgIiIiCgogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKGRheXMsIGludCk6CiAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgnRXhwZWN0ZWQgaW50IGZvciBgYGRheXNgYCwgcmVjZWl2ZWQgezAuX19jbGFzc19fLl9fbmFtZV9ffSBpbnN0ZWFkLicuZm9ybWF0KGRheXMpKQoKICAgICAgICBpZiByb2xlczoKICAgICAgICAgICAgcm9sZXMgPSBbc3RyKHJvbGUuaWQpIGZvciByb2xlIGluIHJvbGVzXQoKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5lc3RpbWF0ZV9wcnVuZWRfbWVtYmVycyhzZWxmLmlkLCBkYXlzLCByb2xlcykKICAgICAgICByZXR1cm4gZGF0YVsncHJ1bmVkJ10KCiAgICBhc3luYyBkZWYgaW52aXRlcyhzZWxmKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGFjdGl2ZSBpbnN0YW50IGludml0ZXMgZnJvbSB0aGUgZ3VpbGQuCgogICAgICAgIFlvdSBtdXN0IGhhdmUgdGhlIDphdHRyOmB+UGVybWlzc2lvbnMubWFuYWdlX2d1aWxkYCBwZXJtaXNzaW9uIHRvIGdldAogICAgICAgIHRoaXMgaW5mb3JtYXRpb24uCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHByb3BlciBwZXJtaXNzaW9ucyB0byBnZXQgdGhlIGluZm9ybWF0aW9uLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdGhlIGluZm9ybWF0aW9uLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLQogICAgICAgIExpc3RbOmNsYXNzOmBJbnZpdGVgXQogICAgICAgICAgICBUaGUgbGlzdCBvZiBpbnZpdGVzIHRoYXQgYXJlIGN1cnJlbnRseSBhY3RpdmUuCiAgICAgICAgIiIiCgogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmludml0ZXNfZnJvbShzZWxmLmlkKQogICAgICAgIHJlc3VsdCA9IFtdCiAgICAgICAgZm9yIGludml0ZSBpbiBkYXRhOgogICAgICAgICAgICBjaGFubmVsID0gc2VsZi5nZXRfY2hhbm5lbChpbnQoaW52aXRlWydjaGFubmVsJ11bJ2lkJ10pKQogICAgICAgICAgICBpbnZpdGVbJ2NoYW5uZWwnXSA9IGNoYW5uZWwKICAgICAgICAgICAgaW52aXRlWydndWlsZCddID0gc2VsZgogICAgICAgICAgICByZXN1bHQuYXBwZW5kKEludml0ZShzdGF0ZT1zZWxmLl9zdGF0ZSwgZGF0YT1pbnZpdGUpKQoKICAgICAgICByZXR1cm4gcmVzdWx0CgogICAgYXN5bmMgZGVmIGNyZWF0ZV90ZW1wbGF0ZShzZWxmLCAqLCBuYW1lLCBkZXNjcmlwdGlvbj1Ob25lKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgQ3JlYXRlcyBhIHRlbXBsYXRlIGZvciB0aGUgZ3VpbGQuCgogICAgICAgIFlvdSBtdXN0IGhhdmUgdGhlIDphdHRyOmB+UGVybWlzc2lvbnMubWFuYWdlX2d1aWxkYCBwZXJtaXNzaW9uIHRvCiAgICAgICAgZG8gdGhpcy4KCiAgICAgICAgLi4gdmVyc2lvbmFkZGVkOjogMS43CgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIG5hbWU6IDpjbGFzczpgc3RyYAogICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgdGVtcGxhdGUuCiAgICAgICAgZGVzY3JpcHRpb246IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSB0ZW1wbGF0ZS4KICAgICAgICAiIiIKICAgICAgICBmcm9tIC50ZW1wbGF0ZSBpbXBvcnQgVGVtcGxhdGUKCiAgICAgICAgcGF5bG9hZCA9IHsKICAgICAgICAgICAgJ25hbWUnOiBuYW1lCiAgICAgICAgfQoKICAgICAgICBpZiBkZXNjcmlwdGlvbjoKICAgICAgICAgICAgcGF5bG9hZFsnZGVzY3JpcHRpb24nXSA9IGRlc2NyaXB0aW9uCgogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmNyZWF0ZV90ZW1wbGF0ZShzZWxmLmlkLCBwYXlsb2FkKQoKICAgICAgICByZXR1cm4gVGVtcGxhdGUoc3RhdGU9c2VsZi5fc3RhdGUsIGRhdGE9ZGF0YSkKCiAgICBhc3luYyBkZWYgY3JlYXRlX2ludGVncmF0aW9uKHNlbGYsICosIHR5cGUsIGlkKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgQXR0YWNoZXMgYW4gaW50ZWdyYXRpb24gdG8gdGhlIGd1aWxkLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLm1hbmFnZV9ndWlsZGAgcGVybWlzc2lvbiB0bwogICAgICAgIGRvIHRoaXMuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuNAoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICB0eXBlOiA6Y2xhc3M6YHN0cmAKICAgICAgICAgICAgVGhlIGludGVncmF0aW9uIHR5cGUgKGUuZy4gVHdpdGNoKS4KICAgICAgICBpZDogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBpbnRlZ3JhdGlvbiBJRC4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBjcmVhdGUgdGhlIGludGVncmF0aW9uLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgVGhlIGFjY291bnQgY291bGQgbm90IGJlIGZvdW5kLgogICAgICAgICIiIgogICAgICAgIGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuY3JlYXRlX2ludGVncmF0aW9uKHNlbGYuaWQsIHR5cGUsIGlkKQoKICAgIGFzeW5jIGRlZiBpbnRlZ3JhdGlvbnMoc2VsZik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFJldHVybnMgYSBsaXN0IG9mIGFsbCBpbnRlZ3JhdGlvbnMgYXR0YWNoZWQgdG8gdGhlIGd1aWxkLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLm1hbmFnZV9ndWlsZGAgcGVybWlzc2lvbiB0bwogICAgICAgIGRvIHRoaXMuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuNAoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGNyZWF0ZSB0aGUgaW50ZWdyYXRpb24uCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBGZXRjaGluZyB0aGUgaW50ZWdyYXRpb25zIGZhaWxlZC4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgTGlzdFs6Y2xhc3M6YEludGVncmF0aW9uYF0KICAgICAgICAgICAgVGhlIGxpc3Qgb2YgaW50ZWdyYXRpb25zIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoZSBndWlsZC4KICAgICAgICAiIiIKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5nZXRfYWxsX2ludGVncmF0aW9ucyhzZWxmLmlkKQogICAgICAgIHJldHVybiBbSW50ZWdyYXRpb24oZ3VpbGQ9c2VsZiwgZGF0YT1kKSBmb3IgZCBpbiBkYXRhXQoKICAgIGFzeW5jIGRlZiBmZXRjaF9lbW9qaXMoc2VsZik6CiAgICAgICAgciIiInxjb3JvfAoKICAgICAgICBSZXRyaWV2ZXMgYWxsIGN1c3RvbSA6Y2xhc3M6YEVtb2ppYFxzIGZyb20gdGhlIGd1aWxkLgoKICAgICAgICAuLiBub3RlOjoKCiAgICAgICAgICAgIFRoaXMgbWV0aG9kIGlzIGFuIEFQSSBjYWxsLiBGb3IgZ2VuZXJhbCB1c2FnZSwgY29uc2lkZXIgOmF0dHI6YGVtb2ppc2AgaW5zdGVhZC4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLS0tCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBBbiBlcnJvciBvY2N1cnJlZCBmZXRjaGluZyB0aGUgZW1vamlzLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICBMaXN0WzpjbGFzczpgRW1vamlgXQogICAgICAgICAgICBUaGUgcmV0cmlldmVkIGVtb2ppcy4KICAgICAgICAiIiIKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5nZXRfYWxsX2N1c3RvbV9lbW9qaXMoc2VsZi5pZCkKICAgICAgICByZXR1cm4gW0Vtb2ppKGd1aWxkPXNlbGYsIHN0YXRlPXNlbGYuX3N0YXRlLCBkYXRhPWQpIGZvciBkIGluIGRhdGFdCgogICAgYXN5bmMgZGVmIGZldGNoX2Vtb2ppKHNlbGYsIGVtb2ppX2lkKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgUmV0cmlldmVzIGEgY3VzdG9tIDpjbGFzczpgRW1vamlgIGZyb20gdGhlIGd1aWxkLgoKICAgICAgICAuLiBub3RlOjoKCiAgICAgICAgICAgIFRoaXMgbWV0aG9kIGlzIGFuIEFQSSBjYWxsLgogICAgICAgICAgICBGb3IgZ2VuZXJhbCB1c2FnZSwgY29uc2lkZXIgaXRlcmF0aW5nIG92ZXIgOmF0dHI6YGVtb2ppc2AgaW5zdGVhZC4KCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tLS0KICAgICAgICBlbW9qaV9pZDogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBlbW9qaSdzIElELgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tLS0KICAgICAgICBOb3RGb3VuZAogICAgICAgICAgICBUaGUgZW1vamkgcmVxdWVzdGVkIGNvdWxkIG5vdCBiZSBmb3VuZC4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEFuIGVycm9yIG9jY3VycmVkIGZldGNoaW5nIHRoZSBlbW9qaS4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgOmNsYXNzOmBFbW9qaWAKICAgICAgICAgICAgVGhlIHJldHJpZXZlZCBlbW9qaS4KICAgICAgICAiIiIKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5nZXRfY3VzdG9tX2Vtb2ppKHNlbGYuaWQsIGVtb2ppX2lkKQogICAgICAgIHJldHVybiBFbW9qaShndWlsZD1zZWxmLCBzdGF0ZT1zZWxmLl9zdGF0ZSwgZGF0YT1kYXRhKQoKICAgIGFzeW5jIGRlZiBjcmVhdGVfY3VzdG9tX2Vtb2ppKHNlbGYsICosIG5hbWUsIGltYWdlLCByb2xlcz1Ob25lLCByZWFzb249Tm9uZSk6CiAgICAgICAgciIiInxjb3JvfAoKICAgICAgICBDcmVhdGVzIGEgY3VzdG9tIDpjbGFzczpgRW1vamlgIGZvciB0aGUgZ3VpbGQuCgogICAgICAgIFRoZXJlIGlzIGN1cnJlbnRseSBhIGxpbWl0IG9mIDUwIHN0YXRpYyBhbmQgYW5pbWF0ZWQgZW1vamlzIHJlc3BlY3RpdmVseSBwZXIgZ3VpbGQsCiAgICAgICAgdW5sZXNzIHRoZSBndWlsZCBoYXMgdGhlIGBgTU9SRV9FTU9KSWBgIGZlYXR1cmUgd2hpY2ggZXh0ZW5kcyB0aGUgbGltaXQgdG8gMjAwLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLm1hbmFnZV9lbW9qaXNgIHBlcm1pc3Npb24gdG8KICAgICAgICBkbyB0aGlzLgoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBuYW1lOiA6Y2xhc3M6YHN0cmAKICAgICAgICAgICAgVGhlIGVtb2ppIG5hbWUuIE11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzLgogICAgICAgIGltYWdlOiA6Y2xhc3M6YGJ5dGVzYAogICAgICAgICAgICBUaGUgOnRlcm06YHB5OmJ5dGVzLWxpa2Ugb2JqZWN0YCByZXByZXNlbnRpbmcgdGhlIGltYWdlIGRhdGEgdG8gdXNlLgogICAgICAgICAgICBPbmx5IEpQRywgUE5HIGFuZCBHSUYgaW1hZ2VzIGFyZSBzdXBwb3J0ZWQuCiAgICAgICAgcm9sZXM6IE9wdGlvbmFsW0xpc3RbOmNsYXNzOmBSb2xlYF1dCiAgICAgICAgICAgIEEgOmNsYXNzOmBsaXN0YCBvZiA6Y2xhc3M6YFJvbGVgXHMgdGhhdCBjYW4gdXNlIHRoaXMgZW1vamkuIExlYXZlIGVtcHR5IHRvIG1ha2UgaXQgYXZhaWxhYmxlIHRvIGV2ZXJ5b25lLgogICAgICAgIHJlYXNvbjogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgICAgICBUaGUgcmVhc29uIGZvciBjcmVhdGluZyB0aGlzIGVtb2ppLiBTaG93cyB1cCBvbiB0aGUgYXVkaXQgbG9nLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY3JlYXRlIGVtb2ppcy4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEFuIGVycm9yIG9jY3VycmVkIGNyZWF0aW5nIGFuIGVtb2ppLgoKICAgICAgICBSZXR1cm5zCiAgICAgICAgLS0tLS0tLS0KICAgICAgICA6Y2xhc3M6YEVtb2ppYAogICAgICAgICAgICBUaGUgY3JlYXRlZCBlbW9qaS4KICAgICAgICAiIiIKCiAgICAgICAgaW1nID0gdXRpbHMuX2J5dGVzX3RvX2Jhc2U2NF9kYXRhKGltYWdlKQogICAgICAgIGlmIHJvbGVzOgogICAgICAgICAgICByb2xlcyA9IFtyb2xlLmlkIGZvciByb2xlIGluIHJvbGVzXQogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmNyZWF0ZV9jdXN0b21fZW1vamkoc2VsZi5pZCwgbmFtZSwgaW1nLCByb2xlcz1yb2xlcywgcmVhc29uPXJlYXNvbikKICAgICAgICByZXR1cm4gc2VsZi5fc3RhdGUuc3RvcmVfZW1vamkoc2VsZiwgZGF0YSkKCiAgICBhc3luYyBkZWYgZmV0Y2hfcm9sZXMoc2VsZik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFJldHJpZXZlcyBhbGwgOmNsYXNzOmBSb2xlYCB0aGF0IHRoZSBndWlsZCBoYXMuCgogICAgICAgIC4uIG5vdGU6OgoKICAgICAgICAgICAgVGhpcyBtZXRob2QgaXMgYW4gQVBJIGNhbGwuIEZvciBnZW5lcmFsIHVzYWdlLCBjb25zaWRlciA6YXR0cjpgcm9sZXNgIGluc3RlYWQuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuMwoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBSZXRyaWV2aW5nIHRoZSByb2xlcyBmYWlsZWQuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tCiAgICAgICAgTGlzdFs6Y2xhc3M6YFJvbGVgXQogICAgICAgICAgICBBbGwgcm9sZXMgaW4gdGhlIGd1aWxkLgogICAgICAgICIiIgogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmdldF9yb2xlcyhzZWxmLmlkKQogICAgICAgIHJldHVybiBbUm9sZShndWlsZD1zZWxmLCBzdGF0ZT1zZWxmLl9zdGF0ZSwgZGF0YT1kKSBmb3IgZCBpbiBkYXRhXQoKICAgIGFzeW5jIGRlZiBjcmVhdGVfcm9sZShzZWxmLCAqLCByZWFzb249Tm9uZSwgKipmaWVsZHMpOgogICAgICAgICIiInxjb3JvfAoKICAgICAgICBDcmVhdGVzIGEgOmNsYXNzOmBSb2xlYCBmb3IgdGhlIGd1aWxkLgoKICAgICAgICBBbGwgZmllbGRzIGFyZSBvcHRpb25hbC4KCiAgICAgICAgWW91IG11c3QgaGF2ZSB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5tYW5hZ2Vfcm9sZXNgIHBlcm1pc3Npb24gdG8KICAgICAgICBkbyB0aGlzLgoKICAgICAgICAuLiB2ZXJzaW9uY2hhbmdlZDo6IDEuNgogICAgICAgICAgICBDYW4gbm93IHBhc3MgYGBpbnRgYCB0byBgYGNvbG91cmBgIGtleXdvcmQtb25seSBwYXJhbWV0ZXIuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIG5hbWU6IDpjbGFzczpgc3RyYAogICAgICAgICAgICBUaGUgcm9sZSBuYW1lLiBEZWZhdWx0cyB0byAnbmV3IHJvbGUnLgogICAgICAgIHBlcm1pc3Npb25zOiA6Y2xhc3M6YFBlcm1pc3Npb25zYAogICAgICAgICAgICBUaGUgcGVybWlzc2lvbnMgdG8gaGF2ZS4gRGVmYXVsdHMgdG8gbm8gcGVybWlzc2lvbnMuCiAgICAgICAgY29sb3VyOiBVbmlvbls6Y2xhc3M6YENvbG91cmAsIDpjbGFzczpgaW50YF0KICAgICAgICAgICAgVGhlIGNvbG91ciBmb3IgdGhlIHJvbGUuIERlZmF1bHRzIHRvIDptZXRoOmBDb2xvdXIuZGVmYXVsdGAuCiAgICAgICAgICAgIFRoaXMgaXMgYWxpYXNlZCB0byBgYGNvbG9yYGAgYXMgd2VsbC4KICAgICAgICBob2lzdDogOmNsYXNzOmBib29sYAogICAgICAgICAgICBJbmRpY2F0ZXMgaWYgdGhlIHJvbGUgc2hvdWxkIGJlIHNob3duIHNlcGFyYXRlbHkgaW4gdGhlIG1lbWJlciBsaXN0LgogICAgICAgICAgICBEZWZhdWx0cyB0byBgYEZhbHNlYGAuCiAgICAgICAgbWVudGlvbmFibGU6IDpjbGFzczpgYm9vbGAKICAgICAgICAgICAgSW5kaWNhdGVzIGlmIHRoZSByb2xlIHNob3VsZCBiZSBtZW50aW9uYWJsZSBieSBvdGhlcnMuCiAgICAgICAgICAgIERlZmF1bHRzIHRvIGBgRmFsc2VgYC4KICAgICAgICByZWFzb246IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIHJlYXNvbiBmb3IgY3JlYXRpbmcgdGhpcyByb2xlLiBTaG93cyB1cCBvbiB0aGUgYXVkaXQgbG9nLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9ucyB0byBjcmVhdGUgdGhlIHJvbGUuCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBDcmVhdGluZyB0aGUgcm9sZSBmYWlsZWQuCiAgICAgICAgSW52YWxpZEFyZ3VtZW50CiAgICAgICAgICAgIEFuIGludmFsaWQga2V5d29yZCBhcmd1bWVudCB3YXMgZ2l2ZW4uCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLQogICAgICAgIDpjbGFzczpgUm9sZWAKICAgICAgICAgICAgVGhlIG5ld2x5IGNyZWF0ZWQgcm9sZS4KICAgICAgICAiIiIKCiAgICAgICAgdHJ5OgogICAgICAgICAgICBwZXJtcyA9IGZpZWxkcy5wb3AoJ3Blcm1pc3Npb25zJykKICAgICAgICBleGNlcHQgS2V5RXJyb3I6CiAgICAgICAgICAgIGZpZWxkc1sncGVybWlzc2lvbnMnXSA9IDAKICAgICAgICBlbHNlOgogICAgICAgICAgICBmaWVsZHNbJ3Blcm1pc3Npb25zJ10gPSBwZXJtcy52YWx1ZQoKICAgICAgICB0cnk6CiAgICAgICAgICAgIGNvbG91ciA9IGZpZWxkcy5wb3AoJ2NvbG91cicpCiAgICAgICAgZXhjZXB0IEtleUVycm9yOgogICAgICAgICAgICBjb2xvdXIgPSBmaWVsZHMuZ2V0KCdjb2xvcicsIENvbG91ci5kZWZhdWx0KCkpCiAgICAgICAgZmluYWxseToKICAgICAgICAgICAgaWYgaXNpbnN0YW5jZShjb2xvdXIsIGludCk6CiAgICAgICAgICAgICAgICBjb2xvdXIgPSBDb2xvdXIodmFsdWU9Y29sb3VyKQogICAgICAgICAgICBmaWVsZHNbJ2NvbG9yJ10gPSBjb2xvdXIudmFsdWUKCiAgICAgICAgdmFsaWRfa2V5cyA9ICgnbmFtZScsICdwZXJtaXNzaW9ucycsICdjb2xvcicsICdob2lzdCcsICdtZW50aW9uYWJsZScpCiAgICAgICAgZm9yIGtleSBpbiBmaWVsZHM6CiAgICAgICAgICAgIGlmIGtleSBub3QgaW4gdmFsaWRfa2V5czoKICAgICAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgnJXIgaXMgbm90IGEgdmFsaWQgZmllbGQuJyAlIGtleSkKCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuY3JlYXRlX3JvbGUoc2VsZi5pZCwgcmVhc29uPXJlYXNvbiwgKipmaWVsZHMpCiAgICAgICAgcm9sZSA9IFJvbGUoZ3VpbGQ9c2VsZiwgZGF0YT1kYXRhLCBzdGF0ZT1zZWxmLl9zdGF0ZSkKCiAgICAgICAgIyBUT0RPOiBhZGQgdG8gY2FjaGUKICAgICAgICByZXR1cm4gcm9sZQoKICAgIGFzeW5jIGRlZiBlZGl0X3JvbGVfcG9zaXRpb25zKHNlbGYsIHBvc2l0aW9ucywgKiwgcmVhc29uPU5vbmUpOgogICAgICAgICIiInxjb3JvfAoKICAgICAgICBCdWxrIGVkaXRzIGEgbGlzdCBvZiA6Y2xhc3M6YFJvbGVgIGluIHRoZSBndWlsZC4KCiAgICAgICAgWW91IG11c3QgaGF2ZSB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5tYW5hZ2Vfcm9sZXNgIHBlcm1pc3Npb24gdG8KICAgICAgICBkbyB0aGlzLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjQKCiAgICAgICAgRXhhbXBsZToKCiAgICAgICAgLi4gY29kZS1ibG9jazo6IHB5dGhvbjMKCiAgICAgICAgICAgIHBvc2l0aW9ucyA9IHsKICAgICAgICAgICAgICAgIGJvdHNfcm9sZTogMSwgIyBwZW51bHRpbWF0ZSByb2xlCiAgICAgICAgICAgICAgICB0ZXN0ZXJfcm9sZTogMiwKICAgICAgICAgICAgICAgIGFkbWluX3JvbGU6IDYKICAgICAgICAgICAgfQoKICAgICAgICAgICAgYXdhaXQgZ3VpbGQuZWRpdF9yb2xlX3Bvc2l0aW9ucyhwb3NpdGlvbnM9cG9zaXRpb25zKQoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBwb3NpdGlvbnMKICAgICAgICAgICAgQSA6Y2xhc3M6YGRpY3RgIG9mIDpjbGFzczpgUm9sZWAgdG8gOmNsYXNzOmBpbnRgIHRvIGNoYW5nZSB0aGUgcG9zaXRpb25zCiAgICAgICAgICAgIG9mIGVhY2ggZ2l2ZW4gcm9sZS4KICAgICAgICByZWFzb246IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIHJlYXNvbiBmb3IgZWRpdGluZyB0aGUgcm9sZSBwb3NpdGlvbnMuIFNob3dzIHVwIG9uIHRoZSBhdWRpdCBsb2cuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb25zIHRvIG1vdmUgdGhlIHJvbGVzLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgTW92aW5nIHRoZSByb2xlcyBmYWlsZWQuCiAgICAgICAgSW52YWxpZEFyZ3VtZW50CiAgICAgICAgICAgIEFuIGludmFsaWQga2V5d29yZCBhcmd1bWVudCB3YXMgZ2l2ZW4uCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLQogICAgICAgIExpc3RbOmNsYXNzOmBSb2xlYF0KICAgICAgICAgICAgQSBsaXN0IG9mIGFsbCB0aGUgcm9sZXMgaW4gdGhlIGd1aWxkLgogICAgICAgICIiIgogICAgICAgIGlmIG5vdCBpc2luc3RhbmNlKHBvc2l0aW9ucywgZGljdCk6CiAgICAgICAgICAgIHJhaXNlIEludmFsaWRBcmd1bWVudCgncG9zaXRpb25zIHBhcmFtZXRlciBleHBlY3RzIGEgZGljdC4nKQoKICAgICAgICByb2xlX3Bvc2l0aW9ucyA9IFtdCiAgICAgICAgZm9yIHJvbGUsIHBvc2l0aW9uIGluIHBvc2l0aW9ucy5pdGVtcygpOgoKICAgICAgICAgICAgcGF5bG9hZCA9IHsKICAgICAgICAgICAgICAgICdpZCc6IHJvbGUuaWQsCiAgICAgICAgICAgICAgICAncG9zaXRpb24nOiBwb3NpdGlvbgogICAgICAgICAgICB9CgogICAgICAgICAgICByb2xlX3Bvc2l0aW9ucy5hcHBlbmQocGF5bG9hZCkKCiAgICAgICAgZGF0YSA9IGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAubW92ZV9yb2xlX3Bvc2l0aW9uKHNlbGYuaWQsIHJvbGVfcG9zaXRpb25zLCByZWFzb249cmVhc29uKQogICAgICAgIHJvbGVzID0gW10KICAgICAgICBmb3IgZCBpbiBkYXRhOgogICAgICAgICAgICByb2xlID0gUm9sZShndWlsZD1zZWxmLCBkYXRhPWQsIHN0YXRlPXNlbGYuX3N0YXRlKQogICAgICAgICAgICByb2xlcy5hcHBlbmQocm9sZSkKICAgICAgICAgICAgc2VsZi5fcm9sZXNbcm9sZS5pZF0gPSByb2xlCgogICAgICAgIHJldHVybiByb2xlcwoKICAgIGFzeW5jIGRlZiBraWNrKHNlbGYsIHVzZXIsICosIHJlYXNvbj1Ob25lKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgS2lja3MgYSB1c2VyIGZyb20gdGhlIGd1aWxkLgoKICAgICAgICBUaGUgdXNlciBtdXN0IG1lZXQgdGhlIDpjbGFzczpgYWJjLlNub3dmbGFrZWAgYWJjLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLmtpY2tfbWVtYmVyc2AgcGVybWlzc2lvbiB0bwogICAgICAgIGRvIHRoaXMuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIHVzZXI6IDpjbGFzczpgYWJjLlNub3dmbGFrZWAKICAgICAgICAgICAgVGhlIHVzZXIgdG8ga2ljayBmcm9tIHRoZWlyIGd1aWxkLgogICAgICAgIHJlYXNvbjogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgICAgICBUaGUgcmVhc29uIHRoZSB1c2VyIGdvdCBraWNrZWQuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHRoZSBwcm9wZXIgcGVybWlzc2lvbnMgdG8ga2ljay4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEtpY2tpbmcgZmFpbGVkLgogICAgICAgICIiIgogICAgICAgIGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAua2ljayh1c2VyLmlkLCBzZWxmLmlkLCByZWFzb249cmVhc29uKQoKICAgIGFzeW5jIGRlZiBiYW4oc2VsZiwgdXNlciwgKiwgcmVhc29uPU5vbmUsIGRlbGV0ZV9tZXNzYWdlX2RheXM9MSk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIEJhbnMgYSB1c2VyIGZyb20gdGhlIGd1aWxkLgoKICAgICAgICBUaGUgdXNlciBtdXN0IG1lZXQgdGhlIDpjbGFzczpgYWJjLlNub3dmbGFrZWAgYWJjLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLmJhbl9tZW1iZXJzYCBwZXJtaXNzaW9uIHRvCiAgICAgICAgZG8gdGhpcy4KCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgdXNlcjogOmNsYXNzOmBhYmMuU25vd2ZsYWtlYAogICAgICAgICAgICBUaGUgdXNlciB0byBiYW4gZnJvbSB0aGVpciBndWlsZC4KICAgICAgICBkZWxldGVfbWVzc2FnZV9kYXlzOiA6Y2xhc3M6YGludGAKICAgICAgICAgICAgVGhlIG51bWJlciBvZiBkYXlzIHdvcnRoIG9mIG1lc3NhZ2VzIHRvIGRlbGV0ZSBmcm9tIHRoZSB1c2VyCiAgICAgICAgICAgIGluIHRoZSBndWlsZC4gVGhlIG1pbmltdW0gaXMgMCBhbmQgdGhlIG1heGltdW0gaXMgNy4KICAgICAgICByZWFzb246IE9wdGlvbmFsWzpjbGFzczpgc3RyYF0KICAgICAgICAgICAgVGhlIHJlYXNvbiB0aGUgdXNlciBnb3QgYmFubmVkLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSB0aGUgcHJvcGVyIHBlcm1pc3Npb25zIHRvIGJhbi4KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEJhbm5pbmcgZmFpbGVkLgogICAgICAgICIiIgogICAgICAgIGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuYmFuKHVzZXIuaWQsIHNlbGYuaWQsIGRlbGV0ZV9tZXNzYWdlX2RheXMsIHJlYXNvbj1yZWFzb24pCgogICAgYXN5bmMgZGVmIHVuYmFuKHNlbGYsIHVzZXIsICosIHJlYXNvbj1Ob25lKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgVW5iYW5zIGEgdXNlciBmcm9tIHRoZSBndWlsZC4KCiAgICAgICAgVGhlIHVzZXIgbXVzdCBtZWV0IHRoZSA6Y2xhc3M6YGFiYy5Tbm93Zmxha2VgIGFiYy4KCiAgICAgICAgWW91IG11c3QgaGF2ZSB0aGUgOmF0dHI6YH5QZXJtaXNzaW9ucy5iYW5fbWVtYmVyc2AgcGVybWlzc2lvbiB0bwogICAgICAgIGRvIHRoaXMuCgogICAgICAgIFBhcmFtZXRlcnMKICAgICAgICAtLS0tLS0tLS0tLQogICAgICAgIHVzZXI6IDpjbGFzczpgYWJjLlNub3dmbGFrZWAKICAgICAgICAgICAgVGhlIHVzZXIgdG8gdW5iYW4uCiAgICAgICAgcmVhc29uOiBPcHRpb25hbFs6Y2xhc3M6YHN0cmBdCiAgICAgICAgICAgIFRoZSByZWFzb24gZm9yIGRvaW5nIHRoaXMgYWN0aW9uLiBTaG93cyB1cCBvbiB0aGUgYXVkaXQgbG9nLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgRm9yYmlkZGVuCiAgICAgICAgICAgIFlvdSBkbyBub3QgaGF2ZSB0aGUgcHJvcGVyIHBlcm1pc3Npb25zIHRvIHVuYmFuLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgVW5iYW5uaW5nIGZhaWxlZC4KICAgICAgICAiIiIKICAgICAgICBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLnVuYmFuKHVzZXIuaWQsIHNlbGYuaWQsIHJlYXNvbj1yZWFzb24pCgogICAgYXN5bmMgZGVmIHZhbml0eV9pbnZpdGUoc2VsZik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFJldHVybnMgdGhlIGd1aWxkJ3Mgc3BlY2lhbCB2YW5pdHkgaW52aXRlLgoKICAgICAgICBUaGUgZ3VpbGQgbXVzdCBoYXZlIGBgVkFOSVRZX1VSTGBgIGluIDphdHRyOmB+R3VpbGQuZmVhdHVyZXNgLgoKICAgICAgICBZb3UgbXVzdCBoYXZlIHRoZSA6YXR0cjpgflBlcm1pc3Npb25zLm1hbmFnZV9ndWlsZGAgcGVybWlzc2lvbiB0byB1c2UKICAgICAgICB0aGlzIGFzIHdlbGwuCgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBGb3JiaWRkZW4KICAgICAgICAgICAgWW91IGRvIG5vdCBoYXZlIHRoZSBwcm9wZXIgcGVybWlzc2lvbnMgdG8gZ2V0IHRoaXMuCiAgICAgICAgSFRUUEV4Y2VwdGlvbgogICAgICAgICAgICBSZXRyaWV2aW5nIHRoZSB2YW5pdHkgaW52aXRlIGZhaWxlZC4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgOmNsYXNzOmBJbnZpdGVgCiAgICAgICAgICAgIFRoZSBzcGVjaWFsIHZhbml0eSBpbnZpdGUuCiAgICAgICAgIiIiCgogICAgICAgICMgd2Ugc3RhcnQgd2l0aCB7IGNvZGU6IGFiYyB9CiAgICAgICAgcGF5bG9hZCA9IGF3YWl0IHNlbGYuX3N0YXRlLmh0dHAuZ2V0X3Zhbml0eV9jb2RlKHNlbGYuaWQpCgogICAgICAgICMgZ2V0IHRoZSB2YW5pdHkgVVJMIGNoYW5uZWwgc2luY2UgZGVmYXVsdCBjaGFubmVscyBhcmVuJ3QKICAgICAgICAjIHJlbGlhYmxlIG9yIGEgdGhpbmcgYW55bW9yZQogICAgICAgIGRhdGEgPSBhd2FpdCBzZWxmLl9zdGF0ZS5odHRwLmdldF9pbnZpdGUocGF5bG9hZFsnY29kZSddKQoKICAgICAgICBwYXlsb2FkWydndWlsZCddID0gc2VsZgogICAgICAgIHBheWxvYWRbJ2NoYW5uZWwnXSA9IHNlbGYuZ2V0X2NoYW5uZWwoaW50KGRhdGFbJ2NoYW5uZWwnXVsnaWQnXSkpCiAgICAgICAgcGF5bG9hZFsncmV2b2tlZCddID0gRmFsc2UKICAgICAgICBwYXlsb2FkWyd0ZW1wb3JhcnknXSA9IEZhbHNlCiAgICAgICAgcGF5bG9hZFsnbWF4X3VzZXMnXSA9IDAKICAgICAgICBwYXlsb2FkWydtYXhfYWdlJ10gPSAwCiAgICAgICAgcmV0dXJuIEludml0ZShzdGF0ZT1zZWxmLl9zdGF0ZSwgZGF0YT1wYXlsb2FkKQoKICAgIEB1dGlscy5kZXByZWNhdGVkKCkKICAgIGRlZiBhY2soc2VsZik6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIE1hcmtzIGV2ZXJ5IG1lc3NhZ2UgaW4gdGhpcyBndWlsZCBhcyByZWFkLgoKICAgICAgICBUaGUgdXNlciBtdXN0IG5vdCBiZSBhIGJvdCB1c2VyLgoKICAgICAgICAuLiBkZXByZWNhdGVkOjogMS43CgogICAgICAgIFJhaXNlcwogICAgICAgIC0tLS0tLS0KICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEFja2luZyBmYWlsZWQuCiAgICAgICAgQ2xpZW50RXhjZXB0aW9uCiAgICAgICAgICAgIFlvdSBtdXN0IG5vdCBiZSBhIGJvdCB1c2VyLgogICAgICAgICIiIgoKICAgICAgICBzdGF0ZSA9IHNlbGYuX3N0YXRlCiAgICAgICAgaWYgc3RhdGUuaXNfYm90OgogICAgICAgICAgICByYWlzZSBDbGllbnRFeGNlcHRpb24oJ011c3Qgbm90IGJlIGEgYm90IGFjY291bnQgdG8gYWNrIG1lc3NhZ2VzLicpCiAgICAgICAgcmV0dXJuIHN0YXRlLmh0dHAuYWNrX2d1aWxkKHNlbGYuaWQpCgogICAgZGVmIGF1ZGl0X2xvZ3Moc2VsZiwgKiwgbGltaXQ9MTAwLCBiZWZvcmU9Tm9uZSwgYWZ0ZXI9Tm9uZSwgb2xkZXN0X2ZpcnN0PU5vbmUsIHVzZXI9Tm9uZSwgYWN0aW9uPU5vbmUpOgogICAgICAgICIiIlJldHVybnMgYW4gOmNsYXNzOmBBc3luY0l0ZXJhdG9yYCB0aGF0IGVuYWJsZXMgcmVjZWl2aW5nIHRoZSBndWlsZCdzIGF1ZGl0IGxvZ3MuCgogICAgICAgIFlvdSBtdXN0IGhhdmUgdGhlIDphdHRyOmB+UGVybWlzc2lvbnMudmlld19hdWRpdF9sb2dgIHBlcm1pc3Npb24gdG8gdXNlIHRoaXMuCgogICAgICAgIEV4YW1wbGVzCiAgICAgICAgLS0tLS0tLS0tLQoKICAgICAgICBHZXR0aW5nIHRoZSBmaXJzdCAxMDAgZW50cmllczogOjoKCiAgICAgICAgICAgIGFzeW5jIGZvciBlbnRyeSBpbiBndWlsZC5hdWRpdF9sb2dzKGxpbWl0PTEwMCk6CiAgICAgICAgICAgICAgICBwcmludCgnezAudXNlcn0gZGlkIHswLmFjdGlvbn0gdG8gezAudGFyZ2V0fScuZm9ybWF0KGVudHJ5KSkKCiAgICAgICAgR2V0dGluZyBlbnRyaWVzIGZvciBhIHNwZWNpZmljIGFjdGlvbjogOjoKCiAgICAgICAgICAgIGFzeW5jIGZvciBlbnRyeSBpbiBndWlsZC5hdWRpdF9sb2dzKGFjdGlvbj1kaXNjb3JkLkF1ZGl0TG9nQWN0aW9uLmJhbik6CiAgICAgICAgICAgICAgICBwcmludCgnezAudXNlcn0gYmFubmVkIHswLnRhcmdldH0nLmZvcm1hdChlbnRyeSkpCgogICAgICAgIEdldHRpbmcgZW50cmllcyBtYWRlIGJ5IGEgc3BlY2lmaWMgdXNlcjogOjoKCiAgICAgICAgICAgIGVudHJpZXMgPSBhd2FpdCBndWlsZC5hdWRpdF9sb2dzKGxpbWl0PU5vbmUsIHVzZXI9Z3VpbGQubWUpLmZsYXR0ZW4oKQogICAgICAgICAgICBhd2FpdCBjaGFubmVsLnNlbmQoJ0kgbWFkZSB7fSBtb2RlcmF0aW9uIGFjdGlvbnMuJy5mb3JtYXQobGVuKGVudHJpZXMpKSkKCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgbGltaXQ6IE9wdGlvbmFsWzpjbGFzczpgaW50YF0KICAgICAgICAgICAgVGhlIG51bWJlciBvZiBlbnRyaWVzIHRvIHJldHJpZXZlLiBJZiBgYE5vbmVgYCByZXRyaWV2ZSBhbGwgZW50cmllcy4KICAgICAgICBiZWZvcmU6IFVuaW9uWzpjbGFzczpgYWJjLlNub3dmbGFrZWAsIDpjbGFzczpgZGF0ZXRpbWUuZGF0ZXRpbWVgXQogICAgICAgICAgICBSZXRyaWV2ZSBlbnRyaWVzIGJlZm9yZSB0aGlzIGRhdGUgb3IgZW50cnkuCiAgICAgICAgICAgIElmIGEgZGF0ZSBpcyBwcm92aWRlZCBpdCBtdXN0IGJlIGEgdGltZXpvbmUtbmFpdmUgZGF0ZXRpbWUgcmVwcmVzZW50aW5nIFVUQyB0aW1lLgogICAgICAgIGFmdGVyOiBVbmlvbls6Y2xhc3M6YGFiYy5Tbm93Zmxha2VgLCA6Y2xhc3M6YGRhdGV0aW1lLmRhdGV0aW1lYF0KICAgICAgICAgICAgUmV0cmlldmUgZW50cmllcyBhZnRlciB0aGlzIGRhdGUgb3IgZW50cnkuCiAgICAgICAgICAgIElmIGEgZGF0ZSBpcyBwcm92aWRlZCBpdCBtdXN0IGJlIGEgdGltZXpvbmUtbmFpdmUgZGF0ZXRpbWUgcmVwcmVzZW50aW5nIFVUQyB0aW1lLgogICAgICAgIG9sZGVzdF9maXJzdDogOmNsYXNzOmBib29sYAogICAgICAgICAgICBJZiBzZXQgdG8gYGBUcnVlYGAsIHJldHVybiBlbnRyaWVzIGluIG9sZGVzdC0+bmV3ZXN0IG9yZGVyLiBEZWZhdWx0cyB0byBgYFRydWVgYCBpZgogICAgICAgICAgICBgYGFmdGVyYGAgaXMgc3BlY2lmaWVkLCBvdGhlcndpc2UgYGBGYWxzZWBgLgogICAgICAgIHVzZXI6IDpjbGFzczpgYWJjLlNub3dmbGFrZWAKICAgICAgICAgICAgVGhlIG1vZGVyYXRvciB0byBmaWx0ZXIgZW50cmllcyBmcm9tLgogICAgICAgIGFjdGlvbjogOmNsYXNzOmBBdWRpdExvZ0FjdGlvbmAKICAgICAgICAgICAgVGhlIGFjdGlvbiB0byBmaWx0ZXIgd2l0aC4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBZb3UgYXJlIG5vdCBhbGxvd2VkIHRvIGZldGNoIGF1ZGl0IGxvZ3MKICAgICAgICBIVFRQRXhjZXB0aW9uCiAgICAgICAgICAgIEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSBhdWRpdCBsb2dzLgoKICAgICAgICBZaWVsZHMKICAgICAgICAtLS0tLS0tLQogICAgICAgIDpjbGFzczpgQXVkaXRMb2dFbnRyeWAKICAgICAgICAgICAgVGhlIGF1ZGl0IGxvZyBlbnRyeS4KICAgICAgICAiIiIKICAgICAgICBpZiB1c2VyOgogICAgICAgICAgICB1c2VyID0gdXNlci5pZAoKICAgICAgICBpZiBhY3Rpb246CiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbi52YWx1ZQoKICAgICAgICByZXR1cm4gQXVkaXRMb2dJdGVyYXRvcihzZWxmLCBiZWZvcmU9YmVmb3JlLCBhZnRlcj1hZnRlciwgbGltaXQ9bGltaXQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkZXN0X2ZpcnN0PW9sZGVzdF9maXJzdCwgdXNlcl9pZD11c2VyLCBhY3Rpb25fdHlwZT1hY3Rpb24pCgogICAgYXN5bmMgZGVmIHdpZGdldChzZWxmKToKICAgICAgICAiIiJ8Y29yb3wKCiAgICAgICAgUmV0dXJucyB0aGUgd2lkZ2V0IG9mIHRoZSBndWlsZC4KCiAgICAgICAgLi4gbm90ZTo6CgogICAgICAgICAgICBUaGUgZ3VpbGQgbXVzdCBoYXZlIHRoZSB3aWRnZXQgZW5hYmxlZCB0byBnZXQgdGhpcyBpbmZvcm1hdGlvbi4KCiAgICAgICAgUmFpc2VzCiAgICAgICAgLS0tLS0tLQogICAgICAgIEZvcmJpZGRlbgogICAgICAgICAgICBUaGUgd2lkZ2V0IGZvciB0aGlzIGd1aWxkIGlzIGRpc2FibGVkLgogICAgICAgIEhUVFBFeGNlcHRpb24KICAgICAgICAgICAgUmV0cmlldmluZyB0aGUgd2lkZ2V0IGZhaWxlZC4KCiAgICAgICAgUmV0dXJucwogICAgICAgIC0tLS0tLS0tCiAgICAgICAgOmNsYXNzOmBXaWRnZXRgCiAgICAgICAgICAgIFRoZSBndWlsZCdzIHdpZGdldC4KICAgICAgICAiIiIKICAgICAgICBkYXRhID0gYXdhaXQgc2VsZi5fc3RhdGUuaHR0cC5nZXRfd2lkZ2V0KHNlbGYuaWQpCgogICAgICAgIHJldHVybiBXaWRnZXQoc3RhdGU9c2VsZi5fc3RhdGUsIGRhdGE9ZGF0YSkKCiAgICBhc3luYyBkZWYgY2h1bmsoc2VsZiwgKiwgY2FjaGU9VHJ1ZSk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFJlcXVlc3RzIGFsbCBtZW1iZXJzIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3VpbGQuIEluIG9yZGVyIHRvIHVzZSB0aGlzLAogICAgICAgIDptZXRoOmBJbnRlbnRzLm1lbWJlcnNgIG11c3QgYmUgZW5hYmxlZC4KCiAgICAgICAgVGhpcyBpcyBhIHdlYnNvY2tldCBvcGVyYXRpb24gYW5kIGNhbiBiZSBzbG93LgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjUKCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgY2FjaGU6IDpjbGFzczpgYm9vbGAKICAgICAgICAgICAgV2hldGhlciB0byBjYWNoZSB0aGUgbWVtYmVycyBhcyB3ZWxsLgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgQ2xpZW50RXhjZXB0aW9uCiAgICAgICAgICAgIFRoZSBtZW1iZXJzIGludGVudCBpcyBub3QgZW5hYmxlZC4KICAgICAgICAiIiIKCiAgICAgICAgaWYgbm90IHNlbGYuX3N0YXRlLl9pbnRlbnRzLm1lbWJlcnM6CiAgICAgICAgICAgIHJhaXNlIENsaWVudEV4Y2VwdGlvbignSW50ZW50cy5tZW1iZXJzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdGhpcy4nKQoKICAgICAgICBpZiBub3Qgc2VsZi5fc3RhdGUuaXNfZ3VpbGRfZXZpY3RlZChzZWxmKToKICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHNlbGYuX3N0YXRlLmNodW5rX2d1aWxkKHNlbGYsIGNhY2hlPWNhY2hlKQoKICAgIGFzeW5jIGRlZiBxdWVyeV9tZW1iZXJzKHNlbGYsIHF1ZXJ5PU5vbmUsICosIGxpbWl0PTUsIHVzZXJfaWRzPU5vbmUsIHByZXNlbmNlcz1GYWxzZSwgY2FjaGU9VHJ1ZSk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIFJlcXVlc3QgbWVtYmVycyB0aGF0IGJlbG9uZyB0byB0aGlzIGd1aWxkIHdob3NlIHVzZXJuYW1lIHN0YXJ0cyB3aXRoCiAgICAgICAgdGhlIHF1ZXJ5IGdpdmVuLgoKICAgICAgICBUaGlzIGlzIGEgd2Vic29ja2V0IG9wZXJhdGlvbiBhbmQgY2FuIGJlIHNsb3cuCgogICAgICAgIC4uIHZlcnNpb25hZGRlZDo6IDEuMwoKICAgICAgICBQYXJhbWV0ZXJzCiAgICAgICAgLS0tLS0tLS0tLS0KICAgICAgICBxdWVyeTogT3B0aW9uYWxbOmNsYXNzOmBzdHJgXQogICAgICAgICAgICBUaGUgc3RyaW5nIHRoYXQgdGhlIHVzZXJuYW1lJ3Mgc3RhcnQgd2l0aC4KICAgICAgICBsaW1pdDogOmNsYXNzOmBpbnRgCiAgICAgICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBtZW1iZXJzIHRvIHNlbmQgYmFjay4gVGhpcyBtdXN0IGJlCiAgICAgICAgICAgIGEgbnVtYmVyIGJldHdlZW4gNSBhbmQgMTAwLgogICAgICAgIHByZXNlbmNlczogOmNsYXNzOmBib29sYAogICAgICAgICAgICBXaGV0aGVyIHRvIHJlcXVlc3QgZm9yIHByZXNlbmNlcyB0byBiZSBwcm92aWRlZC4gVGhpcyBkZWZhdWx0cwogICAgICAgICAgICB0byBgYEZhbHNlYGAuCgogICAgICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjYKCiAgICAgICAgY2FjaGU6IDpjbGFzczpgYm9vbGAKICAgICAgICAgICAgV2hldGhlciB0byBjYWNoZSB0aGUgbWVtYmVycyBpbnRlcm5hbGx5LiBUaGlzIG1ha2VzIG9wZXJhdGlvbnMKICAgICAgICAgICAgc3VjaCBhcyA6bWV0aDpgZ2V0X21lbWJlcmAgd29yayBmb3IgdGhvc2UgdGhhdCBtYXRjaGVkLgogICAgICAgIHVzZXJfaWRzOiBPcHRpb25hbFtMaXN0WzpjbGFzczpgaW50YF1dCiAgICAgICAgICAgIExpc3Qgb2YgdXNlciBJRHMgdG8gc2VhcmNoIGZvci4gSWYgdGhlIHVzZXIgSUQgaXMgbm90IGluIHRoZSBndWlsZCB0aGVuIGl0IHdvbid0IGJlIHJldHVybmVkLgoKICAgICAgICAgICAgLi4gdmVyc2lvbmFkZGVkOjogMS40CgoKICAgICAgICBSYWlzZXMKICAgICAgICAtLS0tLS0tCiAgICAgICAgYXN5bmNpby5UaW1lb3V0RXJyb3IKICAgICAgICAgICAgVGhlIHF1ZXJ5IHRpbWVkIG91dCB3YWl0aW5nIGZvciB0aGUgbWVtYmVycy4KICAgICAgICBWYWx1ZUVycm9yCiAgICAgICAgICAgIEludmFsaWQgcGFyYW1ldGVycyB3ZXJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb24KICAgICAgICBDbGllbnRFeGNlcHRpb24KICAgICAgICAgICAgVGhlIHByZXNlbmNlcyBpbnRlbnQgaXMgbm90IGVuYWJsZWQuCgogICAgICAgIFJldHVybnMKICAgICAgICAtLS0tLS0tLQogICAgICAgIExpc3RbOmNsYXNzOmBNZW1iZXJgXQogICAgICAgICAgICBUaGUgbGlzdCBvZiBtZW1iZXJzIHRoYXQgaGF2ZSBtYXRjaGVkIHRoZSBxdWVyeS4KICAgICAgICAiIiIKCiAgICAgICAgaWYgcHJlc2VuY2VzIGFuZCBub3Qgc2VsZi5fc3RhdGUuX2ludGVudHMucHJlc2VuY2VzOgogICAgICAgICAgICByYWlzZSBDbGllbnRFeGNlcHRpb24oJ0ludGVudHMucHJlc2VuY2VzIG11c3QgYmUgZW5hYmxlZCB0byB1c2UgdGhpcy4nKQoKICAgICAgICBpZiBxdWVyeSBpcyBOb25lOgogICAgICAgICAgICBpZiBxdWVyeSA9PSAnJzoKICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ0Nhbm5vdCBwYXNzIGVtcHR5IHF1ZXJ5IHN0cmluZy4nKQoKICAgICAgICAgICAgaWYgdXNlcl9pZHMgaXMgTm9uZToKICAgICAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ011c3QgcGFzcyBlaXRoZXIgcXVlcnkgb3IgdXNlcl9pZHMnKQoKICAgICAgICBpZiB1c2VyX2lkcyBpcyBub3QgTm9uZSBhbmQgcXVlcnkgaXMgbm90IE5vbmU6CiAgICAgICAgICAgIHJhaXNlIFZhbHVlRXJyb3IoJ0Nhbm5vdCBwYXNzIGJvdGggcXVlcnkgYW5kIHVzZXJfaWRzJykKCiAgICAgICAgaWYgdXNlcl9pZHMgaXMgbm90IE5vbmUgYW5kIG5vdCB1c2VyX2lkczoKICAgICAgICAgICAgcmFpc2UgVmFsdWVFcnJvcigndXNlcl9pZHMgbXVzdCBjb250YWluIGF0IGxlYXN0IDEgdmFsdWUnKQoKICAgICAgICBsaW1pdCA9IG1pbigxMDAsIGxpbWl0IG9yIDUpCiAgICAgICAgcmV0dXJuIGF3YWl0IHNlbGYuX3N0YXRlLnF1ZXJ5X21lbWJlcnMoc2VsZiwgcXVlcnk9cXVlcnksIGxpbWl0PWxpbWl0LCB1c2VyX2lkcz11c2VyX2lkcywgcHJlc2VuY2VzPXByZXNlbmNlcywgY2FjaGU9Y2FjaGUpCgogICAgYXN5bmMgZGVmIGNoYW5nZV92b2ljZV9zdGF0ZShzZWxmLCAqLCBjaGFubmVsLCBzZWxmX211dGU9RmFsc2UsIHNlbGZfZGVhZj1GYWxzZSk6CiAgICAgICAgIiIifGNvcm98CgogICAgICAgIENoYW5nZXMgY2xpZW50J3Mgdm9pY2Ugc3RhdGUgaW4gdGhlIGd1aWxkLgoKICAgICAgICAuLiB2ZXJzaW9uYWRkZWQ6OiAxLjQKCiAgICAgICAgUGFyYW1ldGVycwogICAgICAgIC0tLS0tLS0tLS0tCiAgICAgICAgY2hhbm5lbDogT3B0aW9uYWxbOmNsYXNzOmBWb2ljZUNoYW5uZWxgXQogICAgICAgICAgICBDaGFubmVsIHRoZSBjbGllbnQgd2FudHMgdG8gam9pbi4gVXNlIGBgTm9uZWBgIHRvIGRpc2Nvbm5lY3QuCiAgICAgICAgc2VsZl9tdXRlOiA6Y2xhc3M6YGJvb2xgCiAgICAgICAgICAgIEluZGljYXRlcyBpZiB0aGUgY2xpZW50IHNob3VsZCBiZSBzZWxmLW11dGVkLgogICAgICAgIHNlbGZfZGVhZjogOmNsYXNzOmBib29sYAogICAgICAgICAgICBJbmRpY2F0ZXMgaWYgdGhlIGNsaWVudCBzaG91bGQgYmUgc2VsZi1kZWFmZW5lZC4KICAgICAgICAiIiIKICAgICAgICB3cyA9IHNlbGYuX3N0YXRlLl9nZXRfd2Vic29ja2V0KHNlbGYuaWQpCiAgICAgICAgY2hhbm5lbF9pZCA9IGNoYW5uZWwuaWQgaWYgY2hhbm5lbCBlbHNlIE5vbmUKICAgICAgICBhd2FpdCB3cy52b2ljZV9zdGF0ZShzZWxmLmlkLCBjaGFubmVsX2lkLCBzZWxmX211dGUsIHNlbGZfZGVhZikK
